/******/ var __webpack_modules__ = ({

/***/ "./unified-latex-lint/utils/replace-node.ts":
/*!**************************************************!*\
  !*** ./unified-latex-lint/utils/replace-node.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "replaceNodeDuringVisit": () => (/* binding */ replaceNodeDuringVisit)
/* harmony export */ });
/**
 * Replaces the current node with `replacement`. It is assumed that the current
 * node is in an array that is a child of a parent element. If this is not the case,
 * the function will error.
 */
function replaceNodeDuringVisit(replacement, info) {
    const parent = info.parents[0];
    if (!parent) {
        throw new Error(`Cannot replace node: parent not found`);
    }
    const container = parent[info.key];
    if (!Array.isArray(container)) {
        throw new Error(`Cannot replace node: containing array not found`);
    }
    if (info.index == null) {
        throw new Error(`Cannot replace node: node index undefined`);
    }
    if (!Array.isArray(replacement)) {
        container[info.index] = replacement;
    }
    else {
        container.splice(info.index, 1, ...replacement);
    }
}


/***/ }),

/***/ "./unified-latex-util-match/index.ts":
/*!*******************************************!*\
  !*** ./unified-latex-util-match/index.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "anyEnvironment": () => (/* binding */ anyEnvironment),
/* harmony export */   "anyMacro": () => (/* binding */ anyMacro),
/* harmony export */   "anyString": () => (/* binding */ anyString),
/* harmony export */   "argument": () => (/* binding */ argument),
/* harmony export */   "blankArgument": () => (/* binding */ blankArgument),
/* harmony export */   "comment": () => (/* binding */ comment),
/* harmony export */   "environment": () => (/* binding */ environment),
/* harmony export */   "group": () => (/* binding */ group),
/* harmony export */   "macro": () => (/* binding */ macro),
/* harmony export */   "match": () => (/* reexport safe */ _libs_match__WEBPACK_IMPORTED_MODULE_0__.match),
/* harmony export */   "math": () => (/* binding */ math),
/* harmony export */   "parbreak": () => (/* binding */ parbreak),
/* harmony export */   "string": () => (/* binding */ string),
/* harmony export */   "whitespace": () => (/* binding */ whitespace)
/* harmony export */ });
/* harmony import */ var _libs_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/match */ "./unified-latex-util-match/libs/match.ts");


const { anyEnvironment, anyMacro, anyString, argument, blankArgument, comment, environment, group, macro, math, parbreak, string, whitespace, } = _libs_match__WEBPACK_IMPORTED_MODULE_0__.match;
// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to match different `Ast.Node` types in a `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you need a type-guard to ensure a node is of a certain type; for example, during a call to `unified-latex-until-visit`.
 */


/***/ }),

/***/ "./unified-latex-util-match/libs/match.ts":
/*!************************************************!*\
  !*** ./unified-latex-util-match/libs/match.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "match": () => (/* binding */ match)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-print-raw */ "./unified-latex-util-print-raw/index.ts");

/**
 * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros
 * and generates a hash for quick lookup.
 */
function createMacroMatcher(macros) {
    // We first make sure we have a record type with keys being the macro's contents
    const macrosHash = Array.isArray(macros)
        ? macros.length > 0
            ? typeof macros[0] === "string"
                ? Object.fromEntries(macros.map((macro) => {
                    if (typeof macro !== "string") {
                        throw new Error("Wrong branch of map function");
                    }
                    return [macro, {}];
                }))
                : Object.fromEntries(macros.map((macro) => {
                    if (typeof macro === "string") {
                        throw new Error("Wrong branch of map function");
                    }
                    if (macro.escapeToken != null) {
                        return [
                            macro.content,
                            { escapeToken: macro.escapeToken },
                        ];
                    }
                    return [macro.content, {}];
                }))
            : {}
        : macros;
    return function matchAgainstMacros(node) {
        if (node == null || node.type !== "macro") {
            return false;
        }
        // At this point we have a macro type
        const spec = macrosHash[node.content];
        if (!spec) {
            return false;
        }
        if (typeof spec === "object" && "escapeToken" in spec) {
            return (spec.escapeToken == null ||
                spec.escapeToken === node.escapeToken);
        }
        return true;
    };
}
/**
 * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros
 * and generates a hash for quick lookup.
 */
function createEnvironmentMatcher(macros) {
    // We first make sure we have a record type with keys being the macro's contents
    const environmentsHash = Array.isArray(macros)
        ? Object.fromEntries(macros.map((str) => {
            return [str, {}];
        }))
        : macros;
    return function matchAgainstEnvironments(node) {
        if (!match.anyEnvironment(node)) {
            return false;
        }
        // At this point we have an environment type
        const envName = (0,_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)(node.env);
        const spec = environmentsHash[envName];
        if (!spec) {
            return false;
        }
        return true;
    };
}
/**
 * Functions to match different types of nodes.
 */
const match = {
    macro(node, macroName) {
        if (node == null) {
            return false;
        }
        return (node.type === "macro" &&
            (macroName == null || node.content === macroName));
    },
    anyMacro(node) {
        return match.macro(node);
    },
    environment(node, envName) {
        if (node == null) {
            return false;
        }
        return ((node.type === "environment" || node.type === "mathenv") &&
            (envName == null || (0,_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)(node.env) === envName));
    },
    anyEnvironment(node) {
        return match.environment(node);
    },
    comment(node) {
        if (node == null) {
            return false;
        }
        return node.type === "comment";
    },
    parbreak(node) {
        if (node == null) {
            return false;
        }
        return node.type === "parbreak";
    },
    whitespace(node) {
        if (node == null) {
            return false;
        }
        return node.type === "whitespace";
    },
    /**
     * Matches whitespace or a comment with leading whitespace.
     */
    whitespaceLike(node) {
        if (node == null) {
            return false;
        }
        return (node.type === "whitespace" ||
            (node.type === "whitespace" && node.leadingWhitespace === true));
    },
    string(node, value) {
        if (node == null) {
            return false;
        }
        return (node.type === "string" && (value == null || node.content === value));
    },
    anyString(node) {
        return match.string(node);
    },
    group(node) {
        if (node == null) {
            return false;
        }
        return node.type === "group";
    },
    argument(node) {
        if (node == null) {
            return false;
        }
        return node.type === "argument";
    },
    blankArgument(node) {
        if (!match.argument(node)) {
            return false;
        }
        return (node.openMark === "" &&
            node.closeMark === "" &&
            node.content.length === 0);
    },
    math(node) {
        if (node == null) {
            return false;
        }
        return node.type === "displaymath" || node.type === "inlinemath";
    },
    createMacroMatcher,
    createEnvironmentMatcher,
};


/***/ }),

/***/ "./unified-latex-util-print-raw/index.ts":
/*!***********************************************!*\
  !*** ./unified-latex-util-print-raw/index.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linebreak": () => (/* reexport safe */ _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__.linebreak),
/* harmony export */   "printRaw": () => (/* reexport safe */ _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)
/* harmony export */ });
/* harmony import */ var _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/print-raw */ "./unified-latex-util-print-raw/libs/print-raw.ts");

// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to print a `unified-latex` Abstract Syntax Tree (AST) to a string.
 *
 * ## When should I use this?
 *
 * If you want to directly print an `Ast.Ast` to a string without any pretty printing or formatting.
 */


/***/ }),

/***/ "./unified-latex-util-print-raw/libs/print-raw.ts":
/*!********************************************************!*\
  !*** ./unified-latex-util-print-raw/libs/print-raw.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linebreak": () => (/* binding */ linebreak),
/* harmony export */   "printRaw": () => (/* binding */ printRaw)
/* harmony export */ });
const linebreak = Symbol("linebreak");
const ESCAPE = "\\";
/**
 * Renders the AST to an array inserting `linebreak` where needed;
 * This array may be nested.
 *
 * @param {*} node
 */
function _printRaw(node) {
    if (typeof node === "string") {
        return [node];
    }
    if (Array.isArray(node)) {
        return [].concat(...node.map((n) => _printRaw(n)));
    }
    // tmp variables
    let argsString, escape;
    switch (node.type) {
        case "root":
            return _printRaw(node.content);
        case "argument":
            return [node.openMark, ..._printRaw(node.content), node.closeMark];
        case "comment":
            var suffix = node.suffixParbreak ? "" : linebreak;
            // A comment is responsible for printing its own leading whitespace
            var leadingWhitespace = "";
            if (node.sameline && node.leadingWhitespace) {
                leadingWhitespace = " ";
            }
            if (node.sameline) {
                return [
                    leadingWhitespace,
                    "%",
                    ..._printRaw(node.content),
                    suffix,
                ];
            }
            return [linebreak, "%", ..._printRaw(node.content), suffix];
        case "environment":
        case "mathenv":
        case "verbatim":
            var env = _printRaw(node.env);
            var envStart = [ESCAPE + "begin{", ...env, "}"];
            var envEnd = [ESCAPE + "end{", ...env, "}"];
            argsString =
                node.args == null ? [] : _printRaw(node.args);
            return [
                ...envStart,
                ...argsString,
                ..._printRaw(node.content),
                ...envEnd,
            ];
        case "displaymath":
            return [ESCAPE + "[", ..._printRaw(node.content), ESCAPE + "]"];
        case "group":
            return ["{", ..._printRaw(node.content), "}"];
        case "inlinemath":
            return ["$", ..._printRaw(node.content), "$"];
        case "macro":
            argsString = node.args == null ? [] : _printRaw(node.args);
            escape = node.escapeToken == null ? ESCAPE : node.escapeToken;
            return [escape, ..._printRaw(node.content), ...argsString];
        case "parbreak":
            return [linebreak, linebreak];
        case "string":
            return [node.content];
        case "verb":
            return [
                ESCAPE,
                node.env,
                node.escape,
                ..._printRaw(node.content),
                node.escape,
            ];
        case "whitespace":
            return [" "];
        default:
            console.warn("Cannot find render for node ", node, `(of type ${typeof node})`);
            return ["" + node];
    }
}
function printRaw(node, options) {
    const asArray = options != null ? options.asArray : false;
    const printedTokens = _printRaw(node);
    if (asArray) {
        return printedTokens;
    }
    return printedTokens.map((x) => (x === linebreak ? "\n" : x)).join("");
}


/***/ }),

/***/ "./unified-latex-util-replace/libs/replace-node.ts":
/*!*********************************************************!*\
  !*** ./unified-latex-util-replace/libs/replace-node.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "replaceNode": () => (/* binding */ replaceNode)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-visit */ "./unified-latex-util-visit/index.ts");

/**
 * Recursively replace nodes in `ast`. The `visitor` function is called on each node. If
 * `visitor` returns a node or an array of nodes, those nodes replace the node passed to `visitor`.
 * If `null` is returned, the node is deleted. If `undefined` is returned, no replacement happens.
 */
function replaceNode(ast, visitor) {
    (0,_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_0__.visit)(ast, (node, info) => {
        let replacement = visitor(node, info.context);
        // Returning `undefined` or the same node means we shouldn't replace that node
        if (typeof replacement === "undefined" || replacement === node) {
            return;
        }
        if (!info.containingArray || info.index == null) {
            throw new Error("Trying to delete node, but cannot find containing array");
        }
        if (replacement === null ||
            (Array.isArray(replacement) && replacement.length === 0)) {
            // A null return means that we delete the current node
            info.containingArray.splice(info.index, 1);
            return info.index;
        }
        if (!Array.isArray(replacement)) {
            replacement = [replacement];
        }
        info.containingArray.splice(info.index, 1, ...replacement);
        // We don't want to *reprocess* the nodes we just inserted into the array,
        // lest we get stuck in a recursive loop if the replacement contains the original.
        // Thus we jump to the index after our replacements.
        return info.index + replacement.length;
    });
}


/***/ }),

/***/ "./unified-latex-util-replace/libs/replace-streaming-command.ts":
/*!**********************************************************************!*\
  !*** ./unified-latex-util-replace/libs/replace-streaming-command.ts ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "replaceStreamingCommand": () => (/* binding */ replaceStreamingCommand),
/* harmony export */   "replaceStreamingCommandInGroup": () => (/* binding */ replaceStreamingCommandInGroup)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");
/* harmony import */ var _unified_latex_util_split__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../unified-latex-util-split */ "./unified-latex-util-split/index.ts");
/* harmony import */ var _unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../unified-latex-util-trim */ "./unified-latex-util-trim/index.ts");
/* harmony import */ var _utils_first_significant_node__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/first-significant-node */ "./unified-latex-util-replace/libs/utils/first-significant-node.ts");
/* harmony import */ var _utils_replace_streaming_command_in_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/replace-streaming-command-in-array */ "./unified-latex-util-replace/libs/utils/replace-streaming-command-in-array.ts");
/* harmony import */ var _utils_wrap_significant_content__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/wrap-significant-content */ "./unified-latex-util-replace/libs/utils/wrap-significant-content.ts");






/**
 * Process streaming commands in a group. If needed, "escape" the group.
 * For example, `{\bfseries xx}` -> `\textbf{xx}`, but `{foo \bfseries xx}` -> `{foo \textbf{xx}}`.
 */
function replaceStreamingCommandInGroup(group, isStreamingCommand, replacer) {
    const content = group.content;
    // If the group started with a streaming command, we want to pop
    // out of the group. E.g. `{\bfseries foo}` -> `\textbf{foo}` and not `{\textbf{foo}}`
    let popFromGroup = isStreamingCommand((0,_utils_first_significant_node__WEBPACK_IMPORTED_MODULE_3__.firstSignificantNode)(content));
    let innerProcessed = replaceStreamingCommand(content, isStreamingCommand, replacer);
    // If the group consisted of just streaming commands (for some reason...)
    // it should be eliminated
    if (innerProcessed.length === 0) {
        return [];
    }
    if (popFromGroup) {
        return innerProcessed;
    }
    else {
        return [{ type: "group", content: innerProcessed }];
    }
}
/**
 * Given a group or a node array, look for streaming commands (e.g., `\bfseries`) and replace them
 * with the specified macro. The "arguments" of the streaming command are passed to `replacer` and the return
 * value of `replacer` is inserted into the stream.
 *
 * By default, this command will split at parbreaks (since commands like `\textbf{...} do not accept parbreaks in their
 * contents) and call `replacer` multiple times, once per paragraph.
 */
function replaceStreamingCommand(ast, isStreamingCommand, replacer) {
    if (typeof isStreamingCommand !== "function") {
        throw new Error(`'isStreamingCommand' must be a function, not '${typeof isStreamingCommand}'`);
    }
    let processedContent = [];
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.group(ast)) {
        processedContent = replaceStreamingCommandInGroup(ast, isStreamingCommand, replacer);
    }
    if (Array.isArray(ast)) {
        // Streaming commands that come at the end of a sequence of nodes don't do anything.
        // They also will consume whitespace, so we should remove them and the whitespace.
        const nodes = ast;
        let scanIndex = nodes.length;
        let sliceIndex = scanIndex;
        while (scanIndex > 0 &&
            (isStreamingCommand(nodes[scanIndex - 1]) ||
                _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(nodes[scanIndex - 1]))) {
            scanIndex--;
            if (isStreamingCommand(nodes[scanIndex])) {
                sliceIndex = scanIndex;
            }
        }
        if (sliceIndex !== nodes.length) {
            nodes.splice(sliceIndex);
        }
        const isPar = (node) => _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.parbreak(node) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.macro(node, "par");
        // We split on both a parbreak and a literal `\par`. But we will
        // normalize everything to be parbreaks
        const splitByPar = (0,_unified_latex_util_split__WEBPACK_IMPORTED_MODULE_1__.splitOnCondition)(nodes, isPar);
        splitByPar.separators = splitByPar.separators.map((sep) => _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.parbreak(sep) ? sep : { type: "parbreak" });
        const replacers = [];
        let segments = splitByPar.segments.map((segment) => {
            function applyAccumulatedReplacers(nodes) {
                if (replacers.length === 0) {
                    return nodes;
                }
                return (0,_utils_wrap_significant_content__WEBPACK_IMPORTED_MODULE_5__.wrapSignificantContent)(nodes, composeReplacers(replacers));
            }
            const { foundStreamingCommands } = (0,_utils_replace_streaming_command_in_array__WEBPACK_IMPORTED_MODULE_4__.replaceStreamingCommandInArray)(segment, isStreamingCommand, replacer);
            // All streaming commands in `segment` have now been replaced. However,
            // there might be commands from the previous paragraphs that should wrap
            // the current segment!
            const ret = applyAccumulatedReplacers(segment);
            // Any streaming commands from this segment will carry over to the next,
            // so keep track of them.
            foundStreamingCommands.forEach((macro) => {
                replacers.push((nodes) => {
                    const ret = replacer(nodes, macro);
                    if (!Array.isArray(ret)) {
                        return [ret];
                    }
                    return ret;
                });
            });
            return ret;
        });
        // Leading/trailing whitespace was hoisted in front/back of each replacer.
        // Since we're separated by parbreaks, we can safely trim all that whitespace.
        if (segments.length > 1) {
            segments.forEach((segment, i) => {
                if (i === 0) {
                    (0,_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__.trimEnd)(segment);
                }
                else if (i === segments.length - 1) {
                    (0,_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__.trimStart)(segment);
                }
                else {
                    (0,_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__.trim)(segment);
                }
            });
        }
        processedContent = (0,_unified_latex_util_split__WEBPACK_IMPORTED_MODULE_1__.unsplitOnMacro)({
            segments: segments,
            macros: splitByPar.separators,
        });
    }
    return processedContent;
}
/**
 * Given a sequence of replacer functions `[f, g, h]` return
 * `h \circ g \circ f`
 *
 * @param {((nodes: Ast.Node[]) => Ast.Node)[]} replacers
 * @returns {(nodes: Ast.Node[]) => Ast.Node}
 */
function composeReplacers(replacers) {
    if (replacers.length === 0) {
        throw new Error("Cannot compose zero replacement functions");
    }
    return (nodes) => {
        let ret = nodes;
        for (let i = 0; i < replacers.length; i++) {
            const func = replacers[i];
            ret = func(ret);
        }
        return ret;
    };
}


/***/ }),

/***/ "./unified-latex-util-replace/libs/unified-latex-streaming-command.ts":
/*!****************************************************************************!*\
  !*** ./unified-latex-util-replace/libs/unified-latex-streaming-command.ts ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unifiedLatexReplaceStreamingCommands": () => (/* binding */ unifiedLatexReplaceStreamingCommands)
/* harmony export */ });
/* harmony import */ var _unified_latex_lint_utils_replace_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-lint/utils/replace-node */ "./unified-latex-lint/utils/replace-node.ts");
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");
/* harmony import */ var _unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../unified-latex-util-trim */ "./unified-latex-util-trim/index.ts");
/* harmony import */ var _unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../unified-latex-util-visit */ "./unified-latex-util-visit/index.ts");
/* harmony import */ var _replace_streaming_command__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./replace-streaming-command */ "./unified-latex-util-replace/libs/replace-streaming-command.ts");





/**
 * Unified plugin to replace all found streaming commands with their argument-style equivalents.
 * This only applies to sections of the tree with no math ancestor.
 *
 * @param options.replacer A record of macro names and replacer functions. A replacer function accepts content and the original streaming command and is expected to return the argument-style command. It may be called multiple times per streaming command.
 */
const unifiedLatexReplaceStreamingCommands = function unifiedLatexReplaceStreamingCommands(options) {
    const { replacers = {} } = options || {};
    const isReplaceable = _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__.match.createMacroMatcher(replacers);
    return (tree) => {
        (0,_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_3__.visit)(tree, (group, info) => {
            if (info.context.hasMathModeAncestor ||
                !group.content.some(isReplaceable)) {
                return;
            }
            let fixed = (0,_replace_streaming_command__WEBPACK_IMPORTED_MODULE_4__.replaceStreamingCommand)(group, isReplaceable, (content, command) => {
                return replacers[command.content](content, command);
            });
            // We cannot replace the node unless we can access the containing array.
            if (!info.containingArray || info.index == null) {
                return;
            }
            // `fixed` may consist of only whitespace. If this is the case,
            // surrounding whitespace must trimmed before
            // inserting the group's contents.
            const prevToken = info.containingArray[info.index - 1];
            const nextToken = info.containingArray[info.index + 1];
            if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__.match.whitespaceLike(prevToken) &&
                _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__.match.whitespaceLike(fixed[0])) {
                (0,_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__.trimStart)(fixed);
            }
            if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__.match.whitespaceLike(nextToken) &&
                _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__.match.whitespaceLike(fixed[fixed.length - 1])) {
                (0,_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_2__.trimEnd)(fixed);
            }
            (0,_unified_latex_lint_utils_replace_node__WEBPACK_IMPORTED_MODULE_0__.replaceNodeDuringVisit)(fixed, info);
        }, { test: _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_1__.match.group });
        (0,_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_3__.visit)(tree, (nodes, info) => {
            if (info.context.hasMathModeAncestor ||
                !nodes.some(isReplaceable)) {
                return;
            }
            const replaced = (0,_replace_streaming_command__WEBPACK_IMPORTED_MODULE_4__.replaceStreamingCommand)(nodes, isReplaceable, (content, command) => {
                return replacers[command.content](content, command);
            });
            // If we get back a different array than we input, the replacement did
            // not happen in-place. In this case we need to manipulate `nodes`.
            if (replaced !== nodes) {
                nodes.length = 0;
                nodes.push(...replaced);
            }
        }, { includeArrays: true, test: Array.isArray });
    };
};


/***/ }),

/***/ "./unified-latex-util-replace/libs/utils/first-significant-node.ts":
/*!*************************************************************************!*\
  !*** ./unified-latex-util-replace/libs/utils/first-significant-node.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "firstSignificantNode": () => (/* binding */ firstSignificantNode)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");

/**
 * Returns the first non-whitespace/non-comment node in `nodes`. If there is no such
 * node, `null` is returned.
 */
function firstSignificantNode(nodes) {
    let firstNode = null;
    for (const node of nodes) {
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(node)) {
            continue;
        }
        firstNode = node;
        break;
    }
    return firstNode;
}


/***/ }),

/***/ "./unified-latex-util-replace/libs/utils/join-without-excess-whitespace.ts":
/*!*********************************************************************************!*\
  !*** ./unified-latex-util-replace/libs/utils/join-without-excess-whitespace.ts ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "joinWithoutExcessWhitespace": () => (/* binding */ joinWithoutExcessWhitespace)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");
/* harmony import */ var _unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../unified-latex-util-trim */ "./unified-latex-util-trim/index.ts");


/**
 * Is the node space-like? I.e., is it whitespace or
 * a comment with leading whitespace?
 */
function isSpaceLike(node) {
    return (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node) ||
        (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(node) && Boolean(node.leadingWhitespace)));
}
/**
 * Similar to `head.push(...tail)` except that whitespace at the start
 * of `tail` and the end of `head` is collapsed.
 */
function joinWithoutExcessWhitespace(head, tail) {
    if (tail.length === 0) {
        return;
    }
    if (head.length === 0) {
        head.push(...tail);
        return;
    }
    const headEnd = head[head.length - 1];
    const tailStart = tail[0];
    // Whitespace we can just trim off from either end
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(headEnd) && _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(tailStart)) {
        head.push(...tail.slice(1));
        return;
    }
    // If there's no whitespace at one of the ends, no need to worry
    // unless `tailStart` is a comment, in which case it should "eat"
    // the whitespace
    if (!isSpaceLike(headEnd) || !isSpaceLike(tailStart)) {
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(headEnd) && _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(tailStart)) {
            const comment = {
                type: "comment",
                content: tailStart.content,
                sameline: true,
                leadingWhitespace: true,
            };
            tail = tail.slice(1);
            (0,_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_1__.trimStart)(tail);
            head.pop();
            head.push(comment, ...tail);
            return;
        }
        head.push(...tail);
        return;
    }
    // If we're here, we have a comment with leading whitespace on one side
    // and whitespace/comments on the other.
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(headEnd) && _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(tailStart)) {
        if (tailStart.leadingWhitespace || tailStart.sameline) {
            head.push({ type: "comment", content: tailStart.content }, ...tail.slice(1));
            return;
        }
        head.push(...tail);
        return;
    }
    // Exactly one side is a comment, so we should trim the whitespace and keep the comment,
    // but make sure the comment has leading whitespace!
    let comment = _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(headEnd) ? headEnd : tailStart;
    if (!_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(comment)) {
        throw new Error(`Expected a comment but found ${JSON.stringify(comment)}`);
    }
    if (!comment.leadingWhitespace || !comment.sameline) {
        comment = {
            type: "comment",
            content: comment.content,
            leadingWhitespace: true,
            sameline: true,
        };
    }
    head.pop();
    head.push(comment, ...tail.slice(1));
}


/***/ }),

/***/ "./unified-latex-util-replace/libs/utils/replace-streaming-command-in-array.ts":
/*!*************************************************************************************!*\
  !*** ./unified-latex-util-replace/libs/utils/replace-streaming-command-in-array.ts ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "replaceStreamingCommandInArray": () => (/* binding */ replaceStreamingCommandInArray)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../unified-latex-util-trim */ "./unified-latex-util-trim/index.ts");
/* harmony import */ var _join_without_excess_whitespace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./join-without-excess-whitespace */ "./unified-latex-util-replace/libs/utils/join-without-excess-whitespace.ts");
/* harmony import */ var _wrap_significant_content__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wrap-significant-content */ "./unified-latex-util-replace/libs/utils/wrap-significant-content.ts");



/**
 * Replace commands identified by `isStreamingCommand` with the return value of `replacer`.
 * E.g., the array `[head, streamingCommand, ...tail]` will become `[head, replacer(tail, streamingCommand)]`.
 * This function does not split based on parbreaks/etc.. It is right-associative and returns
 * the streaming commands that were encountered.
 */
function replaceStreamingCommandInArray(nodes, isStreamingCommand, replacer) {
    // Streaming commands that come at the end don't do anything,
    // so we should remove them
    while (nodes.length > 0 && isStreamingCommand(nodes[nodes.length - 1])) {
        nodes.pop();
        (0,_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_0__.trimEnd)(nodes);
    }
    const foundStreamingCommands = [];
    for (let i = nodes.length - 1; i >= 0; i--) {
        const node = nodes[i];
        if (isStreamingCommand(node)) {
            const wrapper = (content) => replacer(content, node);
            let tail = nodes.slice(i + 1);
            // Streaming commands are followed by whitespace, which becomes unneeded when the commands are replaced.
            (0,_unified_latex_util_trim__WEBPACK_IMPORTED_MODULE_0__.trimStart)(tail);
            tail = (0,_wrap_significant_content__WEBPACK_IMPORTED_MODULE_2__.wrapSignificantContent)(tail, wrapper);
            foundStreamingCommands.push(node);
            // Trim off what we're about to replace!
            nodes.splice(i);
            (0,_join_without_excess_whitespace__WEBPACK_IMPORTED_MODULE_1__.joinWithoutExcessWhitespace)(nodes, tail);
        }
    }
    return { foundStreamingCommands };
}


/***/ }),

/***/ "./unified-latex-util-replace/libs/utils/wrap-significant-content.ts":
/*!***************************************************************************!*\
  !*** ./unified-latex-util-replace/libs/utils/wrap-significant-content.ts ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "wrapSignificantContent": () => (/* binding */ wrapSignificantContent)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");

/**
 * Wraps `content` in the specified wrapper. This command is roughly equivalent to
 * `wrapper(content)` except that leading and trailing whitespace and comments are extracted
 * from `content` and moved to the front or back of the return array. For example,
 * `[" ", "foo", "bar", "% xxx"]` -> `[" ", wrapped(["foo", "bar"]), "% xxx"]`.
 *
 */
function wrapSignificantContent(content, wrapper) {
    let hoistUntil = 0;
    let hoistAfter = content.length;
    for (let i = 0; i < content.length; i++) {
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(content[i]) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(content[i])) {
            hoistUntil = i + 1;
            continue;
        }
        break;
    }
    for (let j = content.length - 1; j >= 0; j--) {
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(content[j]) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(content[j])) {
            hoistAfter = j;
            continue;
        }
        break;
    }
    if (hoistUntil === 0 && hoistAfter === content.length) {
        return ensureArray(wrapper(content));
    }
    const frontMatter = content.slice(0, hoistUntil);
    const middle = content.slice(hoistUntil, hoistAfter);
    const backMatter = content.slice(hoistAfter, content.length);
    return frontMatter.concat(wrapper(middle), backMatter);
}
function ensureArray(x) {
    if (!Array.isArray(x)) {
        return [x];
    }
    return x;
}


/***/ }),

/***/ "./unified-latex-util-split/index.ts":
/*!*******************************************!*\
  !*** ./unified-latex-util-split/index.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrayJoin": () => (/* reexport safe */ _libs_array_join__WEBPACK_IMPORTED_MODULE_3__.arrayJoin),
/* harmony export */   "splitOnCondition": () => (/* reexport safe */ _libs_split_on_condition__WEBPACK_IMPORTED_MODULE_1__.splitOnCondition),
/* harmony export */   "splitOnMacro": () => (/* reexport safe */ _libs_split_on_macro__WEBPACK_IMPORTED_MODULE_0__.splitOnMacro),
/* harmony export */   "unsplitOnMacro": () => (/* reexport safe */ _libs_unsplit_on_macro__WEBPACK_IMPORTED_MODULE_2__.unsplitOnMacro)
/* harmony export */ });
/* harmony import */ var _libs_split_on_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/split-on-macro */ "./unified-latex-util-split/libs/split-on-macro.ts");
/* harmony import */ var _libs_split_on_condition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/split-on-condition */ "./unified-latex-util-split/libs/split-on-condition.ts");
/* harmony import */ var _libs_unsplit_on_macro__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./libs/unsplit-on-macro */ "./unified-latex-util-split/libs/unsplit-on-macro.ts");
/* harmony import */ var _libs_array_join__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./libs/array-join */ "./unified-latex-util-split/libs/array-join.ts");




// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to manipulate `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you want break apart or join an array of nodes based on a condition. For example,
 * this is used to split on `&` characters in the `align` environment.
 */ 


/***/ }),

/***/ "./unified-latex-util-split/libs/array-join.ts":
/*!*****************************************************!*\
  !*** ./unified-latex-util-split/libs/array-join.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrayJoin": () => (/* binding */ arrayJoin)
/* harmony export */ });
/**
 * Joins an array of arrays with the item `sep`
 */
function arrayJoin(array, sep) {
    return array.flatMap((item, i) => {
        if (i === 0) {
            return item;
        }
        if (Array.isArray(sep)) {
            return [...sep, ...item];
        }
        else {
            return [sep, ...item];
        }
    });
}


/***/ }),

/***/ "./unified-latex-util-split/libs/split-on-condition.ts":
/*!*************************************************************!*\
  !*** ./unified-latex-util-split/libs/split-on-condition.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "splitOnCondition": () => (/* binding */ splitOnCondition)
/* harmony export */ });
/**
 * Split a list of nodes based on whether `splitFunc` returns `true`.
 * If `onlySplitOnFirstOccurrence` is set to true in the `options` object, then
 * there will be at most two segments returned.
 */
function splitOnCondition(nodes, splitFunc = () => false, options) {
    if (!Array.isArray(nodes)) {
        throw new Error(`Can only split an Array, not ${nodes}`);
    }
    const { onlySplitOnFirstOccurrence = false } = options || {};
    const splitIndices = [];
    for (let i = 0; i < nodes.length; i++) {
        if (splitFunc(nodes[i])) {
            splitIndices.push(i);
            if (onlySplitOnFirstOccurrence) {
                break;
            }
        }
    }
    // Short circuit if there is no splitting to be done
    if (splitIndices.length === 0) {
        return { segments: [nodes], separators: [] };
    }
    let separators = splitIndices.map((i) => nodes[i]);
    let segments = splitIndices.map((splitEnd, i) => {
        const splitStart = i === 0 ? 0 : splitIndices[i - 1] + 1;
        return nodes.slice(splitStart, splitEnd);
    });
    segments.push(nodes.slice(splitIndices[splitIndices.length - 1] + 1, nodes.length));
    return { segments, separators };
}


/***/ }),

/***/ "./unified-latex-util-split/libs/split-on-macro.ts":
/*!*********************************************************!*\
  !*** ./unified-latex-util-split/libs/split-on-macro.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "splitOnMacro": () => (/* binding */ splitOnMacro)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");
/* harmony import */ var _split_on_condition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./split-on-condition */ "./unified-latex-util-split/libs/split-on-condition.ts");


/**
 * Split an array of AST nodes based on a macro. An object `{segments: [], macros: []}`
 * is returned. The original array is reconstructed as
 * `segments[0] + macros[0] + segments[1] + ...`.
 *
 * @param {[object]} ast
 * @param {(string|[string])} macroName
 * @returns {{segments: [object], macros: [object]}}
 */
function splitOnMacro(ast, macroName) {
    if (typeof macroName === "string") {
        macroName = [macroName];
    }
    if (!Array.isArray(macroName)) {
        throw new Error("Type coercion failed");
    }
    const isSeparator = _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.createMacroMatcher(macroName);
    const { segments, separators } = (0,_split_on_condition__WEBPACK_IMPORTED_MODULE_1__.splitOnCondition)(ast, isSeparator);
    return { segments, macros: separators };
}


/***/ }),

/***/ "./unified-latex-util-split/libs/unsplit-on-macro.ts":
/*!***********************************************************!*\
  !*** ./unified-latex-util-split/libs/unsplit-on-macro.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unsplitOnMacro": () => (/* binding */ unsplitOnMacro)
/* harmony export */ });
/**
 * Does the reverse of `splitOnMacro`
 */
function unsplitOnMacro({ segments, macros, }) {
    if (segments.length === 0) {
        console.warn("Trying to join zero segments");
        return [];
    }
    if (segments.length !== macros.length + 1) {
        console.warn("Mismatch between lengths of macros and segments when trying to unsplit");
    }
    let ret = segments[0];
    for (let i = 0; i < macros.length; i++) {
        // Even though the type of macros[i] is node and not array,
        // Array.concat still works
        ret = ret.concat(macros[i]).concat(segments[i + 1]);
    }
    return ret;
}


/***/ }),

/***/ "./unified-latex-util-trim/index.ts":
/*!******************************************!*\
  !*** ./unified-latex-util-trim/index.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hasWhitespaceEquivalent": () => (/* reexport safe */ _libs_has_whitespace_equivalent__WEBPACK_IMPORTED_MODULE_3__.hasWhitespaceEquivalent),
/* harmony export */   "trim": () => (/* reexport safe */ _libs_trim__WEBPACK_IMPORTED_MODULE_0__.trim),
/* harmony export */   "trimEnd": () => (/* reexport safe */ _libs_trim__WEBPACK_IMPORTED_MODULE_0__.trimEnd),
/* harmony export */   "trimStart": () => (/* reexport safe */ _libs_trim__WEBPACK_IMPORTED_MODULE_0__.trimStart),
/* harmony export */   "unifiedLatexTrimEnvironmentContents": () => (/* reexport safe */ _libs_unified_latex_trim_environment_contents__WEBPACK_IMPORTED_MODULE_1__.unifiedLatexTrimEnvironmentContents),
/* harmony export */   "unifiedLatexTrimRoot": () => (/* reexport safe */ _libs_unified_latex_trim_root__WEBPACK_IMPORTED_MODULE_2__.unifiedLatexTrimRoot)
/* harmony export */ });
/* harmony import */ var _libs_trim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/trim */ "./unified-latex-util-trim/libs/trim.ts");
/* harmony import */ var _libs_unified_latex_trim_environment_contents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/unified-latex-trim-environment-contents */ "./unified-latex-util-trim/libs/unified-latex-trim-environment-contents.ts");
/* harmony import */ var _libs_unified_latex_trim_root__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./libs/unified-latex-trim-root */ "./unified-latex-util-trim/libs/unified-latex-trim-root.ts");
/* harmony import */ var _libs_has_whitespace_equivalent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./libs/has-whitespace-equivalent */ "./unified-latex-util-trim/libs/has-whitespace-equivalent.ts");




// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to help modify a `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you want to remove whitespace from the ends of an array of nodes.
 *
 * Note that whitespace can come from a `Ast.Whitespace` node or from an
 * `Ast.Comment` node that has leading whitespace. These functions take care
 * to deal with both situations.
 */


/***/ }),

/***/ "./unified-latex-util-trim/libs/has-whitespace-equivalent.ts":
/*!*******************************************************************!*\
  !*** ./unified-latex-util-trim/libs/has-whitespace-equivalent.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hasWhitespaceEquivalent": () => (/* binding */ hasWhitespaceEquivalent)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");

/**
 * Returns whether the array has whitespace at the start/end. Comments with `leadingWhitespace === true`
 * are counted as whitespace. Other comments are ignored.
 */
function hasWhitespaceEquivalent(nodes) {
    let start = false;
    let end = false;
    for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(node)) {
            // A comment with leading whitespace will render with leading whitespace,
            // so if we encounter one, we should consider ourselves to have leading whitespace.
            if (node.leadingWhitespace) {
                start = true;
                break;
            }
            continue;
        }
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node)) {
            start = true;
        }
        break;
    }
    for (let j = nodes.length - 1; j >= 0; j--) {
        const node = nodes[j];
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(node)) {
            if (node.leadingWhitespace) {
                end = true;
                break;
            }
            continue;
        }
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node)) {
            end = true;
        }
        break;
    }
    return { start, end };
}


/***/ }),

/***/ "./unified-latex-util-trim/libs/trim.ts":
/*!**********************************************!*\
  !*** ./unified-latex-util-trim/libs/trim.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "trim": () => (/* binding */ trim),
/* harmony export */   "trimEnd": () => (/* binding */ trimEnd),
/* harmony export */   "trimStart": () => (/* binding */ trimStart)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");

/**
 * Trims whitespace and parbreaks from the start and end
 * of an array. The number of trimmed nodes is returned.
 * Special care is taken to preserve comments, though any whitespace
 * before the first comment(s) or after the last comment(s) is trimmed.
 */
function trim(nodes) {
    if (!Array.isArray(nodes)) {
        console.warn("Trying to trim a non-array ast", nodes);
        return nodes;
    }
    const { trimmedStart } = trimStart(nodes);
    const { trimmedEnd } = trimEnd(nodes);
    return { trimmedStart, trimmedEnd };
}
/**
 * Trim whitespace and parbreaks from the left of an array.
 */
function trimStart(nodes) {
    const { start } = amountOfLeadingAndTrailingWhitespace(nodes);
    nodes.splice(0, start);
    // If there are comments at the start, they might have leading whitespace.
    // This leading whitespace should be trimmed
    for (const leadingToken of nodes) {
        if (!_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(leadingToken)) {
            break;
        }
        if (leadingToken.leadingWhitespace || leadingToken.sameline) {
            leadingToken.leadingWhitespace = false;
            // We remove the position information from this token to indicate that we've edited it
            delete leadingToken.position;
        }
        // Special care must be taken. If the comment was on the same line as a
        // parskip, it will no longer be on the same line after the trimming.
        // Thus, we must modify the comment.
        if (start > 0 && leadingToken.sameline) {
            leadingToken.sameline = false;
            delete leadingToken.position;
        }
    }
    return { trimmedStart: start };
}
/**
 * Trim whitespace and parbreaks from the right of an array.
 */
function trimEnd(nodes) {
    const { end } = amountOfLeadingAndTrailingWhitespace(nodes);
    nodes.splice(nodes.length - end, end);
    // Trim off any spaces belonging to trailing comments
    for (let i = nodes.length - 1; i >= 0; i--) {
        const trailingToken = nodes[i];
        if (!_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(trailingToken)) {
            break;
        }
        // We don't trim spaces before trailing same-line comments. This is a stylistic choice
        // so that
        // `foo %xxx` does not become `foo%xxx`.
        // The latter is strictly "correct" for a trim function, but it is prettier to format
        // code preserving the space before the sameline comment
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(trailingToken) &&
            trailingToken.leadingWhitespace &&
            !trailingToken.sameline) {
            trailingToken.leadingWhitespace = false;
            delete trailingToken.position;
        }
    }
    return { trimmedEnd: end };
}
/**
 * Returns the number of whitespace/parbreak nodes at the start and end of an array.
 */
function amountOfLeadingAndTrailingWhitespace(ast) {
    let start = 0;
    let end = 0;
    for (const node of ast) {
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.parbreak(node)) {
            start++;
        }
        else {
            break;
        }
    }
    if (start === ast.length) {
        return { start, end: 0 };
    }
    // Find the padding on the right
    for (let i = ast.length - 1; i >= 0; i--) {
        const node = ast[i];
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.parbreak(node)) {
            end++;
        }
        else {
            break;
        }
    }
    return { start, end };
}


/***/ }),

/***/ "./unified-latex-util-trim/libs/unified-latex-trim-environment-contents.ts":
/*!*********************************************************************************!*\
  !*** ./unified-latex-util-trim/libs/unified-latex-trim-environment-contents.ts ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unifiedLatexTrimEnvironmentContents": () => (/* binding */ unifiedLatexTrimEnvironmentContents)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");
/* harmony import */ var _unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../unified-latex-util-visit */ "./unified-latex-util-visit/index.ts");
/* harmony import */ var _trim__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./trim */ "./unified-latex-util-trim/libs/trim.ts");



/**
 * Unified plugin to trim the whitespace from the start/end of any environments, including
 * math environments.
 */
const unifiedLatexTrimEnvironmentContents = function unifiedLatexTrimEnvironmentContents() {
    return (tree) => {
        (0,_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_1__.visit)(tree, (node) => {
            if (!(_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.math(node) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.anyEnvironment(node))) {
                return;
            }
            // If the first thing in the environment is a sameline comment,
            // we actually want to start trimming *after* it.
            let firstNode = node.content[0];
            if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(firstNode) && firstNode.sameline) {
                firstNode.suffixParbreak = false;
                (0,_trim__WEBPACK_IMPORTED_MODULE_2__.trimEnd)(node.content);
                // We play a nasty trick here. This call to `trimStart`
                // will actually modify `node.content` if `node.content.slice(1)` starts
                // with a comment that has leading whitespace (it will remove that whitespace).
                // However, it won't remove any elements from `node.content`; we need
                // to do that ourselves.
                const { trimmedStart } = (0,_trim__WEBPACK_IMPORTED_MODULE_2__.trimStart)(node.content.slice(1));
                node.content.splice(1, trimmedStart);
            }
            else {
                (0,_trim__WEBPACK_IMPORTED_MODULE_2__.trim)(node.content);
            }
        });
    };
};


/***/ }),

/***/ "./unified-latex-util-trim/libs/unified-latex-trim-root.ts":
/*!*****************************************************************!*\
  !*** ./unified-latex-util-trim/libs/unified-latex-trim-root.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unifiedLatexTrimRoot": () => (/* binding */ unifiedLatexTrimRoot)
/* harmony export */ });
/* harmony import */ var _trim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./trim */ "./unified-latex-util-trim/libs/trim.ts");

/**
 * Unified plugin to trim the whitespace from the start/end of the root element.
 */
const unifiedLatexTrimRoot = function unifiedLatexTrimRoot() {
    return (tree) => {
        (0,_trim__WEBPACK_IMPORTED_MODULE_0__.trim)(tree.content);
    };
};


/***/ }),

/***/ "./unified-latex-util-visit/index.ts":
/*!*******************************************!*\
  !*** ./unified-latex-util-visit/index.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CONTINUE": () => (/* reexport safe */ _libs_visit__WEBPACK_IMPORTED_MODULE_0__.CONTINUE),
/* harmony export */   "EXIT": () => (/* reexport safe */ _libs_visit__WEBPACK_IMPORTED_MODULE_0__.EXIT),
/* harmony export */   "SKIP": () => (/* reexport safe */ _libs_visit__WEBPACK_IMPORTED_MODULE_0__.SKIP),
/* harmony export */   "visit": () => (/* reexport safe */ _libs_visit__WEBPACK_IMPORTED_MODULE_0__.visit)
/* harmony export */ });
/* harmony import */ var _libs_visit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/visit */ "./unified-latex-util-visit/libs/visit.ts");

// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to traverse a `unified-latex` Abstract Syntax Tree (AST). `visit` is
 * very similar to [estree-util-visit](https://github.com/syntax-tree/estree-util-visit).
 *
 * ## When should I use this?
 *
 * If you want to recursively replace particular AST nodes.
 */


/***/ }),

/***/ "./unified-latex-util-visit/libs/list-math-children.ts":
/*!*************************************************************!*\
  !*** ./unified-latex-util-visit/libs/list-math-children.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "listMathChildren": () => (/* binding */ listMathChildren)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");

/**
 * List all props of the current node that should be processed
 * in math mode or not in math mode. If math mode is not specified in the node's render
 * info, empty lists are returned.
 *
 * For example `\text{foo}` will report that `args` should *not* be processed in math mode,
 * since it's contents should always be processed in text mode.
 */
function listMathChildren(node) {
    const NULL_RETURN = { enter: [], leave: [] };
    if (Array.isArray(node)) {
        return NULL_RETURN;
    }
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.math(node)) {
        // When we enter a math environment, our content is always
        // considered math mode
        return { enter: ["content"], leave: [] };
    }
    const renderInfo = node._renderInfo || {};
    if (renderInfo.inMathMode == null) {
        return NULL_RETURN;
    }
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.macro(node)) {
        if (renderInfo.inMathMode === true) {
            return { enter: ["args"], leave: [] };
        }
        else if (renderInfo.inMathMode === false) {
            return { enter: [], leave: ["args"] };
        }
    }
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.environment(node)) {
        if (renderInfo.inMathMode === true) {
            return { enter: ["content"], leave: [] };
        }
        else {
            return { enter: [], leave: ["content"] };
        }
    }
    return NULL_RETURN;
}


/***/ }),

/***/ "./unified-latex-util-visit/libs/visit.ts":
/*!************************************************!*\
  !*** ./unified-latex-util-visit/libs/visit.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CONTINUE": () => (/* binding */ CONTINUE),
/* harmony export */   "EXIT": () => (/* binding */ EXIT),
/* harmony export */   "SKIP": () => (/* binding */ SKIP),
/* harmony export */   "visit": () => (/* binding */ visit)
/* harmony export */ });
/* harmony import */ var _list_math_children__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./list-math-children */ "./unified-latex-util-visit/libs/list-math-children.ts");

/**
 * Continue traversing as normal
 */
const CONTINUE = Symbol("continue");
/**
 * Do not traverse this nodes children
 */
const SKIP = Symbol("skip");
/**
 * Stop traversing immediately
 */
const EXIT = Symbol("exit");
const DEFAULT_CONTEXT = {
    inMathMode: false,
    hasMathModeAncestor: false,
};
/**
 * Visit children of tree which pass a test
 *
 * @param {Node} tree Abstract syntax tree to walk
 * @param {Visitor|Visitors} [visitor] Function to run for each node
 */
function visit(tree, visitor, options) {
    const { startingContext = DEFAULT_CONTEXT, test = () => true, includeArrays = false, } = options || {};
    let enter;
    let leave;
    if (typeof visitor === "function") {
        enter = visitor;
    }
    else if (visitor && typeof visitor === "object") {
        enter = visitor.enter;
        leave = visitor.leave;
    }
    walk(tree, {
        key: undefined,
        index: undefined,
        parents: [],
        containingArray: undefined,
        context: Object.assign({}, startingContext),
    });
    /**
     * @param {Node} node
     * @param {string?} key
     * @param {number?} index
     * @param {Array.<Node>} parents
     */
    function walk(node, { key, index, parents, context, containingArray }) {
        const nodePassesTest = includeArrays
            ? test(node, { key, index, parents, context, containingArray })
            : !Array.isArray(node) &&
                test(node, { key, index, parents, context, containingArray });
        const result = enter && nodePassesTest
            ? toResult(enter(node, {
                key,
                index,
                parents,
                context,
                containingArray,
            }))
            : [CONTINUE];
        if (result[0] === EXIT) {
            return result;
        }
        if (result[0] === SKIP) {
            return leave && nodePassesTest
                ? toResult(leave(node, {
                    key,
                    index,
                    parents,
                    context,
                    containingArray,
                }))
                : result;
        }
        if (Array.isArray(node)) {
            // The `value` array might be modified in place as we traverse it, so
            // we use a traditional for loop.
            for (let index = 0; index > -1 && index < node.length; index++) {
                const item = node[index];
                const result = walk(item, {
                    key,
                    index,
                    parents,
                    context,
                    containingArray: node,
                });
                if (result[0] === EXIT) {
                    return result;
                }
                if (typeof result[1] === "number") {
                    // The for loop will increment i every pass. However,
                    // if an index was returned, that's where we want to start next time.
                    index = result[1] - 1;
                }
            }
        }
        else {
            // We don't want to recursively apply to the `content`
            // of all types (e.g., comments and macros), so specify
            // a blacklist.
            let childProps = ["content", "args"];
            switch (node.type) {
                case "macro":
                    childProps = ["args"];
                    break;
                case "comment":
                case "string":
                case "verb":
                case "verbatim":
                    childProps = [];
                    break;
                default:
                    break;
            }
            const mathModeProps = (0,_list_math_children__WEBPACK_IMPORTED_MODULE_0__.listMathChildren)(node);
            for (const key of childProps) {
                const value = node[key];
                const grandparents = [node].concat(parents);
                if (value == null) {
                    continue;
                }
                // We may switch in/out of math mode as we pass to node[key]
                const newContext = Object.assign({}, context);
                if (mathModeProps.enter.includes(key)) {
                    newContext.inMathMode = true;
                    newContext.hasMathModeAncestor = true;
                }
                else if (mathModeProps.leave.includes(key)) {
                    newContext.inMathMode = false;
                }
                const result = walk(value, {
                    key,
                    index: undefined,
                    parents: grandparents,
                    context: newContext,
                    containingArray: undefined,
                });
                if (result[0] === EXIT) {
                    return result;
                }
            }
        }
        return leave && nodePassesTest
            ? toResult(leave(node, {
                key,
                index,
                parents,
                context,
                containingArray,
            }))
            : result;
    }
}
/**
 * Ensures a result is an `ActionTuple`s
 */
function toResult(value) {
    if (value == null) {
        return [CONTINUE];
    }
    if (Array.isArray(value)) {
        return value;
    }
    if (typeof value === "number") {
        return [CONTINUE, value];
    }
    return [value];
}


/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!*********************************************!*\
  !*** ./unified-latex-util-replace/index.ts ***!
  \*********************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "replaceNode": () => (/* reexport safe */ _libs_replace_node__WEBPACK_IMPORTED_MODULE_0__.replaceNode),
/* harmony export */   "replaceStreamingCommand": () => (/* reexport safe */ _libs_replace_streaming_command__WEBPACK_IMPORTED_MODULE_2__.replaceStreamingCommand),
/* harmony export */   "replaceStreamingCommandInGroup": () => (/* reexport safe */ _libs_replace_streaming_command__WEBPACK_IMPORTED_MODULE_2__.replaceStreamingCommandInGroup),
/* harmony export */   "unifiedLatexReplaceStreamingCommands": () => (/* reexport safe */ _libs_unified_latex_streaming_command__WEBPACK_IMPORTED_MODULE_1__.unifiedLatexReplaceStreamingCommands)
/* harmony export */ });
/* harmony import */ var _libs_replace_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/replace-node */ "./unified-latex-util-replace/libs/replace-node.ts");
/* harmony import */ var _libs_unified_latex_streaming_command__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/unified-latex-streaming-command */ "./unified-latex-util-replace/libs/unified-latex-streaming-command.ts");
/* harmony import */ var _libs_replace_streaming_command__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./libs/replace-streaming-command */ "./unified-latex-util-replace/libs/replace-streaming-command.ts");



// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to help modify a `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you want to recursively replace particular AST nodes.
 */

})();

var __webpack_export_target__ = exports;
for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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S0FBSyxDQUFDLEVBQUU7UUFDdEIsT0FBTyxLQUFLLENBQUM7S0FDaEI7SUFFRCxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBRTtRQUMzQixPQUFPLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDO0tBQzVCO0lBRUQsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ25CLENBQUM7Ozs7Ozs7U0NuVUQ7U0FDQTs7U0FFQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTs7U0FFQTtTQUNBOztTQUVBO1NBQ0E7U0FDQTs7Ozs7VUN0QkE7VUFDQTtVQUNBO1VBQ0E7VUFDQSx5Q0FBeUMsd0NBQXdDO1VBQ2pGO1VBQ0E7VUFDQTs7Ozs7VUNQQTs7Ozs7VUNBQTtVQUNBO1VBQ0E7VUFDQSx1REFBdUQsaUJBQWlCO1VBQ3hFO1VBQ0EsZ0RBQWdELGFBQWE7VUFDN0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTm9DO0FBQ21CO0FBQ047QUFFakQsMEVBQTBFO0FBQzFFOzs7Ozs7OztHQVFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtbGludC91dGlscy9yZXBsYWNlLW5vZGUudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1tYXRjaC9pbmRleC50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoL2xpYnMvbWF0Y2gudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1wcmludC1yYXcvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1wcmludC1yYXcvbGlicy9wcmludC1yYXcudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1yZXBsYWNlL2xpYnMvcmVwbGFjZS1ub2RlLnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtcmVwbGFjZS9saWJzL3JlcGxhY2Utc3RyZWFtaW5nLWNvbW1hbmQudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1yZXBsYWNlL2xpYnMvdW5pZmllZC1sYXRleC1zdHJlYW1pbmctY29tbWFuZC50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXJlcGxhY2UvbGlicy91dGlscy9maXJzdC1zaWduaWZpY2FudC1ub2RlLnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtcmVwbGFjZS9saWJzL3V0aWxzL2pvaW4td2l0aG91dC1leGNlc3Mtd2hpdGVzcGFjZS50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXJlcGxhY2UvbGlicy91dGlscy9yZXBsYWNlLXN0cmVhbWluZy1jb21tYW5kLWluLWFycmF5LnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtcmVwbGFjZS9saWJzL3V0aWxzL3dyYXAtc2lnbmlmaWNhbnQtY29udGVudC50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXNwbGl0L2luZGV4LnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtc3BsaXQvbGlicy9hcnJheS1qb2luLnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtc3BsaXQvbGlicy9zcGxpdC1vbi1jb25kaXRpb24udHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1zcGxpdC9saWJzL3NwbGl0LW9uLW1hY3JvLnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtc3BsaXQvbGlicy91bnNwbGl0LW9uLW1hY3JvLnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtdHJpbS9pbmRleC50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXRyaW0vbGlicy9oYXMtd2hpdGVzcGFjZS1lcXVpdmFsZW50LnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtdHJpbS9saWJzL3RyaW0udHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC10cmltL2xpYnMvdW5pZmllZC1sYXRleC10cmltLWVudmlyb25tZW50LWNvbnRlbnRzLnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtdHJpbS9saWJzL3VuaWZpZWQtbGF0ZXgtdHJpbS1yb290LnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtdmlzaXQvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC12aXNpdC9saWJzL2xpc3QtbWF0aC1jaGlsZHJlbi50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXZpc2l0L2xpYnMvdmlzaXQudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4L3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4L3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtcmVwbGFjZS9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWaXNpdEluZm8gfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLXZpc2l0XCI7XG5pbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcblxuLyoqXG4gKiBSZXBsYWNlcyB0aGUgY3VycmVudCBub2RlIHdpdGggYHJlcGxhY2VtZW50YC4gSXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBjdXJyZW50XG4gKiBub2RlIGlzIGluIGFuIGFycmF5IHRoYXQgaXMgYSBjaGlsZCBvZiBhIHBhcmVudCBlbGVtZW50LiBJZiB0aGlzIGlzIG5vdCB0aGUgY2FzZSxcbiAqIHRoZSBmdW5jdGlvbiB3aWxsIGVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZU5vZGVEdXJpbmdWaXNpdChcbiAgICByZXBsYWNlbWVudDogQXN0Lk5vZGUgfCBBc3QuQXJndW1lbnQgfCAoQXN0Lk5vZGUgfCBBc3QuQXJndW1lbnQpW10sXG4gICAgaW5mbzogVmlzaXRJbmZvXG4pIHtcbiAgICBjb25zdCBwYXJlbnQgPSBpbmZvLnBhcmVudHNbMF07XG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVwbGFjZSBub2RlOiBwYXJlbnQgbm90IGZvdW5kYCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRhaW5lciA9IHBhcmVudFtpbmZvLmtleSBhcyBrZXlvZiB0eXBlb2YgcGFyZW50XSBhcyAoXG4gICAgICAgIHwgQXN0Lk5vZGVcbiAgICAgICAgfCBBc3QuQXJndW1lbnRcbiAgICApW107XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvbnRhaW5lcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVwbGFjZSBub2RlOiBjb250YWluaW5nIGFycmF5IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgICBpZiAoaW5mby5pbmRleCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlcGxhY2Ugbm9kZTogbm9kZSBpbmRleCB1bmRlZmluZWRgKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJlcGxhY2VtZW50KSkge1xuICAgICAgICBjb250YWluZXJbaW5mby5pbmRleF0gPSByZXBsYWNlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIuc3BsaWNlKGluZm8uaW5kZXgsIDEsIC4uLnJlcGxhY2VtZW50KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBtYXRjaCB9IGZyb20gXCIuL2xpYnMvbWF0Y2hcIjtcblxuZXhwb3J0IHsgbWF0Y2ggfTtcblxuZXhwb3J0IGNvbnN0IHtcbiAgICBhbnlFbnZpcm9ubWVudCxcbiAgICBhbnlNYWNybyxcbiAgICBhbnlTdHJpbmcsXG4gICAgYXJndW1lbnQsXG4gICAgYmxhbmtBcmd1bWVudCxcbiAgICBjb21tZW50LFxuICAgIGVudmlyb25tZW50LFxuICAgIGdyb3VwLFxuICAgIG1hY3JvLFxuICAgIG1hdGgsXG4gICAgcGFyYnJlYWssXG4gICAgc3RyaW5nLFxuICAgIHdoaXRlc3BhY2UsXG59ID0gbWF0Y2g7XG5cbi8vIE5PVEU6IFRoZSBkb2NzdHJpbmcgY29tbWVudCBtdXN0IGJlIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIGluZGV4LnRzIGZpbGUhXG4vKipcbiAqICMjIFdoYXQgaXMgdGhpcz9cbiAqXG4gKiBGdW5jdGlvbnMgdG8gbWF0Y2ggZGlmZmVyZW50IGBBc3QuTm9kZWAgdHlwZXMgaW4gYSBgdW5pZmllZC1sYXRleGAgQWJzdHJhY3QgU3ludGF4IFRyZWUgKEFTVCkuXG4gKlxuICogIyMgV2hlbiBzaG91bGQgSSB1c2UgdGhpcz9cbiAqXG4gKiBJZiB5b3UgbmVlZCBhIHR5cGUtZ3VhcmQgdG8gZW5zdXJlIGEgbm9kZSBpcyBvZiBhIGNlcnRhaW4gdHlwZTsgZm9yIGV4YW1wbGUsIGR1cmluZyBhIGNhbGwgdG8gYHVuaWZpZWQtbGF0ZXgtdW50aWwtdmlzaXRgLlxuICovXG4iLCJpbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IEVudkluZm8sIE1hY3JvSW5mbywgTWFjcm9JbmZvUmVjb3JkIH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IHByaW50UmF3IH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdXRpbC1wcmludC1yYXdcIjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFjcm8gbWF0Y2hpbmcgZnVuY3Rpb24gdGhhdCB1c2VzIGEgYFNwZWNpYWxNYWNyb1NwZWNgIG9yIGxpc3Qgb2YgbWFjcm9zXG4gKiBhbmQgZ2VuZXJhdGVzIGEgaGFzaCBmb3IgcXVpY2sgbG9va3VwLlxuICovXG5mdW5jdGlvbiBjcmVhdGVNYWNyb01hdGNoZXIoXG4gICAgbWFjcm9zOiBBc3QuTWFjcm9bXSB8IHN0cmluZ1tdIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbikge1xuICAgIC8vIFdlIGZpcnN0IG1ha2Ugc3VyZSB3ZSBoYXZlIGEgcmVjb3JkIHR5cGUgd2l0aCBrZXlzIGJlaW5nIHRoZSBtYWNybydzIGNvbnRlbnRzXG4gICAgY29uc3QgbWFjcm9zSGFzaCA9IEFycmF5LmlzQXJyYXkobWFjcm9zKVxuICAgICAgICA/IG1hY3Jvcy5sZW5ndGggPiAwXG4gICAgICAgICAgICA/IHR5cGVvZiBtYWNyb3NbMF0gPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgICAgICAgICAgICBtYWNyb3MubWFwKChtYWNybykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1hY3JvICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBicmFuY2ggb2YgbWFwIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbbWFjcm8sIHt9XSBhcyBbc3RyaW5nLCBNYWNyb0luZm9dO1xuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICAgICAgICAgICAgbWFjcm9zLm1hcCgobWFjcm8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtYWNybyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgYnJhbmNoIG9mIG1hcCBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFjcm8uZXNjYXBlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWNyby5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgZXNjYXBlVG9rZW46IG1hY3JvLmVzY2FwZVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdIGFzIFtzdHJpbmcsIE1hY3JvSW5mb107XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFttYWNyby5jb250ZW50LCB7fV0gYXMgW3N0cmluZywgTWFjcm9JbmZvXTtcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiB7fVxuICAgICAgICA6IG1hY3JvcztcblxuICAgIHJldHVybiBmdW5jdGlvbiBtYXRjaEFnYWluc3RNYWNyb3Mobm9kZTogYW55IHwgQXN0Lk1hY3JvKSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwgfHwgbm9kZS50eXBlICE9PSBcIm1hY3JvXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYSBtYWNybyB0eXBlXG4gICAgICAgIGNvbnN0IHNwZWMgPSBtYWNyb3NIYXNoW25vZGUuY29udGVudF07XG4gICAgICAgIGlmICghc3BlYykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzcGVjID09PSBcIm9iamVjdFwiICYmIFwiZXNjYXBlVG9rZW5cIiBpbiBzcGVjKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChzcGVjIGFzIE1hY3JvSW5mb1JlY29yZCkuZXNjYXBlVG9rZW4gPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIChzcGVjIGFzIE1hY3JvSW5mb1JlY29yZCkuZXNjYXBlVG9rZW4gPT09IG5vZGUuZXNjYXBlVG9rZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBhcyBBc3QuVHlwZUd1YXJkPEFzdC5NYWNybz47XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hY3JvIG1hdGNoaW5nIGZ1bmN0aW9uIHRoYXQgdXNlcyBhIGBTcGVjaWFsTWFjcm9TcGVjYCBvciBsaXN0IG9mIG1hY3Jvc1xuICogYW5kIGdlbmVyYXRlcyBhIGhhc2ggZm9yIHF1aWNrIGxvb2t1cC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW52aXJvbm1lbnRNYXRjaGVyKG1hY3Jvczogc3RyaW5nW10gfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikge1xuICAgIC8vIFdlIGZpcnN0IG1ha2Ugc3VyZSB3ZSBoYXZlIGEgcmVjb3JkIHR5cGUgd2l0aCBrZXlzIGJlaW5nIHRoZSBtYWNybydzIGNvbnRlbnRzXG4gICAgY29uc3QgZW52aXJvbm1lbnRzSGFzaCA9IEFycmF5LmlzQXJyYXkobWFjcm9zKVxuICAgICAgICA/IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgICAgbWFjcm9zLm1hcCgoc3RyKSA9PiB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW3N0ciwge31dIGFzIFtzdHJpbmcsIEVudkluZm9dO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgOiBtYWNyb3M7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWF0Y2hBZ2FpbnN0RW52aXJvbm1lbnRzKG5vZGU6IGFueSB8IEFzdC5FbnZpcm9ubWVudCkge1xuICAgICAgICBpZiAoIW1hdGNoLmFueUVudmlyb25tZW50KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFuIGVudmlyb25tZW50IHR5cGVcbiAgICAgICAgY29uc3QgZW52TmFtZSA9IHByaW50UmF3KG5vZGUuZW52KTtcbiAgICAgICAgY29uc3Qgc3BlYyA9IGVudmlyb25tZW50c0hhc2hbZW52TmFtZV07XG4gICAgICAgIGlmICghc3BlYykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBhcyBBc3QuVHlwZUd1YXJkPEFzdC5FbnZpcm9ubWVudD47XG59XG5cbi8qKlxuICogRnVuY3Rpb25zIHRvIG1hdGNoIGRpZmZlcmVudCB0eXBlcyBvZiBub2Rlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IG1hdGNoID0ge1xuICAgIG1hY3JvKG5vZGU6IGFueSwgbWFjcm9OYW1lPzogc3RyaW5nKTogbm9kZSBpcyBBc3QuTWFjcm8ge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG5vZGUudHlwZSA9PT0gXCJtYWNyb1wiICYmXG4gICAgICAgICAgICAobWFjcm9OYW1lID09IG51bGwgfHwgbm9kZS5jb250ZW50ID09PSBtYWNyb05hbWUpXG4gICAgICAgICk7XG4gICAgfSxcbiAgICBhbnlNYWNybyhub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5NYWNybyB7XG4gICAgICAgIHJldHVybiBtYXRjaC5tYWNybyhub2RlKTtcbiAgICB9LFxuICAgIGVudmlyb25tZW50KG5vZGU6IGFueSwgZW52TmFtZT86IHN0cmluZyk6IG5vZGUgaXMgQXN0LkVudmlyb25tZW50IHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAobm9kZS50eXBlID09PSBcImVudmlyb25tZW50XCIgfHwgbm9kZS50eXBlID09PSBcIm1hdGhlbnZcIikgJiZcbiAgICAgICAgICAgIChlbnZOYW1lID09IG51bGwgfHwgcHJpbnRSYXcobm9kZS5lbnYpID09PSBlbnZOYW1lKVxuICAgICAgICApO1xuICAgIH0sXG4gICAgYW55RW52aXJvbm1lbnQobm9kZTogYW55KTogbm9kZSBpcyBBc3QuRW52aXJvbm1lbnQge1xuICAgICAgICByZXR1cm4gbWF0Y2guZW52aXJvbm1lbnQobm9kZSk7XG4gICAgfSxcbiAgICBjb21tZW50KG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0LkNvbW1lbnQge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJjb21tZW50XCI7XG4gICAgfSxcbiAgICBwYXJicmVhayhub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5QYXJicmVhayB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInBhcmJyZWFrXCI7XG4gICAgfSxcbiAgICB3aGl0ZXNwYWNlKG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0LldoaXRlc3BhY2Uge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJ3aGl0ZXNwYWNlXCI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBNYXRjaGVzIHdoaXRlc3BhY2Ugb3IgYSBjb21tZW50IHdpdGggbGVhZGluZyB3aGl0ZXNwYWNlLlxuICAgICAqL1xuICAgIHdoaXRlc3BhY2VMaWtlKFxuICAgICAgICBub2RlOiBhbnlcbiAgICApOiBub2RlIGlzIEFzdC5XaGl0ZXNwYWNlIHwgKEFzdC5Db21tZW50ICYgeyBsZWFkaW5nV2hpdGVzcGFjZTogdHJ1ZSB9KSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbm9kZS50eXBlID09PSBcIndoaXRlc3BhY2VcIiB8fFxuICAgICAgICAgICAgKG5vZGUudHlwZSA9PT0gXCJ3aGl0ZXNwYWNlXCIgJiYgbm9kZS5sZWFkaW5nV2hpdGVzcGFjZSA9PT0gdHJ1ZSlcbiAgICAgICAgKTtcbiAgICB9LFxuICAgIHN0cmluZyhub2RlOiBhbnksIHZhbHVlPzogc3RyaW5nKTogbm9kZSBpcyBBc3QuU3RyaW5nIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBub2RlLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgKHZhbHVlID09IG51bGwgfHwgbm9kZS5jb250ZW50ID09PSB2YWx1ZSlcbiAgICAgICAgKTtcbiAgICB9LFxuICAgIGFueVN0cmluZyhub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5TdHJpbmcge1xuICAgICAgICByZXR1cm4gbWF0Y2guc3RyaW5nKG5vZGUpO1xuICAgIH0sXG4gICAgZ3JvdXAobm9kZTogYW55KTogbm9kZSBpcyBBc3QuR3JvdXAge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJncm91cFwiO1xuICAgIH0sXG4gICAgYXJndW1lbnQobm9kZTogYW55KTogbm9kZSBpcyBBc3QuQXJndW1lbnQge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJhcmd1bWVudFwiO1xuICAgIH0sXG4gICAgYmxhbmtBcmd1bWVudChub2RlOiBhbnkpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKCFtYXRjaC5hcmd1bWVudChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBub2RlLm9wZW5NYXJrID09PSBcIlwiICYmXG4gICAgICAgICAgICBub2RlLmNsb3NlTWFyayA9PT0gXCJcIiAmJlxuICAgICAgICAgICAgbm9kZS5jb250ZW50Lmxlbmd0aCA9PT0gMFxuICAgICAgICApO1xuICAgIH0sXG4gICAgbWF0aChub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5EaXNwbGF5TWF0aCB8IEFzdC5JbmxpbmVNYXRoIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiZGlzcGxheW1hdGhcIiB8fCBub2RlLnR5cGUgPT09IFwiaW5saW5lbWF0aFwiO1xuICAgIH0sXG4gICAgY3JlYXRlTWFjcm9NYXRjaGVyLFxuICAgIGNyZWF0ZUVudmlyb25tZW50TWF0Y2hlcixcbn07XG4iLCJleHBvcnQgKiBmcm9tIFwiLi9saWJzL3ByaW50LXJhd1wiO1xuXG4vLyBOT1RFOiBUaGUgZG9jc3RyaW5nIGNvbW1lbnQgbXVzdCBiZSB0aGUgbGFzdCBpdGVtIGluIHRoZSBpbmRleC50cyBmaWxlIVxuLyoqXG4gKiAjIyBXaGF0IGlzIHRoaXM/XG4gKlxuICogRnVuY3Rpb25zIHRvIHByaW50IGEgYHVuaWZpZWQtbGF0ZXhgIEFic3RyYWN0IFN5bnRheCBUcmVlIChBU1QpIHRvIGEgc3RyaW5nLlxuICpcbiAqICMjIFdoZW4gc2hvdWxkIEkgdXNlIHRoaXM/XG4gKlxuICogSWYgeW91IHdhbnQgdG8gZGlyZWN0bHkgcHJpbnQgYW4gYEFzdC5Bc3RgIHRvIGEgc3RyaW5nIHdpdGhvdXQgYW55IHByZXR0eSBwcmludGluZyBvciBmb3JtYXR0aW5nLlxuICovXG4iLCJpbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcblxudHlwZSBQcmludGFibGUgPSBBc3QuTm9kZSB8IEFzdC5Bcmd1bWVudCB8IHN0cmluZztcbnR5cGUgUHJpbnRUb2tlbiA9IHN0cmluZyB8IHR5cGVvZiBsaW5lYnJlYWs7XG5cbmV4cG9ydCBjb25zdCBsaW5lYnJlYWsgPSBTeW1ib2woXCJsaW5lYnJlYWtcIik7XG5jb25zdCBFU0NBUEUgPSBcIlxcXFxcIjtcblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBBU1QgdG8gYW4gYXJyYXkgaW5zZXJ0aW5nIGBsaW5lYnJlYWtgIHdoZXJlIG5lZWRlZDtcbiAqIFRoaXMgYXJyYXkgbWF5IGJlIG5lc3RlZC5cbiAqXG4gKiBAcGFyYW0geyp9IG5vZGVcbiAqL1xuZnVuY3Rpb24gX3ByaW50UmF3KG5vZGU6IFByaW50YWJsZSB8IFByaW50YWJsZVtdKTogUHJpbnRUb2tlbltdIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIChbXSBhcyBQcmludFRva2VuW10pLmNvbmNhdChcbiAgICAgICAgICAgIC4uLm5vZGUubWFwKChuOiBQcmludGFibGUpID0+IF9wcmludFJhdyhuKSlcbiAgICAgICAgKTtcbiAgICB9XG4gICAgLy8gdG1wIHZhcmlhYmxlc1xuICAgIGxldCBhcmdzU3RyaW5nLCBlc2NhcGU7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcInJvb3RcIjpcbiAgICAgICAgICAgIHJldHVybiBfcHJpbnRSYXcobm9kZS5jb250ZW50KTtcbiAgICAgICAgY2FzZSBcImFyZ3VtZW50XCI6XG4gICAgICAgICAgICByZXR1cm4gW25vZGUub3Blbk1hcmssIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLCBub2RlLmNsb3NlTWFya107XG4gICAgICAgIGNhc2UgXCJjb21tZW50XCI6XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gbm9kZS5zdWZmaXhQYXJicmVhayA/IFwiXCIgOiBsaW5lYnJlYWs7XG4gICAgICAgICAgICAvLyBBIGNvbW1lbnQgaXMgcmVzcG9uc2libGUgZm9yIHByaW50aW5nIGl0cyBvd24gbGVhZGluZyB3aGl0ZXNwYWNlXG4gICAgICAgICAgICB2YXIgbGVhZGluZ1doaXRlc3BhY2UgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKG5vZGUuc2FtZWxpbmUgJiYgbm9kZS5sZWFkaW5nV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlID0gXCIgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5zYW1lbGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlLFxuICAgICAgICAgICAgICAgICAgICBcIiVcIixcbiAgICAgICAgICAgICAgICAgICAgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksXG4gICAgICAgICAgICAgICAgICAgIHN1ZmZpeCxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtsaW5lYnJlYWssIFwiJVwiLCAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSwgc3VmZml4XTtcbiAgICAgICAgY2FzZSBcImVudmlyb25tZW50XCI6XG4gICAgICAgIGNhc2UgXCJtYXRoZW52XCI6XG4gICAgICAgIGNhc2UgXCJ2ZXJiYXRpbVwiOlxuICAgICAgICAgICAgdmFyIGVudiA9IF9wcmludFJhdyhub2RlLmVudik7XG4gICAgICAgICAgICB2YXIgZW52U3RhcnQ6IFByaW50VG9rZW5bXSA9IFtFU0NBUEUgKyBcImJlZ2lue1wiLCAuLi5lbnYsIFwifVwiXTtcbiAgICAgICAgICAgIHZhciBlbnZFbmQ6IFByaW50VG9rZW5bXSA9IFtFU0NBUEUgKyBcImVuZHtcIiwgLi4uZW52LCBcIn1cIl07XG4gICAgICAgICAgICBhcmdzU3RyaW5nID1cbiAgICAgICAgICAgICAgICAobm9kZSBhcyBhbnkpLmFyZ3MgPT0gbnVsbCA/IFtdIDogX3ByaW50UmF3KChub2RlIGFzIGFueSkuYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC4uLmVudlN0YXJ0LFxuICAgICAgICAgICAgICAgIC4uLmFyZ3NTdHJpbmcsXG4gICAgICAgICAgICAgICAgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksXG4gICAgICAgICAgICAgICAgLi4uZW52RW5kLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgY2FzZSBcImRpc3BsYXltYXRoXCI6XG4gICAgICAgICAgICByZXR1cm4gW0VTQ0FQRSArIFwiW1wiLCAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSwgRVNDQVBFICsgXCJdXCJdO1xuICAgICAgICBjYXNlIFwiZ3JvdXBcIjpcbiAgICAgICAgICAgIHJldHVybiBbXCJ7XCIsIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLCBcIn1cIl07XG4gICAgICAgIGNhc2UgXCJpbmxpbmVtYXRoXCI6XG4gICAgICAgICAgICByZXR1cm4gW1wiJFwiLCAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSwgXCIkXCJdO1xuICAgICAgICBjYXNlIFwibWFjcm9cIjpcbiAgICAgICAgICAgIGFyZ3NTdHJpbmcgPSBub2RlLmFyZ3MgPT0gbnVsbCA/IFtdIDogX3ByaW50UmF3KG5vZGUuYXJncyk7XG4gICAgICAgICAgICBlc2NhcGUgPSBub2RlLmVzY2FwZVRva2VuID09IG51bGwgPyBFU0NBUEUgOiBub2RlLmVzY2FwZVRva2VuO1xuICAgICAgICAgICAgcmV0dXJuIFtlc2NhcGUsIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLCAuLi5hcmdzU3RyaW5nXTtcbiAgICAgICAgY2FzZSBcInBhcmJyZWFrXCI6XG4gICAgICAgICAgICByZXR1cm4gW2xpbmVicmVhaywgbGluZWJyZWFrXTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIFtub2RlLmNvbnRlbnRdO1xuICAgICAgICBjYXNlIFwidmVyYlwiOlxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBFU0NBUEUsXG4gICAgICAgICAgICAgICAgbm9kZS5lbnYsXG4gICAgICAgICAgICAgICAgbm9kZS5lc2NhcGUsXG4gICAgICAgICAgICAgICAgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksXG4gICAgICAgICAgICAgICAgbm9kZS5lc2NhcGUsXG4gICAgICAgICAgICBdO1xuICAgICAgICBjYXNlIFwid2hpdGVzcGFjZVwiOlxuICAgICAgICAgICAgcmV0dXJuIFtcIiBcIl07XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBcIkNhbm5vdCBmaW5kIHJlbmRlciBmb3Igbm9kZSBcIixcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgIGAob2YgdHlwZSAke3R5cGVvZiBub2RlfSlgXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIFtcIlwiICsgbm9kZV07XG4gICAgfVxufVxuXG4vKipcbiAqIFJlbmRlcnMgdGhlIEFTVCB0byBhIHN0cmluZyB3aXRob3V0IGFueSBwcmV0dHkgcHJpbnRpbmcuXG4gKlxuICogQHBhcmFtIHsqfSBub2RlXG4gKiBAcGFyYW0geyp9IG9wdGlvbnMgLSBTZXR0aW5nIGBhc0FycmF5YCB0byBgdHJ1ZWAgd2lsbCByZXR1cm4gYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgdGhlIHN5bWJvbCBgbGluZWJyZWFrYCwgc28gdGhhdCBwcmludGluZyBjYW4gYmUgY3VzdG9taXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByaW50UmF3KFxuICAgIG5vZGU6IFByaW50YWJsZSB8IFByaW50YWJsZVtdLFxuICAgIG9wdGlvbnM/OiB7IGFzQXJyYXk6IGZhbHNlIH1cbik6IHN0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBwcmludFJhdyhcbiAgICBub2RlOiBQcmludGFibGUgfCBQcmludGFibGVbXSxcbiAgICBvcHRpb25zOiB7IGFzQXJyYXk6IHRydWUgfVxuKTogUHJpbnRUb2tlbltdO1xuZXhwb3J0IGZ1bmN0aW9uIHByaW50UmF3KG5vZGU6IFByaW50YWJsZSB8IFByaW50YWJsZVtdLCBvcHRpb25zPzogb2JqZWN0KTogYW55IHtcbiAgICBjb25zdCBhc0FycmF5ID0gb3B0aW9ucyAhPSBudWxsID8gKG9wdGlvbnMgYXMgYW55KS5hc0FycmF5IDogZmFsc2U7XG4gICAgY29uc3QgcHJpbnRlZFRva2VucyA9IF9wcmludFJhdyhub2RlKTtcbiAgICBpZiAoYXNBcnJheSkge1xuICAgICAgICByZXR1cm4gcHJpbnRlZFRva2VucztcbiAgICB9XG4gICAgcmV0dXJuIHByaW50ZWRUb2tlbnMubWFwKCh4KSA9PiAoeCA9PT0gbGluZWJyZWFrID8gXCJcXG5cIiA6IHgpKS5qb2luKFwiXCIpO1xufVxuIiwiaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5pbXBvcnQgeyB2aXNpdCwgVmlzaXRvckNvbnRleHQgfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLXZpc2l0XCI7XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgcmVwbGFjZSBub2RlcyBpbiBgYXN0YC4gVGhlIGB2aXNpdG9yYCBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZWFjaCBub2RlLiBJZlxuICogYHZpc2l0b3JgIHJldHVybnMgYSBub2RlIG9yIGFuIGFycmF5IG9mIG5vZGVzLCB0aG9zZSBub2RlcyByZXBsYWNlIHRoZSBub2RlIHBhc3NlZCB0byBgdmlzaXRvcmAuXG4gKiBJZiBgbnVsbGAgaXMgcmV0dXJuZWQsIHRoZSBub2RlIGlzIGRlbGV0ZWQuIElmIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLCBubyByZXBsYWNlbWVudCBoYXBwZW5zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZU5vZGUoXG4gICAgYXN0OiBBc3QuQXN0LFxuICAgIHZpc2l0b3I6IChcbiAgICAgICAgbm9kZTogQXN0Lk5vZGUgfCBBc3QuQXJndW1lbnQsXG4gICAgICAgIGNvbnRleHQ6IFZpc2l0b3JDb250ZXh0XG4gICAgKSA9PlxuICAgICAgICB8IEFzdC5Ob2RlXG4gICAgICAgIHwgQXN0LkFyZ3VtZW50XG4gICAgICAgIHwgKEFzdC5Ob2RlIHwgQXN0LkFyZ3VtZW50KVtdXG4gICAgICAgIHwgbnVsbFxuICAgICAgICB8IHVuZGVmaW5lZFxuICAgICAgICB8IHZvaWRcbikge1xuICAgIHZpc2l0KGFzdCwgKG5vZGUsIGluZm8pID0+IHtcbiAgICAgICAgbGV0IHJlcGxhY2VtZW50ID0gdmlzaXRvcihub2RlLCBpbmZvLmNvbnRleHQpO1xuICAgICAgICAvLyBSZXR1cm5pbmcgYHVuZGVmaW5lZGAgb3IgdGhlIHNhbWUgbm9kZSBtZWFucyB3ZSBzaG91bGRuJ3QgcmVwbGFjZSB0aGF0IG5vZGVcbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlbWVudCA9PT0gXCJ1bmRlZmluZWRcIiB8fCByZXBsYWNlbWVudCA9PT0gbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpbmZvLmNvbnRhaW5pbmdBcnJheSB8fCBpbmZvLmluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIlRyeWluZyB0byBkZWxldGUgbm9kZSwgYnV0IGNhbm5vdCBmaW5kIGNvbnRhaW5pbmcgYXJyYXlcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHJlcGxhY2VtZW50ID09PSBudWxsIHx8XG4gICAgICAgICAgICAoQXJyYXkuaXNBcnJheShyZXBsYWNlbWVudCkgJiYgcmVwbGFjZW1lbnQubGVuZ3RoID09PSAwKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIEEgbnVsbCByZXR1cm4gbWVhbnMgdGhhdCB3ZSBkZWxldGUgdGhlIGN1cnJlbnQgbm9kZVxuICAgICAgICAgICAgaW5mby5jb250YWluaW5nQXJyYXkuc3BsaWNlKGluZm8uaW5kZXgsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIGluZm8uaW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVwbGFjZW1lbnQpKSB7XG4gICAgICAgICAgICByZXBsYWNlbWVudCA9IFtyZXBsYWNlbWVudF07XG4gICAgICAgIH1cblxuICAgICAgICBpbmZvLmNvbnRhaW5pbmdBcnJheS5zcGxpY2UoaW5mby5pbmRleCwgMSwgLi4ucmVwbGFjZW1lbnQpO1xuICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvICpyZXByb2Nlc3MqIHRoZSBub2RlcyB3ZSBqdXN0IGluc2VydGVkIGludG8gdGhlIGFycmF5LFxuICAgICAgICAvLyBsZXN0IHdlIGdldCBzdHVjayBpbiBhIHJlY3Vyc2l2ZSBsb29wIGlmIHRoZSByZXBsYWNlbWVudCBjb250YWlucyB0aGUgb3JpZ2luYWwuXG4gICAgICAgIC8vIFRodXMgd2UganVtcCB0byB0aGUgaW5kZXggYWZ0ZXIgb3VyIHJlcGxhY2VtZW50cy5cbiAgICAgICAgcmV0dXJuIGluZm8uaW5kZXggKyByZXBsYWNlbWVudC5sZW5ndGg7XG4gICAgfSk7XG59XG4iLCJpbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IG1hdGNoIH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdXRpbC1tYXRjaFwiO1xuaW1wb3J0IHtcbiAgICBzcGxpdE9uQ29uZGl0aW9uLFxuICAgIHVuc3BsaXRPbk1hY3JvLFxufSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLXNwbGl0XCI7XG5pbXBvcnQgeyB0cmltLCB0cmltRW5kLCB0cmltU3RhcnQgfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLXRyaW1cIjtcbmltcG9ydCB7IGZpcnN0U2lnbmlmaWNhbnROb2RlIH0gZnJvbSBcIi4vdXRpbHMvZmlyc3Qtc2lnbmlmaWNhbnQtbm9kZVwiO1xuaW1wb3J0IHsgcmVwbGFjZVN0cmVhbWluZ0NvbW1hbmRJbkFycmF5IH0gZnJvbSBcIi4vdXRpbHMvcmVwbGFjZS1zdHJlYW1pbmctY29tbWFuZC1pbi1hcnJheVwiO1xuaW1wb3J0IHsgd3JhcFNpZ25pZmljYW50Q29udGVudCB9IGZyb20gXCIuL3V0aWxzL3dyYXAtc2lnbmlmaWNhbnQtY29udGVudFwiO1xuXG50eXBlIFJlcGxhY2VyID0gKG5vZGVzOiBBc3QuTm9kZVtdKSA9PiBBc3QuTm9kZVtdO1xuXG4vKipcbiAqIFByb2Nlc3Mgc3RyZWFtaW5nIGNvbW1hbmRzIGluIGEgZ3JvdXAuIElmIG5lZWRlZCwgXCJlc2NhcGVcIiB0aGUgZ3JvdXAuXG4gKiBGb3IgZXhhbXBsZSwgYHtcXGJmc2VyaWVzIHh4fWAgLT4gYFxcdGV4dGJme3h4fWAsIGJ1dCBge2ZvbyBcXGJmc2VyaWVzIHh4fWAgLT4gYHtmb28gXFx0ZXh0YmZ7eHh9fWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlU3RyZWFtaW5nQ29tbWFuZEluR3JvdXAoXG4gICAgZ3JvdXA6IEFzdC5Hcm91cCxcbiAgICBpc1N0cmVhbWluZ0NvbW1hbmQ6IChub2RlOiBhbnkpID0+IG5vZGUgaXMgQXN0Lk1hY3JvLFxuICAgIHJlcGxhY2VyOiAoXG4gICAgICAgIGNvbnRlbnQ6IEFzdC5Ob2RlW10sXG4gICAgICAgIHN0cmVhbWluZ0NvbW1hbmQ6IEFzdC5NYWNyb1xuICAgICkgPT4gQXN0Lk5vZGUgfCBBc3QuTm9kZVtdXG4pOiBBc3QuTm9kZVtdIHtcbiAgICBjb25zdCBjb250ZW50ID0gZ3JvdXAuY29udGVudDtcbiAgICAvLyBJZiB0aGUgZ3JvdXAgc3RhcnRlZCB3aXRoIGEgc3RyZWFtaW5nIGNvbW1hbmQsIHdlIHdhbnQgdG8gcG9wXG4gICAgLy8gb3V0IG9mIHRoZSBncm91cC4gRS5nLiBge1xcYmZzZXJpZXMgZm9vfWAgLT4gYFxcdGV4dGJme2Zvb31gIGFuZCBub3QgYHtcXHRleHRiZntmb299fWBcbiAgICBsZXQgcG9wRnJvbUdyb3VwID0gaXNTdHJlYW1pbmdDb21tYW5kKGZpcnN0U2lnbmlmaWNhbnROb2RlKGNvbnRlbnQpKTtcblxuICAgIGxldCBpbm5lclByb2Nlc3NlZCA9IHJlcGxhY2VTdHJlYW1pbmdDb21tYW5kKFxuICAgICAgICBjb250ZW50LFxuICAgICAgICBpc1N0cmVhbWluZ0NvbW1hbmQsXG4gICAgICAgIHJlcGxhY2VyXG4gICAgKTtcblxuICAgIC8vIElmIHRoZSBncm91cCBjb25zaXN0ZWQgb2YganVzdCBzdHJlYW1pbmcgY29tbWFuZHMgKGZvciBzb21lIHJlYXNvbi4uLilcbiAgICAvLyBpdCBzaG91bGQgYmUgZWxpbWluYXRlZFxuICAgIGlmIChpbm5lclByb2Nlc3NlZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmIChwb3BGcm9tR3JvdXApIHtcbiAgICAgICAgcmV0dXJuIGlubmVyUHJvY2Vzc2VkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbeyB0eXBlOiBcImdyb3VwXCIsIGNvbnRlbnQ6IGlubmVyUHJvY2Vzc2VkIH1dO1xuICAgIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhIGdyb3VwIG9yIGEgbm9kZSBhcnJheSwgbG9vayBmb3Igc3RyZWFtaW5nIGNvbW1hbmRzIChlLmcuLCBgXFxiZnNlcmllc2ApIGFuZCByZXBsYWNlIHRoZW1cbiAqIHdpdGggdGhlIHNwZWNpZmllZCBtYWNyby4gVGhlIFwiYXJndW1lbnRzXCIgb2YgdGhlIHN0cmVhbWluZyBjb21tYW5kIGFyZSBwYXNzZWQgdG8gYHJlcGxhY2VyYCBhbmQgdGhlIHJldHVyblxuICogdmFsdWUgb2YgYHJlcGxhY2VyYCBpcyBpbnNlcnRlZCBpbnRvIHRoZSBzdHJlYW0uXG4gKlxuICogQnkgZGVmYXVsdCwgdGhpcyBjb21tYW5kIHdpbGwgc3BsaXQgYXQgcGFyYnJlYWtzIChzaW5jZSBjb21tYW5kcyBsaWtlIGBcXHRleHRiZnsuLi59IGRvIG5vdCBhY2NlcHQgcGFyYnJlYWtzIGluIHRoZWlyXG4gKiBjb250ZW50cykgYW5kIGNhbGwgYHJlcGxhY2VyYCBtdWx0aXBsZSB0aW1lcywgb25jZSBwZXIgcGFyYWdyYXBoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZVN0cmVhbWluZ0NvbW1hbmQoXG4gICAgYXN0OiBBc3QuR3JvdXAgfCBBc3QuTm9kZVtdLFxuICAgIGlzU3RyZWFtaW5nQ29tbWFuZDogKG5vZGU6IGFueSkgPT4gbm9kZSBpcyBBc3QuTWFjcm8sXG4gICAgcmVwbGFjZXI6IChcbiAgICAgICAgY29udGVudDogQXN0Lk5vZGVbXSxcbiAgICAgICAgc3RyZWFtaW5nQ29tbWFuZDogQXN0Lk1hY3JvXG4gICAgKSA9PiBBc3QuTm9kZSB8IEFzdC5Ob2RlW11cbik6IEFzdC5Ob2RlW10ge1xuICAgIGlmICh0eXBlb2YgaXNTdHJlYW1pbmdDb21tYW5kICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYCdpc1N0cmVhbWluZ0NvbW1hbmQnIG11c3QgYmUgYSBmdW5jdGlvbiwgbm90ICcke3R5cGVvZiBpc1N0cmVhbWluZ0NvbW1hbmR9J2BcbiAgICAgICAgKTtcbiAgICB9XG4gICAgbGV0IHByb2Nlc3NlZENvbnRlbnQ6IEFzdC5Ob2RlW10gPSBbXTtcbiAgICBpZiAobWF0Y2guZ3JvdXAoYXN0KSkge1xuICAgICAgICBwcm9jZXNzZWRDb250ZW50ID0gcmVwbGFjZVN0cmVhbWluZ0NvbW1hbmRJbkdyb3VwKFxuICAgICAgICAgICAgYXN0LFxuICAgICAgICAgICAgaXNTdHJlYW1pbmdDb21tYW5kLFxuICAgICAgICAgICAgcmVwbGFjZXJcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhc3QpKSB7XG4gICAgICAgIC8vIFN0cmVhbWluZyBjb21tYW5kcyB0aGF0IGNvbWUgYXQgdGhlIGVuZCBvZiBhIHNlcXVlbmNlIG9mIG5vZGVzIGRvbid0IGRvIGFueXRoaW5nLlxuICAgICAgICAvLyBUaGV5IGFsc28gd2lsbCBjb25zdW1lIHdoaXRlc3BhY2UsIHNvIHdlIHNob3VsZCByZW1vdmUgdGhlbSBhbmQgdGhlIHdoaXRlc3BhY2UuXG4gICAgICAgIGNvbnN0IG5vZGVzID0gYXN0O1xuICAgICAgICBsZXQgc2NhbkluZGV4ID0gbm9kZXMubGVuZ3RoO1xuICAgICAgICBsZXQgc2xpY2VJbmRleCA9IHNjYW5JbmRleDtcbiAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICAgc2NhbkluZGV4ID4gMCAmJlxuICAgICAgICAgICAgKGlzU3RyZWFtaW5nQ29tbWFuZChub2Rlc1tzY2FuSW5kZXggLSAxXSkgfHxcbiAgICAgICAgICAgICAgICBtYXRjaC53aGl0ZXNwYWNlKG5vZGVzW3NjYW5JbmRleCAtIDFdKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBzY2FuSW5kZXgtLTtcbiAgICAgICAgICAgIGlmIChpc1N0cmVhbWluZ0NvbW1hbmQobm9kZXNbc2NhbkluZGV4XSkpIHtcbiAgICAgICAgICAgICAgICBzbGljZUluZGV4ID0gc2NhbkluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzbGljZUluZGV4ICE9PSBub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG5vZGVzLnNwbGljZShzbGljZUluZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGlzUGFyID0gKG5vZGU6IEFzdC5Ob2RlKSA9PlxuICAgICAgICAgICAgbWF0Y2gucGFyYnJlYWsobm9kZSkgfHwgbWF0Y2gubWFjcm8obm9kZSwgXCJwYXJcIik7XG5cbiAgICAgICAgLy8gV2Ugc3BsaXQgb24gYm90aCBhIHBhcmJyZWFrIGFuZCBhIGxpdGVyYWwgYFxccGFyYC4gQnV0IHdlIHdpbGxcbiAgICAgICAgLy8gbm9ybWFsaXplIGV2ZXJ5dGhpbmcgdG8gYmUgcGFyYnJlYWtzXG4gICAgICAgIGNvbnN0IHNwbGl0QnlQYXIgPSBzcGxpdE9uQ29uZGl0aW9uKG5vZGVzLCBpc1Bhcik7XG4gICAgICAgIHNwbGl0QnlQYXIuc2VwYXJhdG9ycyA9IHNwbGl0QnlQYXIuc2VwYXJhdG9ycy5tYXAoKHNlcCkgPT5cbiAgICAgICAgICAgIG1hdGNoLnBhcmJyZWFrKHNlcCkgPyBzZXAgOiB7IHR5cGU6IFwicGFyYnJlYWtcIiB9XG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgcmVwbGFjZXJzOiBSZXBsYWNlcltdID0gW107XG4gICAgICAgIGxldCBzZWdtZW50cyA9IHNwbGl0QnlQYXIuc2VnbWVudHMubWFwKChzZWdtZW50KSA9PiB7XG4gICAgICAgICAgICBmdW5jdGlvbiBhcHBseUFjY3VtdWxhdGVkUmVwbGFjZXJzKG5vZGVzOiBBc3QuTm9kZVtdKTogQXN0Lk5vZGVbXSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2Vycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcFNpZ25pZmljYW50Q29udGVudChcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2VSZXBsYWNlcnMocmVwbGFjZXJzKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHsgZm91bmRTdHJlYW1pbmdDb21tYW5kcyB9ID0gcmVwbGFjZVN0cmVhbWluZ0NvbW1hbmRJbkFycmF5KFxuICAgICAgICAgICAgICAgIHNlZ21lbnQsXG4gICAgICAgICAgICAgICAgaXNTdHJlYW1pbmdDb21tYW5kLFxuICAgICAgICAgICAgICAgIHJlcGxhY2VyXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBBbGwgc3RyZWFtaW5nIGNvbW1hbmRzIGluIGBzZWdtZW50YCBoYXZlIG5vdyBiZWVuIHJlcGxhY2VkLiBIb3dldmVyLFxuICAgICAgICAgICAgLy8gdGhlcmUgbWlnaHQgYmUgY29tbWFuZHMgZnJvbSB0aGUgcHJldmlvdXMgcGFyYWdyYXBocyB0aGF0IHNob3VsZCB3cmFwXG4gICAgICAgICAgICAvLyB0aGUgY3VycmVudCBzZWdtZW50IVxuICAgICAgICAgICAgY29uc3QgcmV0ID0gYXBwbHlBY2N1bXVsYXRlZFJlcGxhY2VycyhzZWdtZW50KTtcblxuICAgICAgICAgICAgLy8gQW55IHN0cmVhbWluZyBjb21tYW5kcyBmcm9tIHRoaXMgc2VnbWVudCB3aWxsIGNhcnJ5IG92ZXIgdG8gdGhlIG5leHQsXG4gICAgICAgICAgICAvLyBzbyBrZWVwIHRyYWNrIG9mIHRoZW0uXG4gICAgICAgICAgICBmb3VuZFN0cmVhbWluZ0NvbW1hbmRzLmZvckVhY2goKG1hY3JvKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZXJzLnB1c2goKG5vZGVzOiBBc3QuTm9kZVtdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IHJlcGxhY2VyKG5vZGVzLCBtYWNybyBhcyBBc3QuTWFjcm8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmV0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtyZXRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTGVhZGluZy90cmFpbGluZyB3aGl0ZXNwYWNlIHdhcyBob2lzdGVkIGluIGZyb250L2JhY2sgb2YgZWFjaCByZXBsYWNlci5cbiAgICAgICAgLy8gU2luY2Ugd2UncmUgc2VwYXJhdGVkIGJ5IHBhcmJyZWFrcywgd2UgY2FuIHNhZmVseSB0cmltIGFsbCB0aGF0IHdoaXRlc3BhY2UuXG4gICAgICAgIGlmIChzZWdtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBzZWdtZW50cy5mb3JFYWNoKChzZWdtZW50LCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdHJpbUVuZChzZWdtZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IHNlZ21lbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJpbVN0YXJ0KHNlZ21lbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyaW0oc2VnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzZWRDb250ZW50ID0gdW5zcGxpdE9uTWFjcm8oe1xuICAgICAgICAgICAgc2VnbWVudHM6IHNlZ21lbnRzLFxuICAgICAgICAgICAgbWFjcm9zOiBzcGxpdEJ5UGFyLnNlcGFyYXRvcnMsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9jZXNzZWRDb250ZW50O1xufVxuXG4vKipcbiAqIEdpdmVuIGEgc2VxdWVuY2Ugb2YgcmVwbGFjZXIgZnVuY3Rpb25zIGBbZiwgZywgaF1gIHJldHVyblxuICogYGggXFxjaXJjIGcgXFxjaXJjIGZgXG4gKlxuICogQHBhcmFtIHsoKG5vZGVzOiBBc3QuTm9kZVtdKSA9PiBBc3QuTm9kZSlbXX0gcmVwbGFjZXJzXG4gKiBAcmV0dXJucyB7KG5vZGVzOiBBc3QuTm9kZVtdKSA9PiBBc3QuTm9kZX1cbiAqL1xuZnVuY3Rpb24gY29tcG9zZVJlcGxhY2VycyhyZXBsYWNlcnM6IFJlcGxhY2VyW10pOiBSZXBsYWNlciB7XG4gICAgaWYgKHJlcGxhY2Vycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXBvc2UgemVybyByZXBsYWNlbWVudCBmdW5jdGlvbnNcIik7XG4gICAgfVxuICAgIHJldHVybiAobm9kZXM6IEFzdC5Ob2RlW10pID0+IHtcbiAgICAgICAgbGV0IHJldCA9IG5vZGVzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcGxhY2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZnVuYyA9IHJlcGxhY2Vyc1tpXTtcbiAgICAgICAgICAgIHJldCA9IGZ1bmMocmV0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG59XG4iLCJpbXBvcnQgeyBQbHVnaW4gfSBmcm9tIFwidW5pZmllZFwiO1xuaW1wb3J0IHsgcmVwbGFjZU5vZGVEdXJpbmdWaXNpdCB9IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LWxpbnQvdXRpbHMvcmVwbGFjZS1ub2RlXCI7XG5pbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IG1hdGNoIH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdXRpbC1tYXRjaFwiO1xuaW1wb3J0IHsgdHJpbUVuZCwgdHJpbVN0YXJ0IH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdXRpbC10cmltXCI7XG5pbXBvcnQgeyB2aXNpdCB9IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXV0aWwtdmlzaXRcIjtcbmltcG9ydCB7IHJlcGxhY2VTdHJlYW1pbmdDb21tYW5kIH0gZnJvbSBcIi4vcmVwbGFjZS1zdHJlYW1pbmctY29tbWFuZFwiO1xuXG50eXBlIFBsdWdpbk9wdGlvbnMgPSB7XG4gICAgcmVwbGFjZXJzOiBSZWNvcmQ8XG4gICAgICAgIHN0cmluZyxcbiAgICAgICAgKFxuICAgICAgICAgICAgY29udGVudDogQXN0Lk5vZGVbXSxcbiAgICAgICAgICAgIHN0cmVhbWluZ0NvbW1hbmQ6IEFzdC5NYWNyb1xuICAgICAgICApID0+IEFzdC5Ob2RlIHwgQXN0Lk5vZGVbXVxuICAgID47XG59O1xuXG4vKipcbiAqIFVuaWZpZWQgcGx1Z2luIHRvIHJlcGxhY2UgYWxsIGZvdW5kIHN0cmVhbWluZyBjb21tYW5kcyB3aXRoIHRoZWlyIGFyZ3VtZW50LXN0eWxlIGVxdWl2YWxlbnRzLlxuICogVGhpcyBvbmx5IGFwcGxpZXMgdG8gc2VjdGlvbnMgb2YgdGhlIHRyZWUgd2l0aCBubyBtYXRoIGFuY2VzdG9yLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zLnJlcGxhY2VyIEEgcmVjb3JkIG9mIG1hY3JvIG5hbWVzIGFuZCByZXBsYWNlciBmdW5jdGlvbnMuIEEgcmVwbGFjZXIgZnVuY3Rpb24gYWNjZXB0cyBjb250ZW50IGFuZCB0aGUgb3JpZ2luYWwgc3RyZWFtaW5nIGNvbW1hbmQgYW5kIGlzIGV4cGVjdGVkIHRvIHJldHVybiB0aGUgYXJndW1lbnQtc3R5bGUgY29tbWFuZC4gSXQgbWF5IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBwZXIgc3RyZWFtaW5nIGNvbW1hbmQuXG4gKi9cbmV4cG9ydCBjb25zdCB1bmlmaWVkTGF0ZXhSZXBsYWNlU3RyZWFtaW5nQ29tbWFuZHM6IFBsdWdpbjxcbiAgICBQbHVnaW5PcHRpb25zW10sXG4gICAgQXN0LlJvb3QsXG4gICAgQXN0LlJvb3Rcbj4gPSBmdW5jdGlvbiB1bmlmaWVkTGF0ZXhSZXBsYWNlU3RyZWFtaW5nQ29tbWFuZHMob3B0aW9ucykge1xuICAgIGNvbnN0IHsgcmVwbGFjZXJzID0ge30gfSA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgaXNSZXBsYWNlYWJsZSA9IG1hdGNoLmNyZWF0ZU1hY3JvTWF0Y2hlcihyZXBsYWNlcnMpO1xuICAgIHJldHVybiAodHJlZSkgPT4ge1xuICAgICAgICB2aXNpdChcbiAgICAgICAgICAgIHRyZWUsXG4gICAgICAgICAgICAoZ3JvdXAsIGluZm8pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGluZm8uY29udGV4dC5oYXNNYXRoTW9kZUFuY2VzdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgICFncm91cC5jb250ZW50LnNvbWUoaXNSZXBsYWNlYWJsZSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBmaXhlZCA9IHJlcGxhY2VTdHJlYW1pbmdDb21tYW5kKFxuICAgICAgICAgICAgICAgICAgICBncm91cCxcbiAgICAgICAgICAgICAgICAgICAgaXNSZXBsYWNlYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgKGNvbnRlbnQsIGNvbW1hbmQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlcnNbY29tbWFuZC5jb250ZW50XShjb250ZW50LCBjb21tYW5kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBjYW5ub3QgcmVwbGFjZSB0aGUgbm9kZSB1bmxlc3Mgd2UgY2FuIGFjY2VzcyB0aGUgY29udGFpbmluZyBhcnJheS5cbiAgICAgICAgICAgICAgICBpZiAoIWluZm8uY29udGFpbmluZ0FycmF5IHx8IGluZm8uaW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYGZpeGVkYCBtYXkgY29uc2lzdCBvZiBvbmx5IHdoaXRlc3BhY2UuIElmIHRoaXMgaXMgdGhlIGNhc2UsXG4gICAgICAgICAgICAgICAgLy8gc3Vycm91bmRpbmcgd2hpdGVzcGFjZSBtdXN0IHRyaW1tZWQgYmVmb3JlXG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0aW5nIHRoZSBncm91cCdzIGNvbnRlbnRzLlxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZUb2tlbiA9IGluZm8uY29udGFpbmluZ0FycmF5W2luZm8uaW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0VG9rZW4gPSBpbmZvLmNvbnRhaW5pbmdBcnJheVtpbmZvLmluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBtYXRjaC53aGl0ZXNwYWNlTGlrZShwcmV2VG9rZW4pICYmXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoLndoaXRlc3BhY2VMaWtlKGZpeGVkWzBdKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB0cmltU3RhcnQoZml4ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoLndoaXRlc3BhY2VMaWtlKG5leHRUb2tlbikgJiZcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2gud2hpdGVzcGFjZUxpa2UoZml4ZWRbZml4ZWQubGVuZ3RoIC0gMV0pXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyaW1FbmQoZml4ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXBsYWNlTm9kZUR1cmluZ1Zpc2l0KGZpeGVkLCBpbmZvKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IHRlc3Q6IG1hdGNoLmdyb3VwIH1cbiAgICAgICAgKTtcblxuICAgICAgICB2aXNpdChcbiAgICAgICAgICAgIHRyZWUsXG4gICAgICAgICAgICAobm9kZXMsIGluZm8pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGluZm8uY29udGV4dC5oYXNNYXRoTW9kZUFuY2VzdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgICFub2Rlcy5zb21lKGlzUmVwbGFjZWFibGUpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlZCA9IHJlcGxhY2VTdHJlYW1pbmdDb21tYW5kKFxuICAgICAgICAgICAgICAgICAgICBub2RlcyxcbiAgICAgICAgICAgICAgICAgICAgaXNSZXBsYWNlYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgKGNvbnRlbnQsIGNvbW1hbmQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlcnNbY29tbWFuZC5jb250ZW50XShjb250ZW50LCBjb21tYW5kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBnZXQgYmFjayBhIGRpZmZlcmVudCBhcnJheSB0aGFuIHdlIGlucHV0LCB0aGUgcmVwbGFjZW1lbnQgZGlkXG4gICAgICAgICAgICAgICAgLy8gbm90IGhhcHBlbiBpbi1wbGFjZS4gSW4gdGhpcyBjYXNlIHdlIG5lZWQgdG8gbWFuaXB1bGF0ZSBgbm9kZXNgLlxuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlZCAhPT0gbm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaCguLi5yZXBsYWNlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgaW5jbHVkZUFycmF5czogdHJ1ZSwgdGVzdDogQXJyYXkuaXNBcnJheSB9XG4gICAgICAgICk7XG4gICAgfTtcbn07XG4iLCJpbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IG1hdGNoIH0gZnJvbSBcIi4uLy4uLy4uL3VuaWZpZWQtbGF0ZXgtdXRpbC1tYXRjaFwiO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IG5vbi13aGl0ZXNwYWNlL25vbi1jb21tZW50IG5vZGUgaW4gYG5vZGVzYC4gSWYgdGhlcmUgaXMgbm8gc3VjaFxuICogbm9kZSwgYG51bGxgIGlzIHJldHVybmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmlyc3RTaWduaWZpY2FudE5vZGUobm9kZXM6IEFzdC5Ob2RlW10pOiBBc3QuTm9kZSB8IG51bGwge1xuICAgIGxldCBmaXJzdE5vZGU6IEFzdC5Ob2RlIHwgbnVsbCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgIGlmIChtYXRjaC53aGl0ZXNwYWNlKG5vZGUpIHx8IG1hdGNoLmNvbW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZpcnN0Tm9kZSA9IG5vZGU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBmaXJzdE5vZGU7XG59XG4iLCJpbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IG1hdGNoIH0gZnJvbSBcIi4uLy4uLy4uL3VuaWZpZWQtbGF0ZXgtdXRpbC1tYXRjaFwiO1xuaW1wb3J0IHsgdHJpbVN0YXJ0IH0gZnJvbSBcIi4uLy4uLy4uL3VuaWZpZWQtbGF0ZXgtdXRpbC10cmltXCI7XG5cbi8qKlxuICogSXMgdGhlIG5vZGUgc3BhY2UtbGlrZT8gSS5lLiwgaXMgaXQgd2hpdGVzcGFjZSBvclxuICogYSBjb21tZW50IHdpdGggbGVhZGluZyB3aGl0ZXNwYWNlP1xuICovXG5mdW5jdGlvbiBpc1NwYWNlTGlrZShub2RlOiBBc3QuTm9kZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAoXG4gICAgICAgIG1hdGNoLndoaXRlc3BhY2Uobm9kZSkgfHxcbiAgICAgICAgKG1hdGNoLmNvbW1lbnQobm9kZSkgJiYgQm9vbGVhbihub2RlLmxlYWRpbmdXaGl0ZXNwYWNlKSlcbiAgICApO1xufVxuXG4vKipcbiAqIFNpbWlsYXIgdG8gYGhlYWQucHVzaCguLi50YWlsKWAgZXhjZXB0IHRoYXQgd2hpdGVzcGFjZSBhdCB0aGUgc3RhcnRcbiAqIG9mIGB0YWlsYCBhbmQgdGhlIGVuZCBvZiBgaGVhZGAgaXMgY29sbGFwc2VkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gam9pbldpdGhvdXRFeGNlc3NXaGl0ZXNwYWNlKFxuICAgIGhlYWQ6IEFzdC5Ob2RlW10sXG4gICAgdGFpbDogQXN0Lk5vZGVbXVxuKTogdm9pZCB7XG4gICAgaWYgKHRhaWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGhlYWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGhlYWQucHVzaCguLi50YWlsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBoZWFkRW5kID0gaGVhZFtoZWFkLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHRhaWxTdGFydCA9IHRhaWxbMF07XG4gICAgLy8gV2hpdGVzcGFjZSB3ZSBjYW4ganVzdCB0cmltIG9mZiBmcm9tIGVpdGhlciBlbmRcbiAgICBpZiAobWF0Y2gud2hpdGVzcGFjZShoZWFkRW5kKSAmJiBtYXRjaC53aGl0ZXNwYWNlKHRhaWxTdGFydCkpIHtcbiAgICAgICAgaGVhZC5wdXNoKC4uLnRhaWwuc2xpY2UoMSkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHRoZXJlJ3Mgbm8gd2hpdGVzcGFjZSBhdCBvbmUgb2YgdGhlIGVuZHMsIG5vIG5lZWQgdG8gd29ycnlcbiAgICAvLyB1bmxlc3MgYHRhaWxTdGFydGAgaXMgYSBjb21tZW50LCBpbiB3aGljaCBjYXNlIGl0IHNob3VsZCBcImVhdFwiXG4gICAgLy8gdGhlIHdoaXRlc3BhY2VcbiAgICBpZiAoIWlzU3BhY2VMaWtlKGhlYWRFbmQpIHx8ICFpc1NwYWNlTGlrZSh0YWlsU3RhcnQpKSB7XG4gICAgICAgIGlmIChtYXRjaC53aGl0ZXNwYWNlKGhlYWRFbmQpICYmIG1hdGNoLmNvbW1lbnQodGFpbFN0YXJ0KSkge1xuICAgICAgICAgICAgY29uc3QgY29tbWVudDogQXN0LkNvbW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb21tZW50XCIsXG4gICAgICAgICAgICAgICAgY29udGVudDogdGFpbFN0YXJ0LmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgc2FtZWxpbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgbGVhZGluZ1doaXRlc3BhY2U6IHRydWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGFpbCA9IHRhaWwuc2xpY2UoMSk7XG4gICAgICAgICAgICB0cmltU3RhcnQodGFpbCk7XG4gICAgICAgICAgICBoZWFkLnBvcCgpO1xuICAgICAgICAgICAgaGVhZC5wdXNoKGNvbW1lbnQsIC4uLnRhaWwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGhlYWQucHVzaCguLi50YWlsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHdlJ3JlIGhlcmUsIHdlIGhhdmUgYSBjb21tZW50IHdpdGggbGVhZGluZyB3aGl0ZXNwYWNlIG9uIG9uZSBzaWRlXG4gICAgLy8gYW5kIHdoaXRlc3BhY2UvY29tbWVudHMgb24gdGhlIG90aGVyLlxuICAgIGlmIChtYXRjaC5jb21tZW50KGhlYWRFbmQpICYmIG1hdGNoLmNvbW1lbnQodGFpbFN0YXJ0KSkge1xuICAgICAgICBpZiAodGFpbFN0YXJ0LmxlYWRpbmdXaGl0ZXNwYWNlIHx8IHRhaWxTdGFydC5zYW1lbGluZSkge1xuICAgICAgICAgICAgaGVhZC5wdXNoKFxuICAgICAgICAgICAgICAgIHsgdHlwZTogXCJjb21tZW50XCIsIGNvbnRlbnQ6IHRhaWxTdGFydC5jb250ZW50IH0sXG4gICAgICAgICAgICAgICAgLi4udGFpbC5zbGljZSgxKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBoZWFkLnB1c2goLi4udGFpbCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBFeGFjdGx5IG9uZSBzaWRlIGlzIGEgY29tbWVudCwgc28gd2Ugc2hvdWxkIHRyaW0gdGhlIHdoaXRlc3BhY2UgYW5kIGtlZXAgdGhlIGNvbW1lbnQsXG4gICAgLy8gYnV0IG1ha2Ugc3VyZSB0aGUgY29tbWVudCBoYXMgbGVhZGluZyB3aGl0ZXNwYWNlIVxuICAgIGxldCBjb21tZW50ID0gbWF0Y2guY29tbWVudChoZWFkRW5kKSA/IGhlYWRFbmQgOiB0YWlsU3RhcnQ7XG4gICAgaWYgKCFtYXRjaC5jb21tZW50KGNvbW1lbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhIGNvbW1lbnQgYnV0IGZvdW5kICR7SlNPTi5zdHJpbmdpZnkoY29tbWVudCl9YFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmICghY29tbWVudC5sZWFkaW5nV2hpdGVzcGFjZSB8fCAhY29tbWVudC5zYW1lbGluZSkge1xuICAgICAgICBjb21tZW50ID0ge1xuICAgICAgICAgICAgdHlwZTogXCJjb21tZW50XCIsXG4gICAgICAgICAgICBjb250ZW50OiBjb21tZW50LmNvbnRlbnQsXG4gICAgICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZTogdHJ1ZSxcbiAgICAgICAgICAgIHNhbWVsaW5lOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGhlYWQucG9wKCk7XG4gICAgaGVhZC5wdXNoKGNvbW1lbnQsIC4uLnRhaWwuc2xpY2UoMSkpO1xufVxuIiwiaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5pbXBvcnQgeyB0cmltRW5kLCB0cmltU3RhcnQgfSBmcm9tIFwiLi4vLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLXRyaW1cIjtcbmltcG9ydCB7IGpvaW5XaXRob3V0RXhjZXNzV2hpdGVzcGFjZSB9IGZyb20gXCIuL2pvaW4td2l0aG91dC1leGNlc3Mtd2hpdGVzcGFjZVwiO1xuaW1wb3J0IHsgd3JhcFNpZ25pZmljYW50Q29udGVudCB9IGZyb20gXCIuL3dyYXAtc2lnbmlmaWNhbnQtY29udGVudFwiO1xuXG4vKipcbiAqIFJlcGxhY2UgY29tbWFuZHMgaWRlbnRpZmllZCBieSBgaXNTdHJlYW1pbmdDb21tYW5kYCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgYHJlcGxhY2VyYC5cbiAqIEUuZy4sIHRoZSBhcnJheSBgW2hlYWQsIHN0cmVhbWluZ0NvbW1hbmQsIC4uLnRhaWxdYCB3aWxsIGJlY29tZSBgW2hlYWQsIHJlcGxhY2VyKHRhaWwsIHN0cmVhbWluZ0NvbW1hbmQpXWAuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHNwbGl0IGJhc2VkIG9uIHBhcmJyZWFrcy9ldGMuLiBJdCBpcyByaWdodC1hc3NvY2lhdGl2ZSBhbmQgcmV0dXJuc1xuICogdGhlIHN0cmVhbWluZyBjb21tYW5kcyB0aGF0IHdlcmUgZW5jb3VudGVyZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlU3RyZWFtaW5nQ29tbWFuZEluQXJyYXkoXG4gICAgbm9kZXM6IEFzdC5Ob2RlW10sXG4gICAgaXNTdHJlYW1pbmdDb21tYW5kOiAobm9kZTogYW55KSA9PiBub2RlIGlzIEFzdC5NYWNybyxcbiAgICByZXBsYWNlcjogKFxuICAgICAgICBjb250ZW50OiBBc3QuTm9kZVtdLFxuICAgICAgICBzdHJlYW1pbmdDb21tYW5kOiBBc3QuTWFjcm9cbiAgICApID0+IEFzdC5Ob2RlIHwgQXN0Lk5vZGVbXVxuKTogeyBmb3VuZFN0cmVhbWluZ0NvbW1hbmRzOiBBc3QuTm9kZVtdIH0ge1xuICAgIC8vIFN0cmVhbWluZyBjb21tYW5kcyB0aGF0IGNvbWUgYXQgdGhlIGVuZCBkb24ndCBkbyBhbnl0aGluZyxcbiAgICAvLyBzbyB3ZSBzaG91bGQgcmVtb3ZlIHRoZW1cbiAgICB3aGlsZSAobm9kZXMubGVuZ3RoID4gMCAmJiBpc1N0cmVhbWluZ0NvbW1hbmQobm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIG5vZGVzLnBvcCgpO1xuICAgICAgICB0cmltRW5kKG5vZGVzKTtcbiAgICB9XG5cbiAgICBjb25zdCBmb3VuZFN0cmVhbWluZ0NvbW1hbmRzOiBBc3QuTm9kZVtdID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gbm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAoaXNTdHJlYW1pbmdDb21tYW5kKG5vZGUpKSB7XG4gICAgICAgICAgICBjb25zdCB3cmFwcGVyID0gKGNvbnRlbnQ6IEFzdC5Ob2RlW10pID0+IHJlcGxhY2VyKGNvbnRlbnQsIG5vZGUpO1xuICAgICAgICAgICAgbGV0IHRhaWwgPSBub2Rlcy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICAvLyBTdHJlYW1pbmcgY29tbWFuZHMgYXJlIGZvbGxvd2VkIGJ5IHdoaXRlc3BhY2UsIHdoaWNoIGJlY29tZXMgdW5uZWVkZWQgd2hlbiB0aGUgY29tbWFuZHMgYXJlIHJlcGxhY2VkLlxuICAgICAgICAgICAgdHJpbVN0YXJ0KHRhaWwpO1xuICAgICAgICAgICAgdGFpbCA9IHdyYXBTaWduaWZpY2FudENvbnRlbnQodGFpbCwgd3JhcHBlcik7XG4gICAgICAgICAgICBmb3VuZFN0cmVhbWluZ0NvbW1hbmRzLnB1c2gobm9kZSk7XG5cbiAgICAgICAgICAgIC8vIFRyaW0gb2ZmIHdoYXQgd2UncmUgYWJvdXQgdG8gcmVwbGFjZSFcbiAgICAgICAgICAgIG5vZGVzLnNwbGljZShpKTtcblxuICAgICAgICAgICAgam9pbldpdGhvdXRFeGNlc3NXaGl0ZXNwYWNlKG5vZGVzLCB0YWlsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGZvdW5kU3RyZWFtaW5nQ29tbWFuZHMgfTtcbn1cbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi4vLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoXCI7XG5cbi8qKlxuICogV3JhcHMgYGNvbnRlbnRgIGluIHRoZSBzcGVjaWZpZWQgd3JhcHBlci4gVGhpcyBjb21tYW5kIGlzIHJvdWdobHkgZXF1aXZhbGVudCB0b1xuICogYHdyYXBwZXIoY29udGVudClgIGV4Y2VwdCB0aGF0IGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UgYW5kIGNvbW1lbnRzIGFyZSBleHRyYWN0ZWRcbiAqIGZyb20gYGNvbnRlbnRgIGFuZCBtb3ZlZCB0byB0aGUgZnJvbnQgb3IgYmFjayBvZiB0aGUgcmV0dXJuIGFycmF5LiBGb3IgZXhhbXBsZSxcbiAqIGBbXCIgXCIsIFwiZm9vXCIsIFwiYmFyXCIsIFwiJSB4eHhcIl1gIC0+IGBbXCIgXCIsIHdyYXBwZWQoW1wiZm9vXCIsIFwiYmFyXCJdKSwgXCIlIHh4eFwiXWAuXG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gd3JhcFNpZ25pZmljYW50Q29udGVudChcbiAgICBjb250ZW50OiBBc3QuTm9kZVtdLFxuICAgIHdyYXBwZXI6IChjb250ZW50OiBBc3QuTm9kZVtdKSA9PiBBc3QuTm9kZVtdIHwgQXN0Lk5vZGVcbik6IEFzdC5Ob2RlW10ge1xuICAgIGxldCBob2lzdFVudGlsID0gMDtcbiAgICBsZXQgaG9pc3RBZnRlciA9IGNvbnRlbnQubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobWF0Y2gud2hpdGVzcGFjZShjb250ZW50W2ldKSB8fCBtYXRjaC5jb21tZW50KGNvbnRlbnRbaV0pKSB7XG4gICAgICAgICAgICBob2lzdFVudGlsID0gaSArIDE7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IGNvbnRlbnQubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgaWYgKG1hdGNoLndoaXRlc3BhY2UoY29udGVudFtqXSkgfHwgbWF0Y2guY29tbWVudChjb250ZW50W2pdKSkge1xuICAgICAgICAgICAgaG9pc3RBZnRlciA9IGo7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoaG9pc3RVbnRpbCA9PT0gMCAmJiBob2lzdEFmdGVyID09PSBjb250ZW50Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZW5zdXJlQXJyYXkod3JhcHBlcihjb250ZW50KSk7XG4gICAgfVxuXG4gICAgY29uc3QgZnJvbnRNYXR0ZXIgPSBjb250ZW50LnNsaWNlKDAsIGhvaXN0VW50aWwpO1xuICAgIGNvbnN0IG1pZGRsZSA9IGNvbnRlbnQuc2xpY2UoaG9pc3RVbnRpbCwgaG9pc3RBZnRlcik7XG4gICAgY29uc3QgYmFja01hdHRlciA9IGNvbnRlbnQuc2xpY2UoaG9pc3RBZnRlciwgY29udGVudC5sZW5ndGgpO1xuXG4gICAgcmV0dXJuIGZyb250TWF0dGVyLmNvbmNhdCh3cmFwcGVyKG1pZGRsZSksIGJhY2tNYXR0ZXIpO1xufVxuXG5mdW5jdGlvbiBlbnN1cmVBcnJheSh4OiBBc3QuTm9kZSB8IEFzdC5Ob2RlW10pIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICAgICAgcmV0dXJuIFt4XTtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG59XG4iLCJleHBvcnQgKiBmcm9tIFwiLi9saWJzL3NwbGl0LW9uLW1hY3JvXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9saWJzL3NwbGl0LW9uLWNvbmRpdGlvblwiO1xuZXhwb3J0ICogZnJvbSBcIi4vbGlicy91bnNwbGl0LW9uLW1hY3JvXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9saWJzL2FycmF5LWpvaW5cIjtcblxuLy8gTk9URTogVGhlIGRvY3N0cmluZyBjb21tZW50IG11c3QgYmUgdGhlIGxhc3QgaXRlbSBpbiB0aGUgaW5kZXgudHMgZmlsZSFcbi8qKlxuICogIyMgV2hhdCBpcyB0aGlzP1xuICpcbiAqIEZ1bmN0aW9ucyB0byBtYW5pcHVsYXRlIGB1bmlmaWVkLWxhdGV4YCBBYnN0cmFjdCBTeW50YXggVHJlZSAoQVNUKS5cbiAqXG4gKiAjIyBXaGVuIHNob3VsZCBJIHVzZSB0aGlzP1xuICpcbiAqIElmIHlvdSB3YW50IGJyZWFrIGFwYXJ0IG9yIGpvaW4gYW4gYXJyYXkgb2Ygbm9kZXMgYmFzZWQgb24gYSBjb25kaXRpb24uIEZvciBleGFtcGxlLFxuICogdGhpcyBpcyB1c2VkIHRvIHNwbGl0IG9uIGAmYCBjaGFyYWN0ZXJzIGluIHRoZSBgYWxpZ25gIGVudmlyb25tZW50LlxuICovIiwiLyoqXG4gKiBKb2lucyBhbiBhcnJheSBvZiBhcnJheXMgd2l0aCB0aGUgaXRlbSBgc2VwYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlKb2luPFQ+KGFycmF5OiBUW11bXSwgc2VwOiBUIHwgVFtdKTogVFtdIHtcbiAgICByZXR1cm4gYXJyYXkuZmxhdE1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2VwKSkge1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5zZXAsIC4uLml0ZW1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtzZXAsIC4uLml0ZW1dO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4iLCJpbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcblxuLyoqXG4gKiBTcGxpdCBhIGxpc3Qgb2Ygbm9kZXMgYmFzZWQgb24gd2hldGhlciBgc3BsaXRGdW5jYCByZXR1cm5zIGB0cnVlYC5cbiAqIElmIGBvbmx5U3BsaXRPbkZpcnN0T2NjdXJyZW5jZWAgaXMgc2V0IHRvIHRydWUgaW4gdGhlIGBvcHRpb25zYCBvYmplY3QsIHRoZW5cbiAqIHRoZXJlIHdpbGwgYmUgYXQgbW9zdCB0d28gc2VnbWVudHMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdE9uQ29uZGl0aW9uKFxuICAgIG5vZGVzOiBBc3QuTm9kZVtdLFxuICAgIHNwbGl0RnVuYzogKG5vZGU6IEFzdC5Ob2RlKSA9PiBib29sZWFuID0gKCkgPT4gZmFsc2UsXG4gICAgb3B0aW9ucz86IHsgb25seVNwbGl0T25GaXJzdE9jY3VycmVuY2U/OiBib29sZWFuIH1cbik6IHsgc2VnbWVudHM6IEFzdC5Ob2RlW11bXTsgc2VwYXJhdG9yczogQXN0Lk5vZGVbXSB9IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobm9kZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuIG9ubHkgc3BsaXQgYW4gQXJyYXksIG5vdCAke25vZGVzfWApO1xuICAgIH1cblxuICAgIGNvbnN0IHsgb25seVNwbGl0T25GaXJzdE9jY3VycmVuY2UgPSBmYWxzZSB9ID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGNvbnN0IHNwbGl0SW5kaWNlczogbnVtYmVyW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzcGxpdEZ1bmMobm9kZXNbaV0pKSB7XG4gICAgICAgICAgICBzcGxpdEluZGljZXMucHVzaChpKTtcbiAgICAgICAgICAgIGlmIChvbmx5U3BsaXRPbkZpcnN0T2NjdXJyZW5jZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2hvcnQgY2lyY3VpdCBpZiB0aGVyZSBpcyBubyBzcGxpdHRpbmcgdG8gYmUgZG9uZVxuICAgIGlmIChzcGxpdEluZGljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7IHNlZ21lbnRzOiBbbm9kZXNdLCBzZXBhcmF0b3JzOiBbXSB9O1xuICAgIH1cblxuICAgIGxldCBzZXBhcmF0b3JzID0gc3BsaXRJbmRpY2VzLm1hcCgoaSkgPT4gbm9kZXNbaV0pO1xuICAgIGxldCBzZWdtZW50cyA9IHNwbGl0SW5kaWNlcy5tYXAoKHNwbGl0RW5kLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHNwbGl0U3RhcnQgPSBpID09PSAwID8gMCA6IHNwbGl0SW5kaWNlc1tpIC0gMV0gKyAxO1xuICAgICAgICByZXR1cm4gbm9kZXMuc2xpY2Uoc3BsaXRTdGFydCwgc3BsaXRFbmQpO1xuICAgIH0pO1xuICAgIHNlZ21lbnRzLnB1c2goXG4gICAgICAgIG5vZGVzLnNsaWNlKHNwbGl0SW5kaWNlc1tzcGxpdEluZGljZXMubGVuZ3RoIC0gMV0gKyAxLCBub2Rlcy5sZW5ndGgpXG4gICAgKTtcblxuICAgIHJldHVybiB7IHNlZ21lbnRzLCBzZXBhcmF0b3JzIH07XG59XG4iLCJpbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IG1hdGNoIH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdXRpbC1tYXRjaFwiO1xuaW1wb3J0IHsgc3BsaXRPbkNvbmRpdGlvbiB9IGZyb20gXCIuL3NwbGl0LW9uLWNvbmRpdGlvblwiO1xuXG4vKipcbiAqIFNwbGl0IGFuIGFycmF5IG9mIEFTVCBub2RlcyBiYXNlZCBvbiBhIG1hY3JvLiBBbiBvYmplY3QgYHtzZWdtZW50czogW10sIG1hY3JvczogW119YFxuICogaXMgcmV0dXJuZWQuIFRoZSBvcmlnaW5hbCBhcnJheSBpcyByZWNvbnN0cnVjdGVkIGFzXG4gKiBgc2VnbWVudHNbMF0gKyBtYWNyb3NbMF0gKyBzZWdtZW50c1sxXSArIC4uLmAuXG4gKlxuICogQHBhcmFtIHtbb2JqZWN0XX0gYXN0XG4gKiBAcGFyYW0geyhzdHJpbmd8W3N0cmluZ10pfSBtYWNyb05hbWVcbiAqIEByZXR1cm5zIHt7c2VnbWVudHM6IFtvYmplY3RdLCBtYWNyb3M6IFtvYmplY3RdfX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0T25NYWNybyhcbiAgICBhc3Q6IEFzdC5Ob2RlW10sXG4gICAgbWFjcm9OYW1lOiBzdHJpbmcgfCBzdHJpbmdbXVxuKTogeyBzZWdtZW50czogQXN0Lk5vZGVbXVtdOyBtYWNyb3M6IEFzdC5NYWNyb1tdIH0ge1xuICAgIGlmICh0eXBlb2YgbWFjcm9OYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1hY3JvTmFtZSA9IFttYWNyb05hbWVdO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobWFjcm9OYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlIGNvZXJjaW9uIGZhaWxlZFwiKTtcbiAgICB9XG4gICAgY29uc3QgaXNTZXBhcmF0b3IgPSBtYXRjaC5jcmVhdGVNYWNyb01hdGNoZXIobWFjcm9OYW1lKTtcbiAgICBjb25zdCB7IHNlZ21lbnRzLCBzZXBhcmF0b3JzIH0gPSBzcGxpdE9uQ29uZGl0aW9uKGFzdCwgaXNTZXBhcmF0b3IpO1xuICAgIHJldHVybiB7IHNlZ21lbnRzLCBtYWNyb3M6IHNlcGFyYXRvcnMgYXMgQXN0Lk1hY3JvW10gfTtcbn1cbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuXG4vKipcbiAqIERvZXMgdGhlIHJldmVyc2Ugb2YgYHNwbGl0T25NYWNyb2BcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVuc3BsaXRPbk1hY3JvKHtcbiAgICBzZWdtZW50cyxcbiAgICBtYWNyb3MsXG59OiB7XG4gICAgc2VnbWVudHM6IEFzdC5Ob2RlW11bXTtcbiAgICBtYWNyb3M6IEFzdC5Ob2RlW10gfCBBc3QuTm9kZVtdW107XG59KSB7XG4gICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJUcnlpbmcgdG8gam9pbiB6ZXJvIHNlZ21lbnRzXCIpO1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChzZWdtZW50cy5sZW5ndGggIT09IG1hY3Jvcy5sZW5ndGggKyAxKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiTWlzbWF0Y2ggYmV0d2VlbiBsZW5ndGhzIG9mIG1hY3JvcyBhbmQgc2VnbWVudHMgd2hlbiB0cnlpbmcgdG8gdW5zcGxpdFwiXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IHJldCA9IHNlZ21lbnRzWzBdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFjcm9zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEV2ZW4gdGhvdWdoIHRoZSB0eXBlIG9mIG1hY3Jvc1tpXSBpcyBub2RlIGFuZCBub3QgYXJyYXksXG4gICAgICAgIC8vIEFycmF5LmNvbmNhdCBzdGlsbCB3b3Jrc1xuICAgICAgICByZXQgPSByZXQuY29uY2F0KG1hY3Jvc1tpXSkuY29uY2F0KHNlZ21lbnRzW2kgKyAxXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn1cbiIsImV4cG9ydCAqIGZyb20gXCIuL2xpYnMvdHJpbVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vbGlicy91bmlmaWVkLWxhdGV4LXRyaW0tZW52aXJvbm1lbnQtY29udGVudHNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2xpYnMvdW5pZmllZC1sYXRleC10cmltLXJvb3RcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2xpYnMvaGFzLXdoaXRlc3BhY2UtZXF1aXZhbGVudFwiO1xuXG4vLyBOT1RFOiBUaGUgZG9jc3RyaW5nIGNvbW1lbnQgbXVzdCBiZSB0aGUgbGFzdCBpdGVtIGluIHRoZSBpbmRleC50cyBmaWxlIVxuLyoqXG4gKiAjIyBXaGF0IGlzIHRoaXM/XG4gKlxuICogRnVuY3Rpb25zIHRvIGhlbHAgbW9kaWZ5IGEgYHVuaWZpZWQtbGF0ZXhgIEFic3RyYWN0IFN5bnRheCBUcmVlIChBU1QpLlxuICpcbiAqICMjIFdoZW4gc2hvdWxkIEkgdXNlIHRoaXM/XG4gKlxuICogSWYgeW91IHdhbnQgdG8gcmVtb3ZlIHdoaXRlc3BhY2UgZnJvbSB0aGUgZW5kcyBvZiBhbiBhcnJheSBvZiBub2Rlcy5cbiAqXG4gKiBOb3RlIHRoYXQgd2hpdGVzcGFjZSBjYW4gY29tZSBmcm9tIGEgYEFzdC5XaGl0ZXNwYWNlYCBub2RlIG9yIGZyb20gYW5cbiAqIGBBc3QuQ29tbWVudGAgbm9kZSB0aGF0IGhhcyBsZWFkaW5nIHdoaXRlc3BhY2UuIFRoZXNlIGZ1bmN0aW9ucyB0YWtlIGNhcmVcbiAqIHRvIGRlYWwgd2l0aCBib3RoIHNpdHVhdGlvbnMuXG4gKi9cbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoXCI7XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBhcnJheSBoYXMgd2hpdGVzcGFjZSBhdCB0aGUgc3RhcnQvZW5kLiBDb21tZW50cyB3aXRoIGBsZWFkaW5nV2hpdGVzcGFjZSA9PT0gdHJ1ZWBcbiAqIGFyZSBjb3VudGVkIGFzIHdoaXRlc3BhY2UuIE90aGVyIGNvbW1lbnRzIGFyZSBpZ25vcmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzV2hpdGVzcGFjZUVxdWl2YWxlbnQobm9kZXM6IEFzdC5Ob2RlW10pOiB7XG4gICAgc3RhcnQ6IGJvb2xlYW47XG4gICAgZW5kOiBib29sZWFuO1xufSB7XG4gICAgbGV0IHN0YXJ0ID0gZmFsc2U7XG4gICAgbGV0IGVuZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobWF0Y2guY29tbWVudChub2RlKSkge1xuICAgICAgICAgICAgLy8gQSBjb21tZW50IHdpdGggbGVhZGluZyB3aGl0ZXNwYWNlIHdpbGwgcmVuZGVyIHdpdGggbGVhZGluZyB3aGl0ZXNwYWNlLFxuICAgICAgICAgICAgLy8gc28gaWYgd2UgZW5jb3VudGVyIG9uZSwgd2Ugc2hvdWxkIGNvbnNpZGVyIG91cnNlbHZlcyB0byBoYXZlIGxlYWRpbmcgd2hpdGVzcGFjZS5cbiAgICAgICAgICAgIGlmIChub2RlLmxlYWRpbmdXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoLndoaXRlc3BhY2Uobm9kZSkpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IG5vZGVzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tqXTtcbiAgICAgICAgaWYgKG1hdGNoLmNvbW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmxlYWRpbmdXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaC53aGl0ZXNwYWNlKG5vZGUpKSB7XG4gICAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG59XG4iLCJpbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IG1hdGNoIH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdXRpbC1tYXRjaFwiO1xuXG4vKipcbiAqIFRyaW1zIHdoaXRlc3BhY2UgYW5kIHBhcmJyZWFrcyBmcm9tIHRoZSBzdGFydCBhbmQgZW5kXG4gKiBvZiBhbiBhcnJheS4gVGhlIG51bWJlciBvZiB0cmltbWVkIG5vZGVzIGlzIHJldHVybmVkLlxuICogU3BlY2lhbCBjYXJlIGlzIHRha2VuIHRvIHByZXNlcnZlIGNvbW1lbnRzLCB0aG91Z2ggYW55IHdoaXRlc3BhY2VcbiAqIGJlZm9yZSB0aGUgZmlyc3QgY29tbWVudChzKSBvciBhZnRlciB0aGUgbGFzdCBjb21tZW50KHMpIGlzIHRyaW1tZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltKG5vZGVzOiBBc3QuTm9kZVtdKToge1xuICAgIHRyaW1tZWRTdGFydDogbnVtYmVyO1xuICAgIHRyaW1tZWRFbmQ6IG51bWJlcjtcbn0ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShub2RlcykpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVHJ5aW5nIHRvIHRyaW0gYSBub24tYXJyYXkgYXN0XCIsIG5vZGVzKTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cblxuICAgIGNvbnN0IHsgdHJpbW1lZFN0YXJ0IH0gPSB0cmltU3RhcnQobm9kZXMpO1xuICAgIGNvbnN0IHsgdHJpbW1lZEVuZCB9ID0gdHJpbUVuZChub2Rlcyk7XG5cbiAgICByZXR1cm4geyB0cmltbWVkU3RhcnQsIHRyaW1tZWRFbmQgfTtcbn1cblxuLyoqXG4gKiBUcmltIHdoaXRlc3BhY2UgYW5kIHBhcmJyZWFrcyBmcm9tIHRoZSBsZWZ0IG9mIGFuIGFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbVN0YXJ0KG5vZGVzOiBBc3QuTm9kZVtdKTogeyB0cmltbWVkU3RhcnQ6IG51bWJlciB9IHtcbiAgICBjb25zdCB7IHN0YXJ0IH0gPSBhbW91bnRPZkxlYWRpbmdBbmRUcmFpbGluZ1doaXRlc3BhY2Uobm9kZXMpO1xuXG4gICAgbm9kZXMuc3BsaWNlKDAsIHN0YXJ0KTtcblxuICAgIC8vIElmIHRoZXJlIGFyZSBjb21tZW50cyBhdCB0aGUgc3RhcnQsIHRoZXkgbWlnaHQgaGF2ZSBsZWFkaW5nIHdoaXRlc3BhY2UuXG4gICAgLy8gVGhpcyBsZWFkaW5nIHdoaXRlc3BhY2Ugc2hvdWxkIGJlIHRyaW1tZWRcbiAgICBmb3IgKGNvbnN0IGxlYWRpbmdUb2tlbiBvZiBub2Rlcykge1xuICAgICAgICBpZiAoIW1hdGNoLmNvbW1lbnQobGVhZGluZ1Rva2VuKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlYWRpbmdUb2tlbi5sZWFkaW5nV2hpdGVzcGFjZSB8fCBsZWFkaW5nVG9rZW4uc2FtZWxpbmUpIHtcbiAgICAgICAgICAgIGxlYWRpbmdUb2tlbi5sZWFkaW5nV2hpdGVzcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gV2UgcmVtb3ZlIHRoZSBwb3NpdGlvbiBpbmZvcm1hdGlvbiBmcm9tIHRoaXMgdG9rZW4gdG8gaW5kaWNhdGUgdGhhdCB3ZSd2ZSBlZGl0ZWQgaXRcbiAgICAgICAgICAgIGRlbGV0ZSBsZWFkaW5nVG9rZW4ucG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3BlY2lhbCBjYXJlIG11c3QgYmUgdGFrZW4uIElmIHRoZSBjb21tZW50IHdhcyBvbiB0aGUgc2FtZSBsaW5lIGFzIGFcbiAgICAgICAgLy8gcGFyc2tpcCwgaXQgd2lsbCBubyBsb25nZXIgYmUgb24gdGhlIHNhbWUgbGluZSBhZnRlciB0aGUgdHJpbW1pbmcuXG4gICAgICAgIC8vIFRodXMsIHdlIG11c3QgbW9kaWZ5IHRoZSBjb21tZW50LlxuICAgICAgICBpZiAoc3RhcnQgPiAwICYmIGxlYWRpbmdUb2tlbi5zYW1lbGluZSkge1xuICAgICAgICAgICAgbGVhZGluZ1Rva2VuLnNhbWVsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICBkZWxldGUgbGVhZGluZ1Rva2VuLnBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdHJpbW1lZFN0YXJ0OiBzdGFydCB9O1xufVxuXG4vKipcbiAqIFRyaW0gd2hpdGVzcGFjZSBhbmQgcGFyYnJlYWtzIGZyb20gdGhlIHJpZ2h0IG9mIGFuIGFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbUVuZChub2RlczogQXN0Lk5vZGVbXSk6IHsgdHJpbW1lZEVuZDogbnVtYmVyIH0ge1xuICAgIGNvbnN0IHsgZW5kIH0gPSBhbW91bnRPZkxlYWRpbmdBbmRUcmFpbGluZ1doaXRlc3BhY2Uobm9kZXMpO1xuXG4gICAgbm9kZXMuc3BsaWNlKG5vZGVzLmxlbmd0aCAtIGVuZCwgZW5kKTtcblxuICAgIC8vIFRyaW0gb2ZmIGFueSBzcGFjZXMgYmVsb25naW5nIHRvIHRyYWlsaW5nIGNvbW1lbnRzXG4gICAgZm9yIChsZXQgaSA9IG5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IHRyYWlsaW5nVG9rZW4gPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKCFtYXRjaC5jb21tZW50KHRyYWlsaW5nVG9rZW4pKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBkb24ndCB0cmltIHNwYWNlcyBiZWZvcmUgdHJhaWxpbmcgc2FtZS1saW5lIGNvbW1lbnRzLiBUaGlzIGlzIGEgc3R5bGlzdGljIGNob2ljZVxuICAgICAgICAvLyBzbyB0aGF0XG4gICAgICAgIC8vIGBmb28gJXh4eGAgZG9lcyBub3QgYmVjb21lIGBmb28leHh4YC5cbiAgICAgICAgLy8gVGhlIGxhdHRlciBpcyBzdHJpY3RseSBcImNvcnJlY3RcIiBmb3IgYSB0cmltIGZ1bmN0aW9uLCBidXQgaXQgaXMgcHJldHRpZXIgdG8gZm9ybWF0XG4gICAgICAgIC8vIGNvZGUgcHJlc2VydmluZyB0aGUgc3BhY2UgYmVmb3JlIHRoZSBzYW1lbGluZSBjb21tZW50XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIG1hdGNoLmNvbW1lbnQodHJhaWxpbmdUb2tlbikgJiZcbiAgICAgICAgICAgIHRyYWlsaW5nVG9rZW4ubGVhZGluZ1doaXRlc3BhY2UgJiZcbiAgICAgICAgICAgICF0cmFpbGluZ1Rva2VuLnNhbWVsaW5lXG4gICAgICAgICkge1xuICAgICAgICAgICAgdHJhaWxpbmdUb2tlbi5sZWFkaW5nV2hpdGVzcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgZGVsZXRlIHRyYWlsaW5nVG9rZW4ucG9zaXRpb247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyB0cmltbWVkRW5kOiBlbmQgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygd2hpdGVzcGFjZS9wYXJicmVhayBub2RlcyBhdCB0aGUgc3RhcnQgYW5kIGVuZCBvZiBhbiBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYW1vdW50T2ZMZWFkaW5nQW5kVHJhaWxpbmdXaGl0ZXNwYWNlKGFzdDogQXN0Lk5vZGVbXSk6IHtcbiAgICBzdGFydDogbnVtYmVyO1xuICAgIGVuZDogbnVtYmVyO1xufSB7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgZW5kID0gMDtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgYXN0KSB7XG4gICAgICAgIGlmIChtYXRjaC53aGl0ZXNwYWNlKG5vZGUpIHx8IG1hdGNoLnBhcmJyZWFrKG5vZGUpKSB7XG4gICAgICAgICAgICBzdGFydCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPT09IGFzdC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZDogMCB9O1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIHBhZGRpbmcgb24gdGhlIHJpZ2h0XG4gICAgZm9yIChsZXQgaSA9IGFzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBub2RlID0gYXN0W2ldO1xuICAgICAgICBpZiAobWF0Y2gud2hpdGVzcGFjZShub2RlKSB8fCBtYXRjaC5wYXJicmVhayhub2RlKSkge1xuICAgICAgICAgICAgZW5kKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbn1cbiIsImltcG9ydCB7IFBsdWdpbiB9IGZyb20gXCJ1bmlmaWVkXCI7XG5pbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IG1hdGNoIH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdXRpbC1tYXRjaFwiO1xuaW1wb3J0IHsgdmlzaXQgfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLXZpc2l0XCI7XG5pbXBvcnQgeyB0cmltLCB0cmltRW5kLCB0cmltU3RhcnQgfSBmcm9tIFwiLi90cmltXCI7XG5cbnR5cGUgUGx1Z2luT3B0aW9ucyA9IHZvaWQ7XG5cbi8qKlxuICogVW5pZmllZCBwbHVnaW4gdG8gdHJpbSB0aGUgd2hpdGVzcGFjZSBmcm9tIHRoZSBzdGFydC9lbmQgb2YgYW55IGVudmlyb25tZW50cywgaW5jbHVkaW5nXG4gKiBtYXRoIGVudmlyb25tZW50cy5cbiAqL1xuZXhwb3J0IGNvbnN0IHVuaWZpZWRMYXRleFRyaW1FbnZpcm9ubWVudENvbnRlbnRzOiBQbHVnaW48XG4gICAgUGx1Z2luT3B0aW9uc1tdLFxuICAgIEFzdC5Sb290LFxuICAgIEFzdC5Sb290XG4+ID0gZnVuY3Rpb24gdW5pZmllZExhdGV4VHJpbUVudmlyb25tZW50Q29udGVudHMoKSB7XG4gICAgcmV0dXJuICh0cmVlKSA9PiB7XG4gICAgICAgIHZpc2l0KHRyZWUsIChub2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIShtYXRjaC5tYXRoKG5vZGUpIHx8IG1hdGNoLmFueUVudmlyb25tZW50KG5vZGUpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlIGZpcnN0IHRoaW5nIGluIHRoZSBlbnZpcm9ubWVudCBpcyBhIHNhbWVsaW5lIGNvbW1lbnQsXG4gICAgICAgICAgICAvLyB3ZSBhY3R1YWxseSB3YW50IHRvIHN0YXJ0IHRyaW1taW5nICphZnRlciogaXQuXG4gICAgICAgICAgICBsZXQgZmlyc3ROb2RlID0gbm9kZS5jb250ZW50WzBdO1xuICAgICAgICAgICAgaWYgKG1hdGNoLmNvbW1lbnQoZmlyc3ROb2RlKSAmJiBmaXJzdE5vZGUuc2FtZWxpbmUpIHtcbiAgICAgICAgICAgICAgICBmaXJzdE5vZGUuc3VmZml4UGFyYnJlYWsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0cmltRW5kKG5vZGUuY29udGVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBwbGF5IGEgbmFzdHkgdHJpY2sgaGVyZS4gVGhpcyBjYWxsIHRvIGB0cmltU3RhcnRgXG4gICAgICAgICAgICAgICAgLy8gd2lsbCBhY3R1YWxseSBtb2RpZnkgYG5vZGUuY29udGVudGAgaWYgYG5vZGUuY29udGVudC5zbGljZSgxKWAgc3RhcnRzXG4gICAgICAgICAgICAgICAgLy8gd2l0aCBhIGNvbW1lbnQgdGhhdCBoYXMgbGVhZGluZyB3aGl0ZXNwYWNlIChpdCB3aWxsIHJlbW92ZSB0aGF0IHdoaXRlc3BhY2UpLlxuICAgICAgICAgICAgICAgIC8vIEhvd2V2ZXIsIGl0IHdvbid0IHJlbW92ZSBhbnkgZWxlbWVudHMgZnJvbSBgbm9kZS5jb250ZW50YDsgd2UgbmVlZFxuICAgICAgICAgICAgICAgIC8vIHRvIGRvIHRoYXQgb3Vyc2VsdmVzLlxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJpbW1lZFN0YXJ0IH0gPSB0cmltU3RhcnQobm9kZS5jb250ZW50LnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICBub2RlLmNvbnRlbnQuc3BsaWNlKDEsIHRyaW1tZWRTdGFydCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyaW0obm9kZS5jb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG4iLCJpbXBvcnQgeyBQbHVnaW4gfSBmcm9tIFwidW5pZmllZFwiO1xuaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5pbXBvcnQgeyB0cmltIH0gZnJvbSBcIi4vdHJpbVwiO1xuXG50eXBlIFBsdWdpbk9wdGlvbnMgPSB2b2lkO1xuXG4vKipcbiAqIFVuaWZpZWQgcGx1Z2luIHRvIHRyaW0gdGhlIHdoaXRlc3BhY2UgZnJvbSB0aGUgc3RhcnQvZW5kIG9mIHRoZSByb290IGVsZW1lbnQuXG4gKi9cbmV4cG9ydCBjb25zdCB1bmlmaWVkTGF0ZXhUcmltUm9vdDogUGx1Z2luPFBsdWdpbk9wdGlvbnNbXSwgQXN0LlJvb3QsIEFzdC5Sb290PiA9XG4gICAgZnVuY3Rpb24gdW5pZmllZExhdGV4VHJpbVJvb3QoKSB7XG4gICAgICAgIHJldHVybiAodHJlZSkgPT4ge1xuICAgICAgICAgICAgdHJpbSh0cmVlLmNvbnRlbnQpO1xuICAgICAgICB9O1xuICAgIH07XG4iLCJleHBvcnQgKiBmcm9tIFwiLi9saWJzL3Zpc2l0XCI7XG5cbi8vIE5PVEU6IFRoZSBkb2NzdHJpbmcgY29tbWVudCBtdXN0IGJlIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIGluZGV4LnRzIGZpbGUhXG4vKipcbiAqICMjIFdoYXQgaXMgdGhpcz9cbiAqXG4gKiBGdW5jdGlvbnMgdG8gdHJhdmVyc2UgYSBgdW5pZmllZC1sYXRleGAgQWJzdHJhY3QgU3ludGF4IFRyZWUgKEFTVCkuIGB2aXNpdGAgaXNcbiAqIHZlcnkgc2ltaWxhciB0byBbZXN0cmVlLXV0aWwtdmlzaXRdKGh0dHBzOi8vZ2l0aHViLmNvbS9zeW50YXgtdHJlZS9lc3RyZWUtdXRpbC12aXNpdCkuXG4gKlxuICogIyMgV2hlbiBzaG91bGQgSSB1c2UgdGhpcz9cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byByZWN1cnNpdmVseSByZXBsYWNlIHBhcnRpY3VsYXIgQVNUIG5vZGVzLlxuICovXG4iLCJpbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IG1hdGNoIH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdXRpbC1tYXRjaFwiO1xuXG4vKipcbiAqIExpc3QgYWxsIHByb3BzIG9mIHRoZSBjdXJyZW50IG5vZGUgdGhhdCBzaG91bGQgYmUgcHJvY2Vzc2VkXG4gKiBpbiBtYXRoIG1vZGUgb3Igbm90IGluIG1hdGggbW9kZS4gSWYgbWF0aCBtb2RlIGlzIG5vdCBzcGVjaWZpZWQgaW4gdGhlIG5vZGUncyByZW5kZXJcbiAqIGluZm8sIGVtcHR5IGxpc3RzIGFyZSByZXR1cm5lZC5cbiAqXG4gKiBGb3IgZXhhbXBsZSBgXFx0ZXh0e2Zvb31gIHdpbGwgcmVwb3J0IHRoYXQgYGFyZ3NgIHNob3VsZCAqbm90KiBiZSBwcm9jZXNzZWQgaW4gbWF0aCBtb2RlLFxuICogc2luY2UgaXQncyBjb250ZW50cyBzaG91bGQgYWx3YXlzIGJlIHByb2Nlc3NlZCBpbiB0ZXh0IG1vZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0TWF0aENoaWxkcmVuKG5vZGU6IEFzdC5Bc3QpOiB7XG4gICAgZW50ZXI6IHN0cmluZ1tdO1xuICAgIGxlYXZlOiBzdHJpbmdbXTtcbn0ge1xuICAgIGNvbnN0IE5VTExfUkVUVVJOID0geyBlbnRlcjogW10sIGxlYXZlOiBbXSB9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBOVUxMX1JFVFVSTjtcbiAgICB9XG4gICAgaWYgKG1hdGNoLm1hdGgobm9kZSkpIHtcbiAgICAgICAgLy8gV2hlbiB3ZSBlbnRlciBhIG1hdGggZW52aXJvbm1lbnQsIG91ciBjb250ZW50IGlzIGFsd2F5c1xuICAgICAgICAvLyBjb25zaWRlcmVkIG1hdGggbW9kZVxuICAgICAgICByZXR1cm4geyBlbnRlcjogW1wiY29udGVudFwiXSwgbGVhdmU6IFtdIH07XG4gICAgfVxuXG4gICAgY29uc3QgcmVuZGVySW5mbzogeyBpbk1hdGhNb2RlPzogYm9vbGVhbiB9ID0gbm9kZS5fcmVuZGVySW5mbyB8fCB7fTtcbiAgICBpZiAocmVuZGVySW5mby5pbk1hdGhNb2RlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIE5VTExfUkVUVVJOO1xuICAgIH1cbiAgICBpZiAobWF0Y2gubWFjcm8obm9kZSkpIHtcbiAgICAgICAgaWYgKHJlbmRlckluZm8uaW5NYXRoTW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZW50ZXI6IFtcImFyZ3NcIl0sIGxlYXZlOiBbXSB9O1xuICAgICAgICB9IGVsc2UgaWYgKHJlbmRlckluZm8uaW5NYXRoTW9kZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGVudGVyOiBbXSwgbGVhdmU6IFtcImFyZ3NcIl0gfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobWF0Y2guZW52aXJvbm1lbnQobm9kZSkpIHtcbiAgICAgICAgaWYgKHJlbmRlckluZm8uaW5NYXRoTW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZW50ZXI6IFtcImNvbnRlbnRcIl0sIGxlYXZlOiBbXSB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgZW50ZXI6IFtdLCBsZWF2ZTogW1wiY29udGVudFwiXSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBOVUxMX1JFVFVSTjtcbn1cbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgbGlzdE1hdGhDaGlsZHJlbiB9IGZyb20gXCIuL2xpc3QtbWF0aC1jaGlsZHJlblwiO1xuXG5leHBvcnQgdHlwZSBWaXNpdG9yQ29udGV4dCA9IHtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBub2RlIGlzIGJlaW5nIHByb2Nlc3NlZCBpbiBtYXRoIG1vZGUuXG4gICAgICpcbiAgICAgKiBUaGlzIGhhcHBlbnMgd2hlbiB0aGUgbm9kZSBpcyBhIGRpcmVjdG9yIG9yIGluZGlyZWN0IGNoaWxkXG4gICAgICogb2YgYSBtYXRoIGVudmlyb25tZW50IChlLmcuIGAkYWJjJGApLCBidXQgbm90IHdoZW4gYW4gZW52aXJvbm1lbnRcbiAgICAgKiByZS1lc3RhYmxpc2hlcyB0ZXh0IG1vZGUgKGUuZy4gYCRcXHRleHR7YWJjfSRgKVxuICAgICAqL1xuICAgIGluTWF0aE1vZGU/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIG5vZGUgaGFzIGFueSBhbmNlc3RvciB0aGF0IGlzIHByb2Nlc3NlZCBpbiBtYXRoIG1vZGUuXG4gICAgICovXG4gICAgaGFzTWF0aE1vZGVBbmNlc3Rvcj86IGJvb2xlYW47XG59O1xuXG50eXBlIEdldEd1YXJkPFQ+ID0gVCBleHRlbmRzICh4OiBhbnkpID0+IHggaXMgaW5mZXIgUiA/IFIgOiBuZXZlcjtcbi8qKlxuICogR2V0cyB0aGUgdHlwZSB0aGF0IGEgdHlwZS1ndWFyZCBmdW5jdGlvbiBpcyBndWFyZGluZy4gSWZcbiAqIHRoZSBndWFyZCB0eXBlIGNhbm5vdCBiZSBkZXRlcm1pbmVkLCB0aGUgaW5wdXQgdHlwZSBpcyByZXR1cm5lZC5cbiAqL1xudHlwZSBHdWFyZFR5cGVPZjxUIGV4dGVuZHMgKHg6IGFueSkgPT4gYm9vbGVhbj4gPSBHZXRHdWFyZDxUPiBleHRlbmRzIG5ldmVyXG4gICAgPyBUIGV4dGVuZHMgKHg6IGluZmVyIEEpID0+IGFueVxuICAgICAgICA/IEFcbiAgICAgICAgOiBuZXZlclxuICAgIDogR2V0R3VhcmQ8VD47XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIGd1YXJkIHR5cGUgZnJvbSB0aGUgYHRlc3RgIGZ1bmN0aW9uIHByb3ZpZGVkIGluIGFcbiAqIGBWaXNpdE9wdGlvbnNgIGFyZ3VtZW50LlxuICovXG50eXBlIEd1YXJkRnJvbU9wdGlvbnM8XG4gICAgT3B0cyBleHRlbmRzIFZpc2l0T3B0aW9ucyxcbiAgICBQb3NzaWJsZVR5cGVzID0gQXN0LkFzdFxuPiA9IE9wdHMgZXh0ZW5kcyB7XG4gICAgdGVzdDogaW5mZXIgUjtcbn1cbiAgICA/IFIgZXh0ZW5kcyAoeDogYW55KSA9PiBib29sZWFuXG4gICAgICAgID8gLy8gQSBndWFyZCBsaWtlIGB0eXBlb2YgQXJyYXkuaXNBcnJheWAgd2lsbCByZXR1cm4gYGFueVtdYCBhcyB0aGUgdHlwZS5cbiAgICAgICAgICAvLyBUaGlzIHR5cGUgY2Fubm90IGJlIG5hcnJvd2VkLCBzbyBpbnN0ZWFkIHdlIHVzZSBpdCB0byBwaWNrIGZyb21cbiAgICAgICAgICAvLyB0aGUgc2V0IG9mIGFsbCBwb3NzaWJsZSB0eXBlcy5cbiAgICAgICAgICBFeHRyYWN0PFBvc3NpYmxlVHlwZXMsIEd1YXJkVHlwZU9mPFI+PlxuICAgICAgICA6IFBvc3NpYmxlVHlwZXNcbiAgICA6IFBvc3NpYmxlVHlwZXM7XG5cbi8qKlxuICogTmFycm93IHRoZSB0eXBlIGBUYCBiYXNlZCBvbiB0aGUgYFZpc2l0T3B0aW9uc2Agc3VwcGxpZWQuIElmIGB7aW5jbHVkZUFycmF5czogZmFsc2V9YFxuICogaXMgc3BlY2lmaWVkIGluIHRoZSBgVmlzaXRPcHRpb25zYCwgdGhlbiBhcnJheXMgYXJlIGV4Y2x1ZGVkIGZyb20gYFRgLlxuICovXG50eXBlIE5hcnJvd0FycmF5c0Jhc2VkT25PcHRpb25zPFQsIE9wdHMgZXh0ZW5kcyBWaXNpdE9wdGlvbnM+ID0gT3B0cyBleHRlbmRzIHtcbiAgICBpbmNsdWRlQXJyYXlzOiBpbmZlciBBO1xufVxuICAgID8gQSBleHRlbmRzIHRydWVcbiAgICAgICAgPyBUXG4gICAgICAgIDogRXhjbHVkZTxULCBhbnlbXT5cbiAgICA6IEV4Y2x1ZGU8VCwgYW55W10+O1xuXG4vKipcbiAqIEdldCB0aGUgdHlwZSBvZiB0aGUgcGFyYW1ldGVyIHRvIHRoZSBgVmlzaXRvcmAgZnVuY3Rpb24gYmFzZWQgb24gdGhlXG4gKiBgVmlzaXRPcHRpb25zYCB0aGF0IGFyZSBzdXBwbGllZC5cbiAqL1xudHlwZSBWaXNpdG9yVHlwZUZyb21PcHRpb25zPE9wdHMgZXh0ZW5kcyBWaXNpdE9wdGlvbnM+ID1cbiAgICBOYXJyb3dBcnJheXNCYXNlZE9uT3B0aW9uczxHdWFyZEZyb21PcHRpb25zPE9wdHM+LCBPcHRzPjtcblxuLyoqXG4gKiBDb250aW51ZSB0cmF2ZXJzaW5nIGFzIG5vcm1hbFxuICovXG5leHBvcnQgY29uc3QgQ09OVElOVUUgPSBTeW1ib2woXCJjb250aW51ZVwiKTtcbi8qKlxuICogRG8gbm90IHRyYXZlcnNlIHRoaXMgbm9kZeKAmXMgY2hpbGRyZW5cbiAqL1xuZXhwb3J0IGNvbnN0IFNLSVAgPSBTeW1ib2woXCJza2lwXCIpO1xuLyoqXG4gKiBTdG9wIHRyYXZlcnNpbmcgaW1tZWRpYXRlbHlcbiAqL1xuZXhwb3J0IGNvbnN0IEVYSVQgPSBTeW1ib2woXCJleGl0XCIpO1xuXG50eXBlIEFjdGlvbiA9IHR5cGVvZiBDT05USU5VRSB8IHR5cGVvZiBTS0lQIHwgdHlwZW9mIEVYSVQ7XG50eXBlIEluZGV4ID0gbnVtYmVyO1xudHlwZSBBY3Rpb25UdXBsZSA9IFtBY3Rpb25dIHwgW3R5cGVvZiBTS0lQLCBJbmRleF0gfCBbdHlwZW9mIENPTlRJTlVFLCBJbmRleF07XG5cbi8qKlxuICogQSB2aXNpdG9yIHRha2VzIGEgYG5vZGVgLCBga2V5YCwgYGluZGV4YCwgYW5kIC4uLlxuICpcbiAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9mIHRoZSBwYXJlbnQgdGhhdCB3ZSB3ZXJlIGFjY2Vzc2VkIHRocm91Z2guXG4gKi9cbnR5cGUgVmlzaXRvcjxUPiA9IChcbiAgICBub2RlOiBULFxuICAgIGluZm86IFZpc2l0SW5mb1xuKSA9PiBudWxsIHwgdW5kZWZpbmVkIHwgQWN0aW9uIHwgSW5kZXggfCBBY3Rpb25UdXBsZSB8IHZvaWQ7XG50eXBlIFZpc2l0b3JzPFQ+ID0geyBlbnRlcj86IFZpc2l0b3I8VD47IGxlYXZlPzogVmlzaXRvcjxUPiB9O1xuXG50eXBlIFZpc2l0T3B0aW9ucyA9IHtcbiAgICBzdGFydGluZ0NvbnRleHQ/OiBWaXNpdG9yQ29udGV4dDtcbiAgICAvKipcbiAgICAgKiBUeXBlIGd1YXJkIGZvciB0eXBlcyB0aGF0IGFyZSBwYXNzZWQgdG8gdGhlIGB2aXNpdG9yYCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB0ZXN0PzogKG5vZGU6IEFzdC5Bc3QsIGluZm86IFZpc2l0SW5mbykgPT4gYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGFycmF5cyB3aWxsIGJlIHNlbnQgdG8gdGhlIGB2aXNpdG9yYCBmdW5jdGlvbi4gSWYgZmFsc3ksXG4gICAgICogb25seSBub2RlcyB3aWxsIGJlIHBhc3QgdG8gYHZpc2l0b3JgLlxuICAgICAqL1xuICAgIGluY2x1ZGVBcnJheXM/OiBib29sZWFuO1xufTtcblxuY29uc3QgREVGQVVMVF9DT05URVhUOiBWaXNpdG9yQ29udGV4dCA9IHtcbiAgICBpbk1hdGhNb2RlOiBmYWxzZSxcbiAgICBoYXNNYXRoTW9kZUFuY2VzdG9yOiBmYWxzZSxcbn07XG5cbmV4cG9ydCB0eXBlIFZpc2l0SW5mbyA9IHtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZWxlbWVudCB3YXMgYWNjZXNzZWQgdmlhIGFuIGF0dHJpYnV0ZSwgdGhlIGF0dHJpYnV0ZSBrZXkgaXMgc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGtleTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBlbGVtZW50IHdhcyBhY2Nlc3NlZCBpbiBhbiBhcnJheSwgdGhlIGluZGV4IGlzIHNwZWNpZmllZC5cbiAgICAgKi9cbiAgICByZWFkb25seSBpbmRleDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiBhbmNlc3RvciBub2RlcywgYFtwYXJlbnQsIGdyYW5kcGFyZW50LCBncmVhdC1ncmFuZHBhcmVudCwgLi4uXWBcbiAgICAgKi9cbiAgICByZWFkb25seSBwYXJlbnRzOiAoQXN0Lk5vZGUgfCBBc3QuQXJndW1lbnQpW107XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGVsZW1lbnQgd2FzIGFjY2Vzc2VkIGluIGFuIGFycmF5LCB0aGUgYXJyYXkgdGhhdCBpdCBpcyBwYXJ0IG9mLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGNvbnRhaW5pbmdBcnJheTogKEFzdC5Ob2RlIHwgQXN0LkFyZ3VtZW50KVtdIHwgdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIFRoZSBMYVRlWCBjb250ZXh0IG9mIHRoZSBjdXJyZW50IG1hdGNoLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGNvbnRleHQ6IFZpc2l0b3JDb250ZXh0O1xufTtcblxuLyoqXG4gKiBWaXNpdCBjaGlsZHJlbiBvZiB0cmVlIHdoaWNoIHBhc3MgYSB0ZXN0XG4gKlxuICogQHBhcmFtIHtOb2RlfSB0cmVlIEFic3RyYWN0IHN5bnRheCB0cmVlIHRvIHdhbGtcbiAqIEBwYXJhbSB7VmlzaXRvcnxWaXNpdG9yc30gW3Zpc2l0b3JdIEZ1bmN0aW9uIHRvIHJ1biBmb3IgZWFjaCBub2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2aXNpdDxPcHRzIGV4dGVuZHMgVmlzaXRPcHRpb25zPihcbiAgICB0cmVlOiBBc3QuQXN0LFxuICAgIHZpc2l0b3I6XG4gICAgICAgIHwgVmlzaXRvcjxWaXNpdG9yVHlwZUZyb21PcHRpb25zPE9wdHM+PlxuICAgICAgICB8IFZpc2l0b3JzPFZpc2l0b3JUeXBlRnJvbU9wdGlvbnM8T3B0cz4+LFxuICAgIG9wdGlvbnM/OiBPcHRzXG4pIHtcbiAgICBjb25zdCB7XG4gICAgICAgIHN0YXJ0aW5nQ29udGV4dCA9IERFRkFVTFRfQ09OVEVYVCxcbiAgICAgICAgdGVzdCA9ICgpID0+IHRydWUsXG4gICAgICAgIGluY2x1ZGVBcnJheXMgPSBmYWxzZSxcbiAgICB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgZW50ZXI6IFZpc2l0b3I8VmlzaXRvclR5cGVGcm9tT3B0aW9uczxPcHRzPj4gfCB1bmRlZmluZWQ7XG4gICAgbGV0IGxlYXZlOiBWaXNpdG9yPFZpc2l0b3JUeXBlRnJvbU9wdGlvbnM8T3B0cz4+IHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKHR5cGVvZiB2aXNpdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZW50ZXIgPSB2aXNpdG9yO1xuICAgIH0gZWxzZSBpZiAodmlzaXRvciAmJiB0eXBlb2YgdmlzaXRvciA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBlbnRlciA9IHZpc2l0b3IuZW50ZXI7XG4gICAgICAgIGxlYXZlID0gdmlzaXRvci5sZWF2ZTtcbiAgICB9XG5cbiAgICB3YWxrKHRyZWUsIHtcbiAgICAgICAga2V5OiB1bmRlZmluZWQsXG4gICAgICAgIGluZGV4OiB1bmRlZmluZWQsXG4gICAgICAgIHBhcmVudHM6IFtdLFxuICAgICAgICBjb250YWluaW5nQXJyYXk6IHVuZGVmaW5lZCxcbiAgICAgICAgY29udGV4dDogeyAuLi5zdGFydGluZ0NvbnRleHQgfSxcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nP30ga2V5XG4gICAgICogQHBhcmFtIHtudW1iZXI/fSBpbmRleFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE5vZGU+fSBwYXJlbnRzXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2FsayhcbiAgICAgICAgbm9kZTogQXN0LkFzdCxcbiAgICAgICAgeyBrZXksIGluZGV4LCBwYXJlbnRzLCBjb250ZXh0LCBjb250YWluaW5nQXJyYXkgfTogVmlzaXRJbmZvXG4gICAgKTogQWN0aW9uVHVwbGUge1xuICAgICAgICBjb25zdCBub2RlUGFzc2VzVGVzdCA9IGluY2x1ZGVBcnJheXNcbiAgICAgICAgICAgID8gdGVzdChub2RlLCB7IGtleSwgaW5kZXgsIHBhcmVudHMsIGNvbnRleHQsIGNvbnRhaW5pbmdBcnJheSB9KVxuICAgICAgICAgICAgOiAhQXJyYXkuaXNBcnJheShub2RlKSAmJlxuICAgICAgICAgICAgICB0ZXN0KG5vZGUsIHsga2V5LCBpbmRleCwgcGFyZW50cywgY29udGV4dCwgY29udGFpbmluZ0FycmF5IH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdDogQWN0aW9uVHVwbGUgPVxuICAgICAgICAgICAgZW50ZXIgJiYgbm9kZVBhc3Nlc1Rlc3RcbiAgICAgICAgICAgICAgICA/IHRvUmVzdWx0KFxuICAgICAgICAgICAgICAgICAgICAgIGVudGVyKG5vZGUgYXMgYW55LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5pbmdBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogW0NPTlRJTlVFXTtcblxuICAgICAgICBpZiAocmVzdWx0WzBdID09PSBFWElUKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdFswXSA9PT0gU0tJUCkge1xuICAgICAgICAgICAgcmV0dXJuIGxlYXZlICYmIG5vZGVQYXNzZXNUZXN0XG4gICAgICAgICAgICAgICAgPyB0b1Jlc3VsdChcbiAgICAgICAgICAgICAgICAgICAgICBsZWF2ZShub2RlIGFzIGFueSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluaW5nQXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICA6IHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBUaGUgYHZhbHVlYCBhcnJheSBtaWdodCBiZSBtb2RpZmllZCBpbiBwbGFjZSBhcyB3ZSB0cmF2ZXJzZSBpdCwgc29cbiAgICAgICAgICAgIC8vIHdlIHVzZSBhIHRyYWRpdGlvbmFsIGZvciBsb29wLlxuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA+IC0xICYmIGluZGV4IDwgbm9kZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gbm9kZVtpbmRleF07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gd2FsayhpdGVtLCB7XG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudHMsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5pbmdBcnJheTogbm9kZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0WzBdID09PSBFWElUKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0WzFdID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmb3IgbG9vcCB3aWxsIGluY3JlbWVudCBpIGV2ZXJ5IHBhc3MuIEhvd2V2ZXIsXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGFuIGluZGV4IHdhcyByZXR1cm5lZCwgdGhhdCdzIHdoZXJlIHdlIHdhbnQgdG8gc3RhcnQgbmV4dCB0aW1lLlxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHJlc3VsdFsxXSAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byByZWN1cnNpdmVseSBhcHBseSB0byB0aGUgYGNvbnRlbnRgXG4gICAgICAgICAgICAvLyBvZiBhbGwgdHlwZXMgKGUuZy4sIGNvbW1lbnRzIGFuZCBtYWNyb3MpLCBzbyBzcGVjaWZ5XG4gICAgICAgICAgICAvLyBhIGJsYWNrbGlzdC5cbiAgICAgICAgICAgIGxldCBjaGlsZFByb3BzOiAoXCJjb250ZW50XCIgfCBcImFyZ3NcIilbXSA9IFtcImNvbnRlbnRcIiwgXCJhcmdzXCJdO1xuICAgICAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwibWFjcm9cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRQcm9wcyA9IFtcImFyZ3NcIl07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb21tZW50XCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ2ZXJiXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInZlcmJhdGltXCI6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkUHJvcHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG1hdGhNb2RlUHJvcHMgPSBsaXN0TWF0aENoaWxkcmVuKG5vZGUpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgY2hpbGRQcm9wcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbm9kZVtrZXkgYXMga2V5b2YgdHlwZW9mIG5vZGVdIGFzXG4gICAgICAgICAgICAgICAgICAgIHwgQXN0LkFzdFxuICAgICAgICAgICAgICAgICAgICB8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBjb25zdCBncmFuZHBhcmVudHMgPSBbbm9kZV0uY29uY2F0KHBhcmVudHMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV2UgbWF5IHN3aXRjaCBpbi9vdXQgb2YgbWF0aCBtb2RlIGFzIHdlIHBhc3MgdG8gbm9kZVtrZXldXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Q29udGV4dCA9IHsgLi4uY29udGV4dCB9O1xuICAgICAgICAgICAgICAgIGlmIChtYXRoTW9kZVByb3BzLmVudGVyLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udGV4dC5pbk1hdGhNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udGV4dC5oYXNNYXRoTW9kZUFuY2VzdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGhNb2RlUHJvcHMubGVhdmUuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0LmluTWF0aE1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB3YWxrKHZhbHVlLCB7XG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50czogZ3JhbmRwYXJlbnRzLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBuZXdDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBjb250YWluaW5nQXJyYXk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0WzBdID09PSBFWElUKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxlYXZlICYmIG5vZGVQYXNzZXNUZXN0XG4gICAgICAgICAgICA/IHRvUmVzdWx0KFxuICAgICAgICAgICAgICAgICAgbGVhdmUobm9kZSBhcyBhbnksIHtcbiAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgcGFyZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5pbmdBcnJheSxcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogcmVzdWx0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBFbnN1cmVzIGEgcmVzdWx0IGlzIGFuIGBBY3Rpb25UdXBsZWBzXG4gKi9cbmZ1bmN0aW9uIHRvUmVzdWx0KFxuICAgIHZhbHVlOiBudWxsIHwgdW5kZWZpbmVkIHwgdm9pZCB8IEFjdGlvbiB8IEluZGV4IHwgQWN0aW9uVHVwbGVcbik6IEFjdGlvblR1cGxlIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gW0NPTlRJTlVFXTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIFtDT05USU5VRSwgdmFsdWVdO1xuICAgIH1cblxuICAgIHJldHVybiBbdmFsdWVdO1xufVxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJleHBvcnQgKiBmcm9tIFwiLi9saWJzL3JlcGxhY2Utbm9kZVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vbGlicy91bmlmaWVkLWxhdGV4LXN0cmVhbWluZy1jb21tYW5kXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9saWJzL3JlcGxhY2Utc3RyZWFtaW5nLWNvbW1hbmRcIjtcblxuLy8gTk9URTogVGhlIGRvY3N0cmluZyBjb21tZW50IG11c3QgYmUgdGhlIGxhc3QgaXRlbSBpbiB0aGUgaW5kZXgudHMgZmlsZSFcbi8qKlxuICogIyMgV2hhdCBpcyB0aGlzP1xuICpcbiAqIEZ1bmN0aW9ucyB0byBoZWxwIG1vZGlmeSBhIGB1bmlmaWVkLWxhdGV4YCBBYnN0cmFjdCBTeW50YXggVHJlZSAoQVNUKS5cbiAqXG4gKiAjIyBXaGVuIHNob3VsZCBJIHVzZSB0aGlzP1xuICpcbiAqIElmIHlvdSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJlcGxhY2UgcGFydGljdWxhciBBU1Qgbm9kZXMuXG4gKi9cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==