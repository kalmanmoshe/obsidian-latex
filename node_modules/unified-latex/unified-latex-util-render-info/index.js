/******/ var __webpack_modules__ = ({

/***/ "./unified-latex-util-match/index.ts":
/*!*******************************************!*\
  !*** ./unified-latex-util-match/index.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "anyEnvironment": () => (/* binding */ anyEnvironment),
/* harmony export */   "anyMacro": () => (/* binding */ anyMacro),
/* harmony export */   "anyString": () => (/* binding */ anyString),
/* harmony export */   "argument": () => (/* binding */ argument),
/* harmony export */   "blankArgument": () => (/* binding */ blankArgument),
/* harmony export */   "comment": () => (/* binding */ comment),
/* harmony export */   "environment": () => (/* binding */ environment),
/* harmony export */   "group": () => (/* binding */ group),
/* harmony export */   "macro": () => (/* binding */ macro),
/* harmony export */   "match": () => (/* reexport safe */ _libs_match__WEBPACK_IMPORTED_MODULE_0__.match),
/* harmony export */   "math": () => (/* binding */ math),
/* harmony export */   "parbreak": () => (/* binding */ parbreak),
/* harmony export */   "string": () => (/* binding */ string),
/* harmony export */   "whitespace": () => (/* binding */ whitespace)
/* harmony export */ });
/* harmony import */ var _libs_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/match */ "./unified-latex-util-match/libs/match.ts");


const { anyEnvironment, anyMacro, anyString, argument, blankArgument, comment, environment, group, macro, math, parbreak, string, whitespace, } = _libs_match__WEBPACK_IMPORTED_MODULE_0__.match;
// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to match different `Ast.Node` types in a `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you need a type-guard to ensure a node is of a certain type; for example, during a call to `unified-latex-until-visit`.
 */


/***/ }),

/***/ "./unified-latex-util-match/libs/match.ts":
/*!************************************************!*\
  !*** ./unified-latex-util-match/libs/match.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "match": () => (/* binding */ match)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-print-raw */ "./unified-latex-util-print-raw/index.ts");

/**
 * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros
 * and generates a hash for quick lookup.
 */
function createMacroMatcher(macros) {
    // We first make sure we have a record type with keys being the macro's contents
    const macrosHash = Array.isArray(macros)
        ? macros.length > 0
            ? typeof macros[0] === "string"
                ? Object.fromEntries(macros.map((macro) => {
                    if (typeof macro !== "string") {
                        throw new Error("Wrong branch of map function");
                    }
                    return [macro, {}];
                }))
                : Object.fromEntries(macros.map((macro) => {
                    if (typeof macro === "string") {
                        throw new Error("Wrong branch of map function");
                    }
                    if (macro.escapeToken != null) {
                        return [
                            macro.content,
                            { escapeToken: macro.escapeToken },
                        ];
                    }
                    return [macro.content, {}];
                }))
            : {}
        : macros;
    return function matchAgainstMacros(node) {
        if (node == null || node.type !== "macro") {
            return false;
        }
        // At this point we have a macro type
        const spec = macrosHash[node.content];
        if (!spec) {
            return false;
        }
        if (typeof spec === "object" && "escapeToken" in spec) {
            return (spec.escapeToken == null ||
                spec.escapeToken === node.escapeToken);
        }
        return true;
    };
}
/**
 * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros
 * and generates a hash for quick lookup.
 */
function createEnvironmentMatcher(macros) {
    // We first make sure we have a record type with keys being the macro's contents
    const environmentsHash = Array.isArray(macros)
        ? Object.fromEntries(macros.map((str) => {
            return [str, {}];
        }))
        : macros;
    return function matchAgainstEnvironments(node) {
        if (!match.anyEnvironment(node)) {
            return false;
        }
        // At this point we have an environment type
        const envName = (0,_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)(node.env);
        const spec = environmentsHash[envName];
        if (!spec) {
            return false;
        }
        return true;
    };
}
/**
 * Functions to match different types of nodes.
 */
const match = {
    macro(node, macroName) {
        if (node == null) {
            return false;
        }
        return (node.type === "macro" &&
            (macroName == null || node.content === macroName));
    },
    anyMacro(node) {
        return match.macro(node);
    },
    environment(node, envName) {
        if (node == null) {
            return false;
        }
        return ((node.type === "environment" || node.type === "mathenv") &&
            (envName == null || (0,_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)(node.env) === envName));
    },
    anyEnvironment(node) {
        return match.environment(node);
    },
    comment(node) {
        if (node == null) {
            return false;
        }
        return node.type === "comment";
    },
    parbreak(node) {
        if (node == null) {
            return false;
        }
        return node.type === "parbreak";
    },
    whitespace(node) {
        if (node == null) {
            return false;
        }
        return node.type === "whitespace";
    },
    /**
     * Matches whitespace or a comment with leading whitespace.
     */
    whitespaceLike(node) {
        if (node == null) {
            return false;
        }
        return (node.type === "whitespace" ||
            (node.type === "whitespace" && node.leadingWhitespace === true));
    },
    string(node, value) {
        if (node == null) {
            return false;
        }
        return (node.type === "string" && (value == null || node.content === value));
    },
    anyString(node) {
        return match.string(node);
    },
    group(node) {
        if (node == null) {
            return false;
        }
        return node.type === "group";
    },
    argument(node) {
        if (node == null) {
            return false;
        }
        return node.type === "argument";
    },
    blankArgument(node) {
        if (!match.argument(node)) {
            return false;
        }
        return (node.openMark === "" &&
            node.closeMark === "" &&
            node.content.length === 0);
    },
    math(node) {
        if (node == null) {
            return false;
        }
        return node.type === "displaymath" || node.type === "inlinemath";
    },
    createMacroMatcher,
    createEnvironmentMatcher,
};


/***/ }),

/***/ "./unified-latex-util-print-raw/index.ts":
/*!***********************************************!*\
  !*** ./unified-latex-util-print-raw/index.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linebreak": () => (/* reexport safe */ _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__.linebreak),
/* harmony export */   "printRaw": () => (/* reexport safe */ _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)
/* harmony export */ });
/* harmony import */ var _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/print-raw */ "./unified-latex-util-print-raw/libs/print-raw.ts");

// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to print a `unified-latex` Abstract Syntax Tree (AST) to a string.
 *
 * ## When should I use this?
 *
 * If you want to directly print an `Ast.Ast` to a string without any pretty printing or formatting.
 */


/***/ }),

/***/ "./unified-latex-util-print-raw/libs/print-raw.ts":
/*!********************************************************!*\
  !*** ./unified-latex-util-print-raw/libs/print-raw.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linebreak": () => (/* binding */ linebreak),
/* harmony export */   "printRaw": () => (/* binding */ printRaw)
/* harmony export */ });
const linebreak = Symbol("linebreak");
const ESCAPE = "\\";
/**
 * Renders the AST to an array inserting `linebreak` where needed;
 * This array may be nested.
 *
 * @param {*} node
 */
function _printRaw(node) {
    if (typeof node === "string") {
        return [node];
    }
    if (Array.isArray(node)) {
        return [].concat(...node.map((n) => _printRaw(n)));
    }
    // tmp variables
    let argsString, escape;
    switch (node.type) {
        case "root":
            return _printRaw(node.content);
        case "argument":
            return [node.openMark, ..._printRaw(node.content), node.closeMark];
        case "comment":
            var suffix = node.suffixParbreak ? "" : linebreak;
            // A comment is responsible for printing its own leading whitespace
            var leadingWhitespace = "";
            if (node.sameline && node.leadingWhitespace) {
                leadingWhitespace = " ";
            }
            if (node.sameline) {
                return [
                    leadingWhitespace,
                    "%",
                    ..._printRaw(node.content),
                    suffix,
                ];
            }
            return [linebreak, "%", ..._printRaw(node.content), suffix];
        case "environment":
        case "mathenv":
        case "verbatim":
            var env = _printRaw(node.env);
            var envStart = [ESCAPE + "begin{", ...env, "}"];
            var envEnd = [ESCAPE + "end{", ...env, "}"];
            argsString =
                node.args == null ? [] : _printRaw(node.args);
            return [
                ...envStart,
                ...argsString,
                ..._printRaw(node.content),
                ...envEnd,
            ];
        case "displaymath":
            return [ESCAPE + "[", ..._printRaw(node.content), ESCAPE + "]"];
        case "group":
            return ["{", ..._printRaw(node.content), "}"];
        case "inlinemath":
            return ["$", ..._printRaw(node.content), "$"];
        case "macro":
            argsString = node.args == null ? [] : _printRaw(node.args);
            escape = node.escapeToken == null ? ESCAPE : node.escapeToken;
            return [escape, ..._printRaw(node.content), ...argsString];
        case "parbreak":
            return [linebreak, linebreak];
        case "string":
            return [node.content];
        case "verb":
            return [
                ESCAPE,
                node.env,
                node.escape,
                ..._printRaw(node.content),
                node.escape,
            ];
        case "whitespace":
            return [" "];
        default:
            console.warn("Cannot find render for node ", node, `(of type ${typeof node})`);
            return ["" + node];
    }
}
function printRaw(node, options) {
    const asArray = options != null ? options.asArray : false;
    const printedTokens = _printRaw(node);
    if (asArray) {
        return printedTokens;
    }
    return printedTokens.map((x) => (x === linebreak ? "\n" : x)).join("");
}


/***/ }),

/***/ "./unified-latex-util-visit/index.ts":
/*!*******************************************!*\
  !*** ./unified-latex-util-visit/index.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CONTINUE": () => (/* reexport safe */ _libs_visit__WEBPACK_IMPORTED_MODULE_0__.CONTINUE),
/* harmony export */   "EXIT": () => (/* reexport safe */ _libs_visit__WEBPACK_IMPORTED_MODULE_0__.EXIT),
/* harmony export */   "SKIP": () => (/* reexport safe */ _libs_visit__WEBPACK_IMPORTED_MODULE_0__.SKIP),
/* harmony export */   "visit": () => (/* reexport safe */ _libs_visit__WEBPACK_IMPORTED_MODULE_0__.visit)
/* harmony export */ });
/* harmony import */ var _libs_visit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/visit */ "./unified-latex-util-visit/libs/visit.ts");

// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to traverse a `unified-latex` Abstract Syntax Tree (AST). `visit` is
 * very similar to [estree-util-visit](https://github.com/syntax-tree/estree-util-visit).
 *
 * ## When should I use this?
 *
 * If you want to recursively replace particular AST nodes.
 */


/***/ }),

/***/ "./unified-latex-util-visit/libs/list-math-children.ts":
/*!*************************************************************!*\
  !*** ./unified-latex-util-visit/libs/list-math-children.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "listMathChildren": () => (/* binding */ listMathChildren)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");

/**
 * List all props of the current node that should be processed
 * in math mode or not in math mode. If math mode is not specified in the node's render
 * info, empty lists are returned.
 *
 * For example `\text{foo}` will report that `args` should *not* be processed in math mode,
 * since it's contents should always be processed in text mode.
 */
function listMathChildren(node) {
    const NULL_RETURN = { enter: [], leave: [] };
    if (Array.isArray(node)) {
        return NULL_RETURN;
    }
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.math(node)) {
        // When we enter a math environment, our content is always
        // considered math mode
        return { enter: ["content"], leave: [] };
    }
    const renderInfo = node._renderInfo || {};
    if (renderInfo.inMathMode == null) {
        return NULL_RETURN;
    }
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.macro(node)) {
        if (renderInfo.inMathMode === true) {
            return { enter: ["args"], leave: [] };
        }
        else if (renderInfo.inMathMode === false) {
            return { enter: [], leave: ["args"] };
        }
    }
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.environment(node)) {
        if (renderInfo.inMathMode === true) {
            return { enter: ["content"], leave: [] };
        }
        else {
            return { enter: [], leave: ["content"] };
        }
    }
    return NULL_RETURN;
}


/***/ }),

/***/ "./unified-latex-util-visit/libs/visit.ts":
/*!************************************************!*\
  !*** ./unified-latex-util-visit/libs/visit.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CONTINUE": () => (/* binding */ CONTINUE),
/* harmony export */   "EXIT": () => (/* binding */ EXIT),
/* harmony export */   "SKIP": () => (/* binding */ SKIP),
/* harmony export */   "visit": () => (/* binding */ visit)
/* harmony export */ });
/* harmony import */ var _list_math_children__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./list-math-children */ "./unified-latex-util-visit/libs/list-math-children.ts");

/**
 * Continue traversing as normal
 */
const CONTINUE = Symbol("continue");
/**
 * Do not traverse this nodeâ€™s children
 */
const SKIP = Symbol("skip");
/**
 * Stop traversing immediately
 */
const EXIT = Symbol("exit");
const DEFAULT_CONTEXT = {
    inMathMode: false,
    hasMathModeAncestor: false,
};
/**
 * Visit children of tree which pass a test
 *
 * @param {Node} tree Abstract syntax tree to walk
 * @param {Visitor|Visitors} [visitor] Function to run for each node
 */
function visit(tree, visitor, options) {
    const { startingContext = DEFAULT_CONTEXT, test = () => true, includeArrays = false, } = options || {};
    let enter;
    let leave;
    if (typeof visitor === "function") {
        enter = visitor;
    }
    else if (visitor && typeof visitor === "object") {
        enter = visitor.enter;
        leave = visitor.leave;
    }
    walk(tree, {
        key: undefined,
        index: undefined,
        parents: [],
        containingArray: undefined,
        context: Object.assign({}, startingContext),
    });
    /**
     * @param {Node} node
     * @param {string?} key
     * @param {number?} index
     * @param {Array.<Node>} parents
     */
    function walk(node, { key, index, parents, context, containingArray }) {
        const nodePassesTest = includeArrays
            ? test(node, { key, index, parents, context, containingArray })
            : !Array.isArray(node) &&
                test(node, { key, index, parents, context, containingArray });
        const result = enter && nodePassesTest
            ? toResult(enter(node, {
                key,
                index,
                parents,
                context,
                containingArray,
            }))
            : [CONTINUE];
        if (result[0] === EXIT) {
            return result;
        }
        if (result[0] === SKIP) {
            return leave && nodePassesTest
                ? toResult(leave(node, {
                    key,
                    index,
                    parents,
                    context,
                    containingArray,
                }))
                : result;
        }
        if (Array.isArray(node)) {
            // The `value` array might be modified in place as we traverse it, so
            // we use a traditional for loop.
            for (let index = 0; index > -1 && index < node.length; index++) {
                const item = node[index];
                const result = walk(item, {
                    key,
                    index,
                    parents,
                    context,
                    containingArray: node,
                });
                if (result[0] === EXIT) {
                    return result;
                }
                if (typeof result[1] === "number") {
                    // The for loop will increment i every pass. However,
                    // if an index was returned, that's where we want to start next time.
                    index = result[1] - 1;
                }
            }
        }
        else {
            // We don't want to recursively apply to the `content`
            // of all types (e.g., comments and macros), so specify
            // a blacklist.
            let childProps = ["content", "args"];
            switch (node.type) {
                case "macro":
                    childProps = ["args"];
                    break;
                case "comment":
                case "string":
                case "verb":
                case "verbatim":
                    childProps = [];
                    break;
                default:
                    break;
            }
            const mathModeProps = (0,_list_math_children__WEBPACK_IMPORTED_MODULE_0__.listMathChildren)(node);
            for (const key of childProps) {
                const value = node[key];
                const grandparents = [node].concat(parents);
                if (value == null) {
                    continue;
                }
                // We may switch in/out of math mode as we pass to node[key]
                const newContext = Object.assign({}, context);
                if (mathModeProps.enter.includes(key)) {
                    newContext.inMathMode = true;
                    newContext.hasMathModeAncestor = true;
                }
                else if (mathModeProps.leave.includes(key)) {
                    newContext.inMathMode = false;
                }
                const result = walk(value, {
                    key,
                    index: undefined,
                    parents: grandparents,
                    context: newContext,
                    containingArray: undefined,
                });
                if (result[0] === EXIT) {
                    return result;
                }
            }
        }
        return leave && nodePassesTest
            ? toResult(leave(node, {
                key,
                index,
                parents,
                context,
                containingArray,
            }))
            : result;
    }
}
/**
 * Ensures a result is an `ActionTuple`s
 */
function toResult(value) {
    if (value == null) {
        return [CONTINUE];
    }
    if (Array.isArray(value)) {
        return value;
    }
    if (typeof value === "number") {
        return [CONTINUE, value];
    }
    return [value];
}


/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!*************************************************!*\
  !*** ./unified-latex-util-render-info/index.ts ***!
  \*************************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "trimRenderInfo": () => (/* binding */ trimRenderInfo),
/* harmony export */   "updateRenderInfo": () => (/* binding */ updateRenderInfo)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../unified-latex-util-visit */ "./unified-latex-util-visit/index.ts");

/**
 * Updates the `._renderInfo` property on a node to include
 * whatever has been supplied to `renderInfo`. If `renderInfo`
 * is null, no update is performed.
 *
 * *This operation mutates `node`*
 */
function updateRenderInfo(node, renderInfo) {
    if (renderInfo != null) {
        node._renderInfo = Object.assign(Object.assign({}, (node._renderInfo || {})), renderInfo);
    }
    return node;
}
/**
 * Removes any `_renderInfo` and `position` tags present in the AST. This
 * operation is _destructive_.
 */
function trimRenderInfo(ast) {
    (0,_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_0__.visit)(ast, (node) => {
        delete node._renderInfo;
        delete node.position;
    });
    return ast;
}
// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to help modify the `_renderInfo` of a `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you want to compare the structure of an AST without position information or extra information
 * that is kept for pretty-printing, these functions can be used to remove/modify the `_renderInfo`
 * of an `Ast.Node`.
 */

})();

var __webpack_exports__trimRenderInfo = __webpack_exports__.trimRenderInfo;
var __webpack_exports__updateRenderInfo = __webpack_exports__.updateRenderInfo;
export { __webpack_exports__trimRenderInfo as trimRenderInfo, __webpack_exports__updateRenderInfo as updateRenderInfo };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW5pZmllZC1sYXRleC11dGlsLXJlbmRlci1pbmZvL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFDO0FBRXBCO0FBRVYsTUFBTSxFQUNULGNBQWMsRUFDZCxRQUFRLEVBQ1IsU0FBUyxFQUNULFFBQVEsRUFDUixhQUFhLEVBQ2IsT0FBTyxFQUNQLFdBQVcsRUFDWCxLQUFLLEVBQ0wsS0FBSyxFQUNMLElBQUksRUFDSixRQUFRLEVBQ1IsTUFBTSxFQUNOLFVBQVUsR0FDYixHQUFHLDhDQUFLLENBQUM7QUFFViwwRUFBMEU7QUFDMUU7Ozs7Ozs7O0dBUUc7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzQjJEO0FBRTlEOzs7R0FHRztBQUNILFNBQVMsa0JBQWtCLENBQ3ZCLE1BQXdEO0lBRXhELGdGQUFnRjtJQUNoRixNQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQztRQUNwQyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDO1lBQ2YsQ0FBQyxDQUFDLE9BQU8sTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLFFBQVE7Z0JBQzNCLENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUNkLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRTtvQkFDakIsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7d0JBQzNCLE1BQU0sSUFBSSxLQUFLLENBQUMsOEJBQThCLENBQUMsQ0FBQztxQkFDbkQ7b0JBQ0QsT0FBTyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQXdCLENBQUM7Z0JBQzlDLENBQUMsQ0FBQyxDQUNMO2dCQUNILENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUNkLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRTtvQkFDakIsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7d0JBQzNCLE1BQU0sSUFBSSxLQUFLLENBQUMsOEJBQThCLENB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VUFDQTs7Ozs7VUNQQTs7Ozs7VUNBQTtVQUNBO1VBQ0E7VUFDQSx1REFBdUQsaUJBQWlCO1VBQ3hFO1VBQ0EsZ0RBQWdELGFBQWE7VUFDN0Q7Ozs7Ozs7Ozs7Ozs7Ozs7QUNMb0Q7QUFFcEQ7Ozs7OztHQU1HO0FBQ0ksU0FBUyxnQkFBZ0IsQ0FDNUIsSUFBYyxFQUNkLFVBQXFDO0lBRXJDLElBQUksVUFBVSxJQUFJLElBQUksRUFBRTtRQUNwQixJQUFJLENBQUMsV0FBVyxtQ0FBUSxDQUFDLElBQUksQ0FBQyxXQUFXLElBQUksRUFBRSxDQUFDLEdBQUssVUFBVSxDQUFFLENBQUM7S0FDckU7SUFDRCxPQUFPLElBQUksQ0FBQztBQUNoQixDQUFDO0FBRUQ7OztHQUdHO0FBQ0ksU0FBUyxjQUFjLENBQUMsR0FBWTtJQUN2QyxnRUFBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksRUFBRSxFQUFFO1FBQ2hCLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQztRQUN4QixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDekIsQ0FBQyxDQUFDLENBQUM7SUFDSCxPQUFPLEdBQUcsQ0FBQztBQUNmLENBQUM7QUFFRCwwRUFBMEU7QUFDMUU7Ozs7Ozs7Ozs7R0FVRyIsInNvdXJjZXMiOlsid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtbWF0Y2gvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC1tYXRjaC9saWJzL21hdGNoLnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtcHJpbnQtcmF3L2luZGV4LnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtcHJpbnQtcmF3L2xpYnMvcHJpbnQtcmF3LnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtdmlzaXQvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC12aXNpdC9saWJzL2xpc3QtbWF0aC1jaGlsZHJlbi50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXZpc2l0L2xpYnMvdmlzaXQudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4L3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4L3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtcmVuZGVyLWluZm8vaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi9saWJzL21hdGNoXCI7XG5cbmV4cG9ydCB7IG1hdGNoIH07XG5cbmV4cG9ydCBjb25zdCB7XG4gICAgYW55RW52aXJvbm1lbnQsXG4gICAgYW55TWFjcm8sXG4gICAgYW55U3RyaW5nLFxuICAgIGFyZ3VtZW50LFxuICAgIGJsYW5rQXJndW1lbnQsXG4gICAgY29tbWVudCxcbiAgICBlbnZpcm9ubWVudCxcbiAgICBncm91cCxcbiAgICBtYWNybyxcbiAgICBtYXRoLFxuICAgIHBhcmJyZWFrLFxuICAgIHN0cmluZyxcbiAgICB3aGl0ZXNwYWNlLFxufSA9IG1hdGNoO1xuXG4vLyBOT1RFOiBUaGUgZG9jc3RyaW5nIGNvbW1lbnQgbXVzdCBiZSB0aGUgbGFzdCBpdGVtIGluIHRoZSBpbmRleC50cyBmaWxlIVxuLyoqXG4gKiAjIyBXaGF0IGlzIHRoaXM/XG4gKlxuICogRnVuY3Rpb25zIHRvIG1hdGNoIGRpZmZlcmVudCBgQXN0Lk5vZGVgIHR5cGVzIGluIGEgYHVuaWZpZWQtbGF0ZXhgIEFic3RyYWN0IFN5bnRheCBUcmVlIChBU1QpLlxuICpcbiAqICMjIFdoZW4gc2hvdWxkIEkgdXNlIHRoaXM/XG4gKlxuICogSWYgeW91IG5lZWQgYSB0eXBlLWd1YXJkIHRvIGVuc3VyZSBhIG5vZGUgaXMgb2YgYSBjZXJ0YWluIHR5cGU7IGZvciBleGFtcGxlLCBkdXJpbmcgYSBjYWxsIHRvIGB1bmlmaWVkLWxhdGV4LXVudGlsLXZpc2l0YC5cbiAqL1xuIiwiaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5pbXBvcnQgeyBFbnZJbmZvLCBNYWNyb0luZm8sIE1hY3JvSW5mb1JlY29yZCB9IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5pbXBvcnQgeyBwcmludFJhdyB9IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXV0aWwtcHJpbnQtcmF3XCI7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hY3JvIG1hdGNoaW5nIGZ1bmN0aW9uIHRoYXQgdXNlcyBhIGBTcGVjaWFsTWFjcm9TcGVjYCBvciBsaXN0IG9mIG1hY3Jvc1xuICogYW5kIGdlbmVyYXRlcyBhIGhhc2ggZm9yIHF1aWNrIGxvb2t1cC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWFjcm9NYXRjaGVyKFxuICAgIG1hY3JvczogQXN0Lk1hY3JvW10gfCBzdHJpbmdbXSB8IFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4pIHtcbiAgICAvLyBXZSBmaXJzdCBtYWtlIHN1cmUgd2UgaGF2ZSBhIHJlY29yZCB0eXBlIHdpdGgga2V5cyBiZWluZyB0aGUgbWFjcm8ncyBjb250ZW50c1xuICAgIGNvbnN0IG1hY3Jvc0hhc2ggPSBBcnJheS5pc0FycmF5KG1hY3JvcylcbiAgICAgICAgPyBtYWNyb3MubGVuZ3RoID4gMFxuICAgICAgICAgICAgPyB0eXBlb2YgbWFjcm9zWzBdID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgPyBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICAgICAgICAgICAgbWFjcm9zLm1hcCgobWFjcm8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtYWNybyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgYnJhbmNoIG9mIG1hcCBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW21hY3JvLCB7fV0gYXMgW3N0cmluZywgTWFjcm9JbmZvXTtcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgICAgICAgICAgICAgICAgIG1hY3Jvcy5tYXAoKG1hY3JvKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWFjcm8gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIGJyYW5jaCBvZiBtYXAgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hY3JvLmVzY2FwZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFjcm8uY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGVzY2FwZVRva2VuOiBtYWNyby5lc2NhcGVUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSBhcyBbc3RyaW5nLCBNYWNyb0luZm9dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbbWFjcm8uY29udGVudCwge31dIGFzIFtzdHJpbmcsIE1hY3JvSW5mb107XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIDoge31cbiAgICAgICAgOiBtYWNyb3M7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWF0Y2hBZ2FpbnN0TWFjcm9zKG5vZGU6IGFueSB8IEFzdC5NYWNybykge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsIHx8IG5vZGUudHlwZSAhPT0gXCJtYWNyb1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGEgbWFjcm8gdHlwZVxuICAgICAgICBjb25zdCBzcGVjID0gbWFjcm9zSGFzaFtub2RlLmNvbnRlbnRdO1xuICAgICAgICBpZiAoIXNwZWMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygc3BlYyA9PT0gXCJvYmplY3RcIiAmJiBcImVzY2FwZVRva2VuXCIgaW4gc3BlYykge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAoc3BlYyBhcyBNYWNyb0luZm9SZWNvcmQpLmVzY2FwZVRva2VuID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAoc3BlYyBhcyBNYWNyb0luZm9SZWNvcmQpLmVzY2FwZVRva2VuID09PSBub2RlLmVzY2FwZVRva2VuXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gYXMgQXN0LlR5cGVHdWFyZDxBc3QuTWFjcm8+O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYWNybyBtYXRjaGluZyBmdW5jdGlvbiB0aGF0IHVzZXMgYSBgU3BlY2lhbE1hY3JvU3BlY2Agb3IgbGlzdCBvZiBtYWNyb3NcbiAqIGFuZCBnZW5lcmF0ZXMgYSBoYXNoIGZvciBxdWljayBsb29rdXAuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVudmlyb25tZW50TWF0Y2hlcihtYWNyb3M6IHN0cmluZ1tdIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHtcbiAgICAvLyBXZSBmaXJzdCBtYWtlIHN1cmUgd2UgaGF2ZSBhIHJlY29yZCB0eXBlIHdpdGgga2V5cyBiZWluZyB0aGUgbWFjcm8ncyBjb250ZW50c1xuICAgIGNvbnN0IGVudmlyb25tZW50c0hhc2ggPSBBcnJheS5pc0FycmF5KG1hY3JvcylcbiAgICAgICAgPyBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICAgIG1hY3Jvcy5tYXAoKHN0cikgPT4ge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzdHIsIHt9XSBhcyBbc3RyaW5nLCBFbnZJbmZvXTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIDogbWFjcm9zO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1hdGNoQWdhaW5zdEVudmlyb25tZW50cyhub2RlOiBhbnkgfCBBc3QuRW52aXJvbm1lbnQpIHtcbiAgICAgICAgaWYgKCFtYXRjaC5hbnlFbnZpcm9ubWVudChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgd2UgaGF2ZSBhbiBlbnZpcm9ubWVudCB0eXBlXG4gICAgICAgIGNvbnN0IGVudk5hbWUgPSBwcmludFJhdyhub2RlLmVudik7XG4gICAgICAgIGNvbnN0IHNwZWMgPSBlbnZpcm9ubWVudHNIYXNoW2Vudk5hbWVdO1xuICAgICAgICBpZiAoIXNwZWMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gYXMgQXN0LlR5cGVHdWFyZDxBc3QuRW52aXJvbm1lbnQ+O1xufVxuXG4vKipcbiAqIEZ1bmN0aW9ucyB0byBtYXRjaCBkaWZmZXJlbnQgdHlwZXMgb2Ygbm9kZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBtYXRjaCA9IHtcbiAgICBtYWNybyhub2RlOiBhbnksIG1hY3JvTmFtZT86IHN0cmluZyk6IG5vZGUgaXMgQXN0Lk1hY3JvIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBub2RlLnR5cGUgPT09IFwibWFjcm9cIiAmJlxuICAgICAgICAgICAgKG1hY3JvTmFtZSA9PSBudWxsIHx8IG5vZGUuY29udGVudCA9PT0gbWFjcm9OYW1lKVxuICAgICAgICApO1xuICAgIH0sXG4gICAgYW55TWFjcm8obm9kZTogYW55KTogbm9kZSBpcyBBc3QuTWFjcm8ge1xuICAgICAgICByZXR1cm4gbWF0Y2gubWFjcm8obm9kZSk7XG4gICAgfSxcbiAgICBlbnZpcm9ubWVudChub2RlOiBhbnksIGVudk5hbWU/OiBzdHJpbmcpOiBub2RlIGlzIEFzdC5FbnZpcm9ubWVudCB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKG5vZGUudHlwZSA9PT0gXCJlbnZpcm9ubWVudFwiIHx8IG5vZGUudHlwZSA9PT0gXCJtYXRoZW52XCIpICYmXG4gICAgICAgICAgICAoZW52TmFtZSA9PSBudWxsIHx8IHByaW50UmF3KG5vZGUuZW52KSA9PT0gZW52TmFtZSlcbiAgICAgICAgKTtcbiAgICB9LFxuICAgIGFueUVudmlyb25tZW50KG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0LkVudmlyb25tZW50IHtcbiAgICAgICAgcmV0dXJuIG1hdGNoLmVudmlyb25tZW50KG5vZGUpO1xuICAgIH0sXG4gICAgY29tbWVudChub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5Db21tZW50IHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiY29tbWVudFwiO1xuICAgIH0sXG4gICAgcGFyYnJlYWsobm9kZTogYW55KTogbm9kZSBpcyBBc3QuUGFyYnJlYWsge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJwYXJicmVha1wiO1xuICAgIH0sXG4gICAgd2hpdGVzcGFjZShub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5XaGl0ZXNwYWNlIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwid2hpdGVzcGFjZVwiO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogTWF0Y2hlcyB3aGl0ZXNwYWNlIG9yIGEgY29tbWVudCB3aXRoIGxlYWRpbmcgd2hpdGVzcGFjZS5cbiAgICAgKi9cbiAgICB3aGl0ZXNwYWNlTGlrZShcbiAgICAgICAgbm9kZTogYW55XG4gICAgKTogbm9kZSBpcyBBc3QuV2hpdGVzcGFjZSB8IChBc3QuQ29tbWVudCAmIHsgbGVhZGluZ1doaXRlc3BhY2U6IHRydWUgfSkge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG5vZGUudHlwZSA9PT0gXCJ3aGl0ZXNwYWNlXCIgfHxcbiAgICAgICAgICAgIChub2RlLnR5cGUgPT09IFwid2hpdGVzcGFjZVwiICYmIG5vZGUubGVhZGluZ1doaXRlc3BhY2UgPT09IHRydWUpXG4gICAgICAgICk7XG4gICAgfSxcbiAgICBzdHJpbmcobm9kZTogYW55LCB2YWx1ZT86IHN0cmluZyk6IG5vZGUgaXMgQXN0LlN0cmluZyB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbm9kZS50eXBlID09PSBcInN0cmluZ1wiICYmICh2YWx1ZSA9PSBudWxsIHx8IG5vZGUuY29udGVudCA9PT0gdmFsdWUpXG4gICAgICAgICk7XG4gICAgfSxcbiAgICBhbnlTdHJpbmcobm9kZTogYW55KTogbm9kZSBpcyBBc3QuU3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoLnN0cmluZyhub2RlKTtcbiAgICB9LFxuICAgIGdyb3VwKG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0Lkdyb3VwIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiZ3JvdXBcIjtcbiAgICB9LFxuICAgIGFyZ3VtZW50KG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0LkFyZ3VtZW50IHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiYXJndW1lbnRcIjtcbiAgICB9LFxuICAgIGJsYW5rQXJndW1lbnQobm9kZTogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIGlmICghbWF0Y2guYXJndW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbm9kZS5vcGVuTWFyayA9PT0gXCJcIiAmJlxuICAgICAgICAgICAgbm9kZS5jbG9zZU1hcmsgPT09IFwiXCIgJiZcbiAgICAgICAgICAgIG5vZGUuY29udGVudC5sZW5ndGggPT09IDBcbiAgICAgICAgKTtcbiAgICB9LFxuICAgIG1hdGgobm9kZTogYW55KTogbm9kZSBpcyBBc3QuRGlzcGxheU1hdGggfCBBc3QuSW5saW5lTWF0aCB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcImRpc3BsYXltYXRoXCIgfHwgbm9kZS50eXBlID09PSBcImlubGluZW1hdGhcIjtcbiAgICB9LFxuICAgIGNyZWF0ZU1hY3JvTWF0Y2hlcixcbiAgICBjcmVhdGVFbnZpcm9ubWVudE1hdGNoZXIsXG59O1xuIiwiZXhwb3J0ICogZnJvbSBcIi4vbGlicy9wcmludC1yYXdcIjtcblxuLy8gTk9URTogVGhlIGRvY3N0cmluZyBjb21tZW50IG11c3QgYmUgdGhlIGxhc3QgaXRlbSBpbiB0aGUgaW5kZXgudHMgZmlsZSFcbi8qKlxuICogIyMgV2hhdCBpcyB0aGlzP1xuICpcbiAqIEZ1bmN0aW9ucyB0byBwcmludCBhIGB1bmlmaWVkLWxhdGV4YCBBYnN0cmFjdCBTeW50YXggVHJlZSAoQVNUKSB0byBhIHN0cmluZy5cbiAqXG4gKiAjIyBXaGVuIHNob3VsZCBJIHVzZSB0aGlzP1xuICpcbiAqIElmIHlvdSB3YW50IHRvIGRpcmVjdGx5IHByaW50IGFuIGBBc3QuQXN0YCB0byBhIHN0cmluZyB3aXRob3V0IGFueSBwcmV0dHkgcHJpbnRpbmcgb3IgZm9ybWF0dGluZy5cbiAqL1xuIiwiaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5cbnR5cGUgUHJpbnRhYmxlID0gQXN0Lk5vZGUgfCBBc3QuQXJndW1lbnQgfCBzdHJpbmc7XG50eXBlIFByaW50VG9rZW4gPSBzdHJpbmcgfCB0eXBlb2YgbGluZWJyZWFrO1xuXG5leHBvcnQgY29uc3QgbGluZWJyZWFrID0gU3ltYm9sKFwibGluZWJyZWFrXCIpO1xuY29uc3QgRVNDQVBFID0gXCJcXFxcXCI7XG5cbi8qKlxuICogUmVuZGVycyB0aGUgQVNUIHRvIGFuIGFycmF5IGluc2VydGluZyBgbGluZWJyZWFrYCB3aGVyZSBuZWVkZWQ7XG4gKiBUaGlzIGFycmF5IG1heSBiZSBuZXN0ZWQuXG4gKlxuICogQHBhcmFtIHsqfSBub2RlXG4gKi9cbmZ1bmN0aW9uIF9wcmludFJhdyhub2RlOiBQcmludGFibGUgfCBQcmludGFibGVbXSk6IFByaW50VG9rZW5bXSB7XG4gICAgaWYgKHR5cGVvZiBub2RlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBbbm9kZV07XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICAgIHJldHVybiAoW10gYXMgUHJpbnRUb2tlbltdKS5jb25jYXQoXG4gICAgICAgICAgICAuLi5ub2RlLm1hcCgobjogUHJpbnRhYmxlKSA9PiBfcHJpbnRSYXcobikpXG4gICAgICAgICk7XG4gICAgfVxuICAgIC8vIHRtcCB2YXJpYWJsZXNcbiAgICBsZXQgYXJnc1N0cmluZywgZXNjYXBlO1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJyb290XCI6XG4gICAgICAgICAgICByZXR1cm4gX3ByaW50UmF3KG5vZGUuY29udGVudCk7XG4gICAgICAgIGNhc2UgXCJhcmd1bWVudFwiOlxuICAgICAgICAgICAgcmV0dXJuIFtub2RlLm9wZW5NYXJrLCAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSwgbm9kZS5jbG9zZU1hcmtdO1xuICAgICAgICBjYXNlIFwiY29tbWVudFwiOlxuICAgICAgICAgICAgdmFyIHN1ZmZpeCA9IG5vZGUuc3VmZml4UGFyYnJlYWsgPyBcIlwiIDogbGluZWJyZWFrO1xuICAgICAgICAgICAgLy8gQSBjb21tZW50IGlzIHJlc3BvbnNpYmxlIGZvciBwcmludGluZyBpdHMgb3duIGxlYWRpbmcgd2hpdGVzcGFjZVxuICAgICAgICAgICAgdmFyIGxlYWRpbmdXaGl0ZXNwYWNlID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChub2RlLnNhbWVsaW5lICYmIG5vZGUubGVhZGluZ1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZSA9IFwiIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuc2FtZWxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBsZWFkaW5nV2hpdGVzcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgXCIlXCIsXG4gICAgICAgICAgICAgICAgICAgIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLFxuICAgICAgICAgICAgICAgICAgICBzdWZmaXgsXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbbGluZWJyZWFrLCBcIiVcIiwgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksIHN1ZmZpeF07XG4gICAgICAgIGNhc2UgXCJlbnZpcm9ubWVudFwiOlxuICAgICAgICBjYXNlIFwibWF0aGVudlwiOlxuICAgICAgICBjYXNlIFwidmVyYmF0aW1cIjpcbiAgICAgICAgICAgIHZhciBlbnYgPSBfcHJpbnRSYXcobm9kZS5lbnYpO1xuICAgICAgICAgICAgdmFyIGVudlN0YXJ0OiBQcmludFRva2VuW10gPSBbRVNDQVBFICsgXCJiZWdpbntcIiwgLi4uZW52LCBcIn1cIl07XG4gICAgICAgICAgICB2YXIgZW52RW5kOiBQcmludFRva2VuW10gPSBbRVNDQVBFICsgXCJlbmR7XCIsIC4uLmVudiwgXCJ9XCJdO1xuICAgICAgICAgICAgYXJnc1N0cmluZyA9XG4gICAgICAgICAgICAgICAgKG5vZGUgYXMgYW55KS5hcmdzID09IG51bGwgPyBbXSA6IF9wcmludFJhdygobm9kZSBhcyBhbnkpLmFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAuLi5lbnZTdGFydCxcbiAgICAgICAgICAgICAgICAuLi5hcmdzU3RyaW5nLFxuICAgICAgICAgICAgICAgIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLFxuICAgICAgICAgICAgICAgIC4uLmVudkVuZCxcbiAgICAgICAgICAgIF07XG4gICAgICAgIGNhc2UgXCJkaXNwbGF5bWF0aFwiOlxuICAgICAgICAgICAgcmV0dXJuIFtFU0NBUEUgKyBcIltcIiwgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksIEVTQ0FQRSArIFwiXVwiXTtcbiAgICAgICAgY2FzZSBcImdyb3VwXCI6XG4gICAgICAgICAgICByZXR1cm4gW1wie1wiLCAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSwgXCJ9XCJdO1xuICAgICAgICBjYXNlIFwiaW5saW5lbWF0aFwiOlxuICAgICAgICAgICAgcmV0dXJuIFtcIiRcIiwgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksIFwiJFwiXTtcbiAgICAgICAgY2FzZSBcIm1hY3JvXCI6XG4gICAgICAgICAgICBhcmdzU3RyaW5nID0gbm9kZS5hcmdzID09IG51bGwgPyBbXSA6IF9wcmludFJhdyhub2RlLmFyZ3MpO1xuICAgICAgICAgICAgZXNjYXBlID0gbm9kZS5lc2NhcGVUb2tlbiA9PSBudWxsID8gRVNDQVBFIDogbm9kZS5lc2NhcGVUb2tlbjtcbiAgICAgICAgICAgIHJldHVybiBbZXNjYXBlLCAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSwgLi4uYXJnc1N0cmluZ107XG4gICAgICAgIGNhc2UgXCJwYXJicmVha1wiOlxuICAgICAgICAgICAgcmV0dXJuIFtsaW5lYnJlYWssIGxpbmVicmVha107XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBbbm9kZS5jb250ZW50XTtcbiAgICAgICAgY2FzZSBcInZlcmJcIjpcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgRVNDQVBFLFxuICAgICAgICAgICAgICAgIG5vZGUuZW52LFxuICAgICAgICAgICAgICAgIG5vZGUuZXNjYXBlLFxuICAgICAgICAgICAgICAgIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLFxuICAgICAgICAgICAgICAgIG5vZGUuZXNjYXBlLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgY2FzZSBcIndoaXRlc3BhY2VcIjpcbiAgICAgICAgICAgIHJldHVybiBbXCIgXCJdO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgXCJDYW5ub3QgZmluZCByZW5kZXIgZm9yIG5vZGUgXCIsXG4gICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICBgKG9mIHR5cGUgJHt0eXBlb2Ygbm9kZX0pYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBbXCJcIiArIG5vZGVdO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBBU1QgdG8gYSBzdHJpbmcgd2l0aG91dCBhbnkgcHJldHR5IHByaW50aW5nLlxuICpcbiAqIEBwYXJhbSB7Kn0gbm9kZVxuICogQHBhcmFtIHsqfSBvcHRpb25zIC0gU2V0dGluZyBgYXNBcnJheWAgdG8gYHRydWVgIHdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIHRoZSBzeW1ib2wgYGxpbmVicmVha2AsIHNvIHRoYXQgcHJpbnRpbmcgY2FuIGJlIGN1c3RvbWl6ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmludFJhdyhcbiAgICBub2RlOiBQcmludGFibGUgfCBQcmludGFibGVbXSxcbiAgICBvcHRpb25zPzogeyBhc0FycmF5OiBmYWxzZSB9XG4pOiBzdHJpbmc7XG5leHBvcnQgZnVuY3Rpb24gcHJpbnRSYXcoXG4gICAgbm9kZTogUHJpbnRhYmxlIHwgUHJpbnRhYmxlW10sXG4gICAgb3B0aW9uczogeyBhc0FycmF5OiB0cnVlIH1cbik6IFByaW50VG9rZW5bXTtcbmV4cG9ydCBmdW5jdGlvbiBwcmludFJhdyhub2RlOiBQcmludGFibGUgfCBQcmludGFibGVbXSwgb3B0aW9ucz86IG9iamVjdCk6IGFueSB7XG4gICAgY29uc3QgYXNBcnJheSA9IG9wdGlvbnMgIT0gbnVsbCA/IChvcHRpb25zIGFzIGFueSkuYXNBcnJheSA6IGZhbHNlO1xuICAgIGNvbnN0IHByaW50ZWRUb2tlbnMgPSBfcHJpbnRSYXcobm9kZSk7XG4gICAgaWYgKGFzQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHByaW50ZWRUb2tlbnM7XG4gICAgfVxuICAgIHJldHVybiBwcmludGVkVG9rZW5zLm1hcCgoeCkgPT4gKHggPT09IGxpbmVicmVhayA/IFwiXFxuXCIgOiB4KSkuam9pbihcIlwiKTtcbn1cbiIsImV4cG9ydCAqIGZyb20gXCIuL2xpYnMvdmlzaXRcIjtcblxuLy8gTk9URTogVGhlIGRvY3N0cmluZyBjb21tZW50IG11c3QgYmUgdGhlIGxhc3QgaXRlbSBpbiB0aGUgaW5kZXgudHMgZmlsZSFcbi8qKlxuICogIyMgV2hhdCBpcyB0aGlzP1xuICpcbiAqIEZ1bmN0aW9ucyB0byB0cmF2ZXJzZSBhIGB1bmlmaWVkLWxhdGV4YCBBYnN0cmFjdCBTeW50YXggVHJlZSAoQVNUKS4gYHZpc2l0YCBpc1xuICogdmVyeSBzaW1pbGFyIHRvIFtlc3RyZWUtdXRpbC12aXNpdF0oaHR0cHM6Ly9naXRodWIuY29tL3N5bnRheC10cmVlL2VzdHJlZS11dGlsLXZpc2l0KS5cbiAqXG4gKiAjIyBXaGVuIHNob3VsZCBJIHVzZSB0aGlzP1xuICpcbiAqIElmIHlvdSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJlcGxhY2UgcGFydGljdWxhciBBU1Qgbm9kZXMuXG4gKi9cbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoXCI7XG5cbi8qKlxuICogTGlzdCBhbGwgcHJvcHMgb2YgdGhlIGN1cnJlbnQgbm9kZSB0aGF0IHNob3VsZCBiZSBwcm9jZXNzZWRcbiAqIGluIG1hdGggbW9kZSBvciBub3QgaW4gbWF0aCBtb2RlLiBJZiBtYXRoIG1vZGUgaXMgbm90IHNwZWNpZmllZCBpbiB0aGUgbm9kZSdzIHJlbmRlclxuICogaW5mbywgZW1wdHkgbGlzdHMgYXJlIHJldHVybmVkLlxuICpcbiAqIEZvciBleGFtcGxlIGBcXHRleHR7Zm9vfWAgd2lsbCByZXBvcnQgdGhhdCBgYXJnc2Agc2hvdWxkICpub3QqIGJlIHByb2Nlc3NlZCBpbiBtYXRoIG1vZGUsXG4gKiBzaW5jZSBpdCdzIGNvbnRlbnRzIHNob3VsZCBhbHdheXMgYmUgcHJvY2Vzc2VkIGluIHRleHQgbW9kZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3RNYXRoQ2hpbGRyZW4obm9kZTogQXN0LkFzdCk6IHtcbiAgICBlbnRlcjogc3RyaW5nW107XG4gICAgbGVhdmU6IHN0cmluZ1tdO1xufSB7XG4gICAgY29uc3QgTlVMTF9SRVRVUk4gPSB7IGVudGVyOiBbXSwgbGVhdmU6IFtdIH07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIE5VTExfUkVUVVJOO1xuICAgIH1cbiAgICBpZiAobWF0Y2gubWF0aChub2RlKSkge1xuICAgICAgICAvLyBXaGVuIHdlIGVudGVyIGEgbWF0aCBlbnZpcm9ubWVudCwgb3VyIGNvbnRlbnQgaXMgYWx3YXlzXG4gICAgICAgIC8vIGNvbnNpZGVyZWQgbWF0aCBtb2RlXG4gICAgICAgIHJldHVybiB7IGVudGVyOiBbXCJjb250ZW50XCJdLCBsZWF2ZTogW10gfTtcbiAgICB9XG5cbiAgICBjb25zdCByZW5kZXJJbmZvOiB7IGluTWF0aE1vZGU/OiBib29sZWFuIH0gPSBub2RlLl9yZW5kZXJJbmZvIHx8IHt9O1xuICAgIGlmIChyZW5kZXJJbmZvLmluTWF0aE1vZGUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gTlVMTF9SRVRVUk47XG4gICAgfVxuICAgIGlmIChtYXRjaC5tYWNybyhub2RlKSkge1xuICAgICAgICBpZiAocmVuZGVySW5mby5pbk1hdGhNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlbnRlcjogW1wiYXJnc1wiXSwgbGVhdmU6IFtdIH07XG4gICAgICAgIH0gZWxzZSBpZiAocmVuZGVySW5mby5pbk1hdGhNb2RlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZW50ZXI6IFtdLCBsZWF2ZTogW1wiYXJnc1wiXSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRjaC5lbnZpcm9ubWVudChub2RlKSkge1xuICAgICAgICBpZiAocmVuZGVySW5mby5pbk1hdGhNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlbnRlcjogW1wiY29udGVudFwiXSwgbGVhdmU6IFtdIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBlbnRlcjogW10sIGxlYXZlOiBbXCJjb250ZW50XCJdIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE5VTExfUkVUVVJOO1xufVxuIiwiaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5pbXBvcnQgeyBsaXN0TWF0aENoaWxkcmVuIH0gZnJvbSBcIi4vbGlzdC1tYXRoLWNoaWxkcmVuXCI7XG5cbmV4cG9ydCB0eXBlIFZpc2l0b3JDb250ZXh0ID0ge1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIG5vZGUgaXMgYmVpbmcgcHJvY2Vzc2VkIGluIG1hdGggbW9kZS5cbiAgICAgKlxuICAgICAqIFRoaXMgaGFwcGVucyB3aGVuIHRoZSBub2RlIGlzIGEgZGlyZWN0b3Igb3IgaW5kaXJlY3QgY2hpbGRcbiAgICAgKiBvZiBhIG1hdGggZW52aXJvbm1lbnQgKGUuZy4gYCRhYmMkYCksIGJ1dCBub3Qgd2hlbiBhbiBlbnZpcm9ubWVudFxuICAgICAqIHJlLWVzdGFibGlzaGVzIHRleHQgbW9kZSAoZS5nLiBgJFxcdGV4dHthYmN9JGApXG4gICAgICovXG4gICAgaW5NYXRoTW9kZT86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgbm9kZSBoYXMgYW55IGFuY2VzdG9yIHRoYXQgaXMgcHJvY2Vzc2VkIGluIG1hdGggbW9kZS5cbiAgICAgKi9cbiAgICBoYXNNYXRoTW9kZUFuY2VzdG9yPzogYm9vbGVhbjtcbn07XG5cbnR5cGUgR2V0R3VhcmQ8VD4gPSBUIGV4dGVuZHMgKHg6IGFueSkgPT4geCBpcyBpbmZlciBSID8gUiA6IG5ldmVyO1xuLyoqXG4gKiBHZXRzIHRoZSB0eXBlIHRoYXQgYSB0eXBlLWd1YXJkIGZ1bmN0aW9uIGlzIGd1YXJkaW5nLiBJZlxuICogdGhlIGd1YXJkIHR5cGUgY2Fubm90IGJlIGRldGVybWluZWQsIHRoZSBpbnB1dCB0eXBlIGlzIHJldHVybmVkLlxuICovXG50eXBlIEd1YXJkVHlwZU9mPFQgZXh0ZW5kcyAoeDogYW55KSA9PiBib29sZWFuPiA9IEdldEd1YXJkPFQ+IGV4dGVuZHMgbmV2ZXJcbiAgICA/IFQgZXh0ZW5kcyAoeDogaW5mZXIgQSkgPT4gYW55XG4gICAgICAgID8gQVxuICAgICAgICA6IG5ldmVyXG4gICAgOiBHZXRHdWFyZDxUPjtcblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgZ3VhcmQgdHlwZSBmcm9tIHRoZSBgdGVzdGAgZnVuY3Rpb24gcHJvdmlkZWQgaW4gYVxuICogYFZpc2l0T3B0aW9uc2AgYXJndW1lbnQuXG4gKi9cbnR5cGUgR3VhcmRGcm9tT3B0aW9uczxcbiAgICBPcHRzIGV4dGVuZHMgVmlzaXRPcHRpb25zLFxuICAgIFBvc3NpYmxlVHlwZXMgPSBBc3QuQXN0XG4+ID0gT3B0cyBleHRlbmRzIHtcbiAgICB0ZXN0OiBpbmZlciBSO1xufVxuICAgID8gUiBleHRlbmRzICh4OiBhbnkpID0+IGJvb2xlYW5cbiAgICAgICAgPyAvLyBBIGd1YXJkIGxpa2UgYHR5cGVvZiBBcnJheS5pc0FycmF5YCB3aWxsIHJldHVybiBgYW55W11gIGFzIHRoZSB0eXBlLlxuICAgICAgICAgIC8vIFRoaXMgdHlwZSBjYW5ub3QgYmUgbmFycm93ZWQsIHNvIGluc3RlYWQgd2UgdXNlIGl0IHRvIHBpY2sgZnJvbVxuICAgICAgICAgIC8vIHRoZSBzZXQgb2YgYWxsIHBvc3NpYmxlIHR5cGVzLlxuICAgICAgICAgIEV4dHJhY3Q8UG9zc2libGVUeXBlcywgR3VhcmRUeXBlT2Y8Uj4+XG4gICAgICAgIDogUG9zc2libGVUeXBlc1xuICAgIDogUG9zc2libGVUeXBlcztcblxuLyoqXG4gKiBOYXJyb3cgdGhlIHR5cGUgYFRgIGJhc2VkIG9uIHRoZSBgVmlzaXRPcHRpb25zYCBzdXBwbGllZC4gSWYgYHtpbmNsdWRlQXJyYXlzOiBmYWxzZX1gXG4gKiBpcyBzcGVjaWZpZWQgaW4gdGhlIGBWaXNpdE9wdGlvbnNgLCB0aGVuIGFycmF5cyBhcmUgZXhjbHVkZWQgZnJvbSBgVGAuXG4gKi9cbnR5cGUgTmFycm93QXJyYXlzQmFzZWRPbk9wdGlvbnM8VCwgT3B0cyBleHRlbmRzIFZpc2l0T3B0aW9ucz4gPSBPcHRzIGV4dGVuZHMge1xuICAgIGluY2x1ZGVBcnJheXM6IGluZmVyIEE7XG59XG4gICAgPyBBIGV4dGVuZHMgdHJ1ZVxuICAgICAgICA/IFRcbiAgICAgICAgOiBFeGNsdWRlPFQsIGFueVtdPlxuICAgIDogRXhjbHVkZTxULCBhbnlbXT47XG5cbi8qKlxuICogR2V0IHRoZSB0eXBlIG9mIHRoZSBwYXJhbWV0ZXIgdG8gdGhlIGBWaXNpdG9yYCBmdW5jdGlvbiBiYXNlZCBvbiB0aGVcbiAqIGBWaXNpdE9wdGlvbnNgIHRoYXQgYXJlIHN1cHBsaWVkLlxuICovXG50eXBlIFZpc2l0b3JUeXBlRnJvbU9wdGlvbnM8T3B0cyBleHRlbmRzIFZpc2l0T3B0aW9ucz4gPVxuICAgIE5hcnJvd0FycmF5c0Jhc2VkT25PcHRpb25zPEd1YXJkRnJvbU9wdGlvbnM8T3B0cz4sIE9wdHM+O1xuXG4vKipcbiAqIENvbnRpbnVlIHRyYXZlcnNpbmcgYXMgbm9ybWFsXG4gKi9cbmV4cG9ydCBjb25zdCBDT05USU5VRSA9IFN5bWJvbChcImNvbnRpbnVlXCIpO1xuLyoqXG4gKiBEbyBub3QgdHJhdmVyc2UgdGhpcyBub2Rl4oCZcyBjaGlsZHJlblxuICovXG5leHBvcnQgY29uc3QgU0tJUCA9IFN5bWJvbChcInNraXBcIik7XG4vKipcbiAqIFN0b3AgdHJhdmVyc2luZyBpbW1lZGlhdGVseVxuICovXG5leHBvcnQgY29uc3QgRVhJVCA9IFN5bWJvbChcImV4aXRcIik7XG5cbnR5cGUgQWN0aW9uID0gdHlwZW9mIENPTlRJTlVFIHwgdHlwZW9mIFNLSVAgfCB0eXBlb2YgRVhJVDtcbnR5cGUgSW5kZXggPSBudW1iZXI7XG50eXBlIEFjdGlvblR1cGxlID0gW0FjdGlvbl0gfCBbdHlwZW9mIFNLSVAsIEluZGV4XSB8IFt0eXBlb2YgQ09OVElOVUUsIEluZGV4XTtcblxuLyoqXG4gKiBBIHZpc2l0b3IgdGFrZXMgYSBgbm9kZWAsIGBrZXlgLCBgaW5kZXhgLCBhbmQgLi4uXG4gKlxuICogQHBhcmFtIGtleSAtIFRoZSBrZXkgb2YgdGhlIHBhcmVudCB0aGF0IHdlIHdlcmUgYWNjZXNzZWQgdGhyb3VnaC5cbiAqL1xudHlwZSBWaXNpdG9yPFQ+ID0gKFxuICAgIG5vZGU6IFQsXG4gICAgaW5mbzogVmlzaXRJbmZvXG4pID0+IG51bGwgfCB1bmRlZmluZWQgfCBBY3Rpb24gfCBJbmRleCB8IEFjdGlvblR1cGxlIHwgdm9pZDtcbnR5cGUgVmlzaXRvcnM8VD4gPSB7IGVudGVyPzogVmlzaXRvcjxUPjsgbGVhdmU/OiBWaXNpdG9yPFQ+IH07XG5cbnR5cGUgVmlzaXRPcHRpb25zID0ge1xuICAgIHN0YXJ0aW5nQ29udGV4dD86IFZpc2l0b3JDb250ZXh0O1xuICAgIC8qKlxuICAgICAqIFR5cGUgZ3VhcmQgZm9yIHR5cGVzIHRoYXQgYXJlIHBhc3NlZCB0byB0aGUgYHZpc2l0b3JgIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHRlc3Q/OiAobm9kZTogQXN0LkFzdCwgaW5mbzogVmlzaXRJbmZvKSA9PiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgYXJyYXlzIHdpbGwgYmUgc2VudCB0byB0aGUgYHZpc2l0b3JgIGZ1bmN0aW9uLiBJZiBmYWxzeSxcbiAgICAgKiBvbmx5IG5vZGVzIHdpbGwgYmUgcGFzdCB0byBgdmlzaXRvcmAuXG4gICAgICovXG4gICAgaW5jbHVkZUFycmF5cz86IGJvb2xlYW47XG59O1xuXG5jb25zdCBERUZBVUxUX0NPTlRFWFQ6IFZpc2l0b3JDb250ZXh0ID0ge1xuICAgIGluTWF0aE1vZGU6IGZhbHNlLFxuICAgIGhhc01hdGhNb2RlQW5jZXN0b3I6IGZhbHNlLFxufTtcblxuZXhwb3J0IHR5cGUgVmlzaXRJbmZvID0ge1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBlbGVtZW50IHdhcyBhY2Nlc3NlZCB2aWEgYW4gYXR0cmlidXRlLCB0aGUgYXR0cmlidXRlIGtleSBpcyBzcGVjaWZpZWQuXG4gICAgICovXG4gICAgcmVhZG9ubHkga2V5OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGVsZW1lbnQgd2FzIGFjY2Vzc2VkIGluIGFuIGFycmF5LCB0aGUgaW5kZXggaXMgc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGluZGV4OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIGFuY2VzdG9yIG5vZGVzLCBgW3BhcmVudCwgZ3JhbmRwYXJlbnQsIGdyZWF0LWdyYW5kcGFyZW50LCAuLi5dYFxuICAgICAqL1xuICAgIHJlYWRvbmx5IHBhcmVudHM6IChBc3QuTm9kZSB8IEFzdC5Bcmd1bWVudClbXTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZWxlbWVudCB3YXMgYWNjZXNzZWQgaW4gYW4gYXJyYXksIHRoZSBhcnJheSB0aGF0IGl0IGlzIHBhcnQgb2YuXG4gICAgICovXG4gICAgcmVhZG9ubHkgY29udGFpbmluZ0FycmF5OiAoQXN0Lk5vZGUgfCBBc3QuQXJndW1lbnQpW10gfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogVGhlIExhVGVYIGNvbnRleHQgb2YgdGhlIGN1cnJlbnQgbWF0Y2guXG4gICAgICovXG4gICAgcmVhZG9ubHkgY29udGV4dDogVmlzaXRvckNvbnRleHQ7XG59O1xuXG4vKipcbiAqIFZpc2l0IGNoaWxkcmVuIG9mIHRyZWUgd2hpY2ggcGFzcyBhIHRlc3RcbiAqXG4gKiBAcGFyYW0ge05vZGV9IHRyZWUgQWJzdHJhY3Qgc3ludGF4IHRyZWUgdG8gd2Fsa1xuICogQHBhcmFtIHtWaXNpdG9yfFZpc2l0b3JzfSBbdmlzaXRvcl0gRnVuY3Rpb24gdG8gcnVuIGZvciBlYWNoIG5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZpc2l0PE9wdHMgZXh0ZW5kcyBWaXNpdE9wdGlvbnM+KFxuICAgIHRyZWU6IEFzdC5Bc3QsXG4gICAgdmlzaXRvcjpcbiAgICAgICAgfCBWaXNpdG9yPFZpc2l0b3JUeXBlRnJvbU9wdGlvbnM8T3B0cz4+XG4gICAgICAgIHwgVmlzaXRvcnM8VmlzaXRvclR5cGVGcm9tT3B0aW9uczxPcHRzPj4sXG4gICAgb3B0aW9ucz86IE9wdHNcbikge1xuICAgIGNvbnN0IHtcbiAgICAgICAgc3RhcnRpbmdDb250ZXh0ID0gREVGQVVMVF9DT05URVhULFxuICAgICAgICB0ZXN0ID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgaW5jbHVkZUFycmF5cyA9IGZhbHNlLFxuICAgIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGxldCBlbnRlcjogVmlzaXRvcjxWaXNpdG9yVHlwZUZyb21PcHRpb25zPE9wdHM+PiB8IHVuZGVmaW5lZDtcbiAgICBsZXQgbGVhdmU6IFZpc2l0b3I8VmlzaXRvclR5cGVGcm9tT3B0aW9uczxPcHRzPj4gfCB1bmRlZmluZWQ7XG5cbiAgICBpZiAodHlwZW9mIHZpc2l0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBlbnRlciA9IHZpc2l0b3I7XG4gICAgfSBlbHNlIGlmICh2aXNpdG9yICYmIHR5cGVvZiB2aXNpdG9yID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGVudGVyID0gdmlzaXRvci5lbnRlcjtcbiAgICAgICAgbGVhdmUgPSB2aXNpdG9yLmxlYXZlO1xuICAgIH1cblxuICAgIHdhbGsodHJlZSwge1xuICAgICAgICBrZXk6IHVuZGVmaW5lZCxcbiAgICAgICAgaW5kZXg6IHVuZGVmaW5lZCxcbiAgICAgICAgcGFyZW50czogW10sXG4gICAgICAgIGNvbnRhaW5pbmdBcnJheTogdW5kZWZpbmVkLFxuICAgICAgICBjb250ZXh0OiB7IC4uLnN0YXJ0aW5nQ29udGV4dCB9LFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmc/fSBrZXlcbiAgICAgKiBAcGFyYW0ge251bWJlcj99IGluZGV4XG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IHBhcmVudHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3YWxrKFxuICAgICAgICBub2RlOiBBc3QuQXN0LFxuICAgICAgICB7IGtleSwgaW5kZXgsIHBhcmVudHMsIGNvbnRleHQsIGNvbnRhaW5pbmdBcnJheSB9OiBWaXNpdEluZm9cbiAgICApOiBBY3Rpb25UdXBsZSB7XG4gICAgICAgIGNvbnN0IG5vZGVQYXNzZXNUZXN0ID0gaW5jbHVkZUFycmF5c1xuICAgICAgICAgICAgPyB0ZXN0KG5vZGUsIHsga2V5LCBpbmRleCwgcGFyZW50cywgY29udGV4dCwgY29udGFpbmluZ0FycmF5IH0pXG4gICAgICAgICAgICA6ICFBcnJheS5pc0FycmF5KG5vZGUpICYmXG4gICAgICAgICAgICAgIHRlc3Qobm9kZSwgeyBrZXksIGluZGV4LCBwYXJlbnRzLCBjb250ZXh0LCBjb250YWluaW5nQXJyYXkgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0OiBBY3Rpb25UdXBsZSA9XG4gICAgICAgICAgICBlbnRlciAmJiBub2RlUGFzc2VzVGVzdFxuICAgICAgICAgICAgICAgID8gdG9SZXN1bHQoXG4gICAgICAgICAgICAgICAgICAgICAgZW50ZXIobm9kZSBhcyBhbnksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmluZ0FycmF5LFxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBbQ09OVElOVUVdO1xuXG4gICAgICAgIGlmIChyZXN1bHRbMF0gPT09IEVYSVQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0WzBdID09PSBTS0lQKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVhdmUgJiYgbm9kZVBhc3Nlc1Rlc3RcbiAgICAgICAgICAgICAgICA/IHRvUmVzdWx0KFxuICAgICAgICAgICAgICAgICAgICAgIGxlYXZlKG5vZGUgYXMgYW55LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5pbmdBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgICAgIC8vIFRoZSBgdmFsdWVgIGFycmF5IG1pZ2h0IGJlIG1vZGlmaWVkIGluIHBsYWNlIGFzIHdlIHRyYXZlcnNlIGl0LCBzb1xuICAgICAgICAgICAgLy8gd2UgdXNlIGEgdHJhZGl0aW9uYWwgZm9yIGxvb3AuXG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4ID4gLTEgJiYgaW5kZXggPCBub2RlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBub2RlW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB3YWxrKGl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50cyxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmluZ0FycmF5OiBub2RlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbMF0gPT09IEVYSVQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRbMV0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZvciBsb29wIHdpbGwgaW5jcmVtZW50IGkgZXZlcnkgcGFzcy4gSG93ZXZlcixcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgYW4gaW5kZXggd2FzIHJldHVybmVkLCB0aGF0J3Mgd2hlcmUgd2Ugd2FudCB0byBzdGFydCBuZXh0IHRpbWUuXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcmVzdWx0WzFdIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHJlY3Vyc2l2ZWx5IGFwcGx5IHRvIHRoZSBgY29udGVudGBcbiAgICAgICAgICAgIC8vIG9mIGFsbCB0eXBlcyAoZS5nLiwgY29tbWVudHMgYW5kIG1hY3JvcyksIHNvIHNwZWNpZnlcbiAgICAgICAgICAgIC8vIGEgYmxhY2tsaXN0LlxuICAgICAgICAgICAgbGV0IGNoaWxkUHJvcHM6IChcImNvbnRlbnRcIiB8IFwiYXJnc1wiKVtdID0gW1wiY29udGVudFwiLCBcImFyZ3NcIl07XG4gICAgICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtYWNyb1wiOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZFByb3BzID0gW1wiYXJnc1wiXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbW1lbnRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInZlcmJcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidmVyYmF0aW1cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRQcm9wcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbWF0aE1vZGVQcm9wcyA9IGxpc3RNYXRoQ2hpbGRyZW4obm9kZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBjaGlsZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBub2RlW2tleSBhcyBrZXlvZiB0eXBlb2Ygbm9kZV0gYXNcbiAgICAgICAgICAgICAgICAgICAgfCBBc3QuQXN0XG4gICAgICAgICAgICAgICAgICAgIHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyYW5kcGFyZW50cyA9IFtub2RlXS5jb25jYXQocGFyZW50cyk7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBtYXkgc3dpdGNoIGluL291dCBvZiBtYXRoIG1vZGUgYXMgd2UgcGFzcyB0byBub2RlW2tleV1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDb250ZXh0ID0geyAuLi5jb250ZXh0IH07XG4gICAgICAgICAgICAgICAgaWYgKG1hdGhNb2RlUHJvcHMuZW50ZXIuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0LmluTWF0aE1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0Lmhhc01hdGhNb2RlQW5jZXN0b3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0aE1vZGVQcm9wcy5sZWF2ZS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRleHQuaW5NYXRoTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHdhbGsodmFsdWUsIHtcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRzOiBncmFuZHBhcmVudHMsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IG5ld0NvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5pbmdBcnJheTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbMF0gPT09IEVYSVQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGVhdmUgJiYgbm9kZVBhc3Nlc1Rlc3RcbiAgICAgICAgICAgID8gdG9SZXN1bHQoXG4gICAgICAgICAgICAgICAgICBsZWF2ZShub2RlIGFzIGFueSwge1xuICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgY29udGFpbmluZ0FycmF5LFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiByZXN1bHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEVuc3VyZXMgYSByZXN1bHQgaXMgYW4gYEFjdGlvblR1cGxlYHNcbiAqL1xuZnVuY3Rpb24gdG9SZXN1bHQoXG4gICAgdmFsdWU6IG51bGwgfCB1bmRlZmluZWQgfCB2b2lkIHwgQWN0aW9uIHwgSW5kZXggfCBBY3Rpb25UdXBsZVxuKTogQWN0aW9uVHVwbGUge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbQ09OVElOVUVdO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gW0NPTlRJTlVFLCB2YWx1ZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFt2YWx1ZV07XG59XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgdmlzaXQgfSBmcm9tIFwiLi4vdW5pZmllZC1sYXRleC11dGlsLXZpc2l0XCI7XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgYC5fcmVuZGVySW5mb2AgcHJvcGVydHkgb24gYSBub2RlIHRvIGluY2x1ZGVcbiAqIHdoYXRldmVyIGhhcyBiZWVuIHN1cHBsaWVkIHRvIGByZW5kZXJJbmZvYC4gSWYgYHJlbmRlckluZm9gXG4gKiBpcyBudWxsLCBubyB1cGRhdGUgaXMgcGVyZm9ybWVkLlxuICpcbiAqICpUaGlzIG9wZXJhdGlvbiBtdXRhdGVzIGBub2RlYCpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVJlbmRlckluZm8oXG4gICAgbm9kZTogQXN0Lk5vZGUsXG4gICAgcmVuZGVySW5mbzogb2JqZWN0IHwgbnVsbCB8IHVuZGVmaW5lZFxuKSB7XG4gICAgaWYgKHJlbmRlckluZm8gIT0gbnVsbCkge1xuICAgICAgICBub2RlLl9yZW5kZXJJbmZvID0geyAuLi4obm9kZS5fcmVuZGVySW5mbyB8fCB7fSksIC4uLnJlbmRlckluZm8gfTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbnkgYF9yZW5kZXJJbmZvYCBhbmQgYHBvc2l0aW9uYCB0YWdzIHByZXNlbnQgaW4gdGhlIEFTVC4gVGhpc1xuICogb3BlcmF0aW9uIGlzIF9kZXN0cnVjdGl2ZV8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltUmVuZGVySW5mbyhhc3Q6IEFzdC5Bc3QpIHtcbiAgICB2aXNpdChhc3QsIChub2RlKSA9PiB7XG4gICAgICAgIGRlbGV0ZSBub2RlLl9yZW5kZXJJbmZvO1xuICAgICAgICBkZWxldGUgbm9kZS5wb3NpdGlvbjtcbiAgICB9KTtcbiAgICByZXR1cm4gYXN0O1xufVxuXG4vLyBOT1RFOiBUaGUgZG9jc3RyaW5nIGNvbW1lbnQgbXVzdCBiZSB0aGUgbGFzdCBpdGVtIGluIHRoZSBpbmRleC50cyBmaWxlIVxuLyoqXG4gKiAjIyBXaGF0IGlzIHRoaXM/XG4gKlxuICogRnVuY3Rpb25zIHRvIGhlbHAgbW9kaWZ5IHRoZSBgX3JlbmRlckluZm9gIG9mIGEgYHVuaWZpZWQtbGF0ZXhgIEFic3RyYWN0IFN5bnRheCBUcmVlIChBU1QpLlxuICpcbiAqICMjIFdoZW4gc2hvdWxkIEkgdXNlIHRoaXM/XG4gKlxuICogSWYgeW91IHdhbnQgdG8gY29tcGFyZSB0aGUgc3RydWN0dXJlIG9mIGFuIEFTVCB3aXRob3V0IHBvc2l0aW9uIGluZm9ybWF0aW9uIG9yIGV4dHJhIGluZm9ybWF0aW9uXG4gKiB0aGF0IGlzIGtlcHQgZm9yIHByZXR0eS1wcmludGluZywgdGhlc2UgZnVuY3Rpb25zIGNhbiBiZSB1c2VkIHRvIHJlbW92ZS9tb2RpZnkgdGhlIGBfcmVuZGVySW5mb2BcbiAqIG9mIGFuIGBBc3QuTm9kZWAuXG4gKi9cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==