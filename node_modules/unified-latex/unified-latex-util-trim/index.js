/******/ var __webpack_modules__ = ({

/***/ "./unified-latex-util-match/index.ts":
/*!*******************************************!*\
  !*** ./unified-latex-util-match/index.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "anyEnvironment": () => (/* binding */ anyEnvironment),
/* harmony export */   "anyMacro": () => (/* binding */ anyMacro),
/* harmony export */   "anyString": () => (/* binding */ anyString),
/* harmony export */   "argument": () => (/* binding */ argument),
/* harmony export */   "blankArgument": () => (/* binding */ blankArgument),
/* harmony export */   "comment": () => (/* binding */ comment),
/* harmony export */   "environment": () => (/* binding */ environment),
/* harmony export */   "group": () => (/* binding */ group),
/* harmony export */   "macro": () => (/* binding */ macro),
/* harmony export */   "match": () => (/* reexport safe */ _libs_match__WEBPACK_IMPORTED_MODULE_0__.match),
/* harmony export */   "math": () => (/* binding */ math),
/* harmony export */   "parbreak": () => (/* binding */ parbreak),
/* harmony export */   "string": () => (/* binding */ string),
/* harmony export */   "whitespace": () => (/* binding */ whitespace)
/* harmony export */ });
/* harmony import */ var _libs_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/match */ "./unified-latex-util-match/libs/match.ts");


const { anyEnvironment, anyMacro, anyString, argument, blankArgument, comment, environment, group, macro, math, parbreak, string, whitespace, } = _libs_match__WEBPACK_IMPORTED_MODULE_0__.match;
// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to match different `Ast.Node` types in a `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you need a type-guard to ensure a node is of a certain type; for example, during a call to `unified-latex-until-visit`.
 */


/***/ }),

/***/ "./unified-latex-util-match/libs/match.ts":
/*!************************************************!*\
  !*** ./unified-latex-util-match/libs/match.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "match": () => (/* binding */ match)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-print-raw */ "./unified-latex-util-print-raw/index.ts");

/**
 * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros
 * and generates a hash for quick lookup.
 */
function createMacroMatcher(macros) {
    // We first make sure we have a record type with keys being the macro's contents
    const macrosHash = Array.isArray(macros)
        ? macros.length > 0
            ? typeof macros[0] === "string"
                ? Object.fromEntries(macros.map((macro) => {
                    if (typeof macro !== "string") {
                        throw new Error("Wrong branch of map function");
                    }
                    return [macro, {}];
                }))
                : Object.fromEntries(macros.map((macro) => {
                    if (typeof macro === "string") {
                        throw new Error("Wrong branch of map function");
                    }
                    if (macro.escapeToken != null) {
                        return [
                            macro.content,
                            { escapeToken: macro.escapeToken },
                        ];
                    }
                    return [macro.content, {}];
                }))
            : {}
        : macros;
    return function matchAgainstMacros(node) {
        if (node == null || node.type !== "macro") {
            return false;
        }
        // At this point we have a macro type
        const spec = macrosHash[node.content];
        if (!spec) {
            return false;
        }
        if (typeof spec === "object" && "escapeToken" in spec) {
            return (spec.escapeToken == null ||
                spec.escapeToken === node.escapeToken);
        }
        return true;
    };
}
/**
 * Creates a macro matching function that uses a `SpecialMacroSpec` or list of macros
 * and generates a hash for quick lookup.
 */
function createEnvironmentMatcher(macros) {
    // We first make sure we have a record type with keys being the macro's contents
    const environmentsHash = Array.isArray(macros)
        ? Object.fromEntries(macros.map((str) => {
            return [str, {}];
        }))
        : macros;
    return function matchAgainstEnvironments(node) {
        if (!match.anyEnvironment(node)) {
            return false;
        }
        // At this point we have an environment type
        const envName = (0,_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)(node.env);
        const spec = environmentsHash[envName];
        if (!spec) {
            return false;
        }
        return true;
    };
}
/**
 * Functions to match different types of nodes.
 */
const match = {
    macro(node, macroName) {
        if (node == null) {
            return false;
        }
        return (node.type === "macro" &&
            (macroName == null || node.content === macroName));
    },
    anyMacro(node) {
        return match.macro(node);
    },
    environment(node, envName) {
        if (node == null) {
            return false;
        }
        return ((node.type === "environment" || node.type === "mathenv") &&
            (envName == null || (0,_unified_latex_util_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)(node.env) === envName));
    },
    anyEnvironment(node) {
        return match.environment(node);
    },
    comment(node) {
        if (node == null) {
            return false;
        }
        return node.type === "comment";
    },
    parbreak(node) {
        if (node == null) {
            return false;
        }
        return node.type === "parbreak";
    },
    whitespace(node) {
        if (node == null) {
            return false;
        }
        return node.type === "whitespace";
    },
    /**
     * Matches whitespace or a comment with leading whitespace.
     */
    whitespaceLike(node) {
        if (node == null) {
            return false;
        }
        return (node.type === "whitespace" ||
            (node.type === "whitespace" && node.leadingWhitespace === true));
    },
    string(node, value) {
        if (node == null) {
            return false;
        }
        return (node.type === "string" && (value == null || node.content === value));
    },
    anyString(node) {
        return match.string(node);
    },
    group(node) {
        if (node == null) {
            return false;
        }
        return node.type === "group";
    },
    argument(node) {
        if (node == null) {
            return false;
        }
        return node.type === "argument";
    },
    blankArgument(node) {
        if (!match.argument(node)) {
            return false;
        }
        return (node.openMark === "" &&
            node.closeMark === "" &&
            node.content.length === 0);
    },
    math(node) {
        if (node == null) {
            return false;
        }
        return node.type === "displaymath" || node.type === "inlinemath";
    },
    createMacroMatcher,
    createEnvironmentMatcher,
};


/***/ }),

/***/ "./unified-latex-util-print-raw/index.ts":
/*!***********************************************!*\
  !*** ./unified-latex-util-print-raw/index.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linebreak": () => (/* reexport safe */ _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__.linebreak),
/* harmony export */   "printRaw": () => (/* reexport safe */ _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__.printRaw)
/* harmony export */ });
/* harmony import */ var _libs_print_raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/print-raw */ "./unified-latex-util-print-raw/libs/print-raw.ts");

// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to print a `unified-latex` Abstract Syntax Tree (AST) to a string.
 *
 * ## When should I use this?
 *
 * If you want to directly print an `Ast.Ast` to a string without any pretty printing or formatting.
 */


/***/ }),

/***/ "./unified-latex-util-print-raw/libs/print-raw.ts":
/*!********************************************************!*\
  !*** ./unified-latex-util-print-raw/libs/print-raw.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "linebreak": () => (/* binding */ linebreak),
/* harmony export */   "printRaw": () => (/* binding */ printRaw)
/* harmony export */ });
const linebreak = Symbol("linebreak");
const ESCAPE = "\\";
/**
 * Renders the AST to an array inserting `linebreak` where needed;
 * This array may be nested.
 *
 * @param {*} node
 */
function _printRaw(node) {
    if (typeof node === "string") {
        return [node];
    }
    if (Array.isArray(node)) {
        return [].concat(...node.map((n) => _printRaw(n)));
    }
    // tmp variables
    let argsString, escape;
    switch (node.type) {
        case "root":
            return _printRaw(node.content);
        case "argument":
            return [node.openMark, ..._printRaw(node.content), node.closeMark];
        case "comment":
            var suffix = node.suffixParbreak ? "" : linebreak;
            // A comment is responsible for printing its own leading whitespace
            var leadingWhitespace = "";
            if (node.sameline && node.leadingWhitespace) {
                leadingWhitespace = " ";
            }
            if (node.sameline) {
                return [
                    leadingWhitespace,
                    "%",
                    ..._printRaw(node.content),
                    suffix,
                ];
            }
            return [linebreak, "%", ..._printRaw(node.content), suffix];
        case "environment":
        case "mathenv":
        case "verbatim":
            var env = _printRaw(node.env);
            var envStart = [ESCAPE + "begin{", ...env, "}"];
            var envEnd = [ESCAPE + "end{", ...env, "}"];
            argsString =
                node.args == null ? [] : _printRaw(node.args);
            return [
                ...envStart,
                ...argsString,
                ..._printRaw(node.content),
                ...envEnd,
            ];
        case "displaymath":
            return [ESCAPE + "[", ..._printRaw(node.content), ESCAPE + "]"];
        case "group":
            return ["{", ..._printRaw(node.content), "}"];
        case "inlinemath":
            return ["$", ..._printRaw(node.content), "$"];
        case "macro":
            argsString = node.args == null ? [] : _printRaw(node.args);
            escape = node.escapeToken == null ? ESCAPE : node.escapeToken;
            return [escape, ..._printRaw(node.content), ...argsString];
        case "parbreak":
            return [linebreak, linebreak];
        case "string":
            return [node.content];
        case "verb":
            return [
                ESCAPE,
                node.env,
                node.escape,
                ..._printRaw(node.content),
                node.escape,
            ];
        case "whitespace":
            return [" "];
        default:
            console.warn("Cannot find render for node ", node, `(of type ${typeof node})`);
            return ["" + node];
    }
}
function printRaw(node, options) {
    const asArray = options != null ? options.asArray : false;
    const printedTokens = _printRaw(node);
    if (asArray) {
        return printedTokens;
    }
    return printedTokens.map((x) => (x === linebreak ? "\n" : x)).join("");
}


/***/ }),

/***/ "./unified-latex-util-trim/libs/has-whitespace-equivalent.ts":
/*!*******************************************************************!*\
  !*** ./unified-latex-util-trim/libs/has-whitespace-equivalent.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hasWhitespaceEquivalent": () => (/* binding */ hasWhitespaceEquivalent)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");

/**
 * Returns whether the array has whitespace at the start/end. Comments with `leadingWhitespace === true`
 * are counted as whitespace. Other comments are ignored.
 */
function hasWhitespaceEquivalent(nodes) {
    let start = false;
    let end = false;
    for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(node)) {
            // A comment with leading whitespace will render with leading whitespace,
            // so if we encounter one, we should consider ourselves to have leading whitespace.
            if (node.leadingWhitespace) {
                start = true;
                break;
            }
            continue;
        }
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node)) {
            start = true;
        }
        break;
    }
    for (let j = nodes.length - 1; j >= 0; j--) {
        const node = nodes[j];
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(node)) {
            if (node.leadingWhitespace) {
                end = true;
                break;
            }
            continue;
        }
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node)) {
            end = true;
        }
        break;
    }
    return { start, end };
}


/***/ }),

/***/ "./unified-latex-util-trim/libs/trim.ts":
/*!**********************************************!*\
  !*** ./unified-latex-util-trim/libs/trim.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "trim": () => (/* binding */ trim),
/* harmony export */   "trimEnd": () => (/* binding */ trimEnd),
/* harmony export */   "trimStart": () => (/* binding */ trimStart)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");

/**
 * Trims whitespace and parbreaks from the start and end
 * of an array. The number of trimmed nodes is returned.
 * Special care is taken to preserve comments, though any whitespace
 * before the first comment(s) or after the last comment(s) is trimmed.
 */
function trim(nodes) {
    if (!Array.isArray(nodes)) {
        console.warn("Trying to trim a non-array ast", nodes);
        return nodes;
    }
    const { trimmedStart } = trimStart(nodes);
    const { trimmedEnd } = trimEnd(nodes);
    return { trimmedStart, trimmedEnd };
}
/**
 * Trim whitespace and parbreaks from the left of an array.
 */
function trimStart(nodes) {
    const { start } = amountOfLeadingAndTrailingWhitespace(nodes);
    nodes.splice(0, start);
    // If there are comments at the start, they might have leading whitespace.
    // This leading whitespace should be trimmed
    for (const leadingToken of nodes) {
        if (!_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(leadingToken)) {
            break;
        }
        if (leadingToken.leadingWhitespace || leadingToken.sameline) {
            leadingToken.leadingWhitespace = false;
            // We remove the position information from this token to indicate that we've edited it
            delete leadingToken.position;
        }
        // Special care must be taken. If the comment was on the same line as a
        // parskip, it will no longer be on the same line after the trimming.
        // Thus, we must modify the comment.
        if (start > 0 && leadingToken.sameline) {
            leadingToken.sameline = false;
            delete leadingToken.position;
        }
    }
    return { trimmedStart: start };
}
/**
 * Trim whitespace and parbreaks from the right of an array.
 */
function trimEnd(nodes) {
    const { end } = amountOfLeadingAndTrailingWhitespace(nodes);
    nodes.splice(nodes.length - end, end);
    // Trim off any spaces belonging to trailing comments
    for (let i = nodes.length - 1; i >= 0; i--) {
        const trailingToken = nodes[i];
        if (!_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(trailingToken)) {
            break;
        }
        // We don't trim spaces before trailing same-line comments. This is a stylistic choice
        // so that
        // `foo %xxx` does not become `foo%xxx`.
        // The latter is strictly "correct" for a trim function, but it is prettier to format
        // code preserving the space before the sameline comment
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(trailingToken) &&
            trailingToken.leadingWhitespace &&
            !trailingToken.sameline) {
            trailingToken.leadingWhitespace = false;
            delete trailingToken.position;
        }
    }
    return { trimmedEnd: end };
}
/**
 * Returns the number of whitespace/parbreak nodes at the start and end of an array.
 */
function amountOfLeadingAndTrailingWhitespace(ast) {
    let start = 0;
    let end = 0;
    for (const node of ast) {
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.parbreak(node)) {
            start++;
        }
        else {
            break;
        }
    }
    if (start === ast.length) {
        return { start, end: 0 };
    }
    // Find the padding on the right
    for (let i = ast.length - 1; i >= 0; i--) {
        const node = ast[i];
        if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.whitespace(node) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.parbreak(node)) {
            end++;
        }
        else {
            break;
        }
    }
    return { start, end };
}


/***/ }),

/***/ "./unified-latex-util-trim/libs/unified-latex-trim-environment-contents.ts":
/*!*********************************************************************************!*\
  !*** ./unified-latex-util-trim/libs/unified-latex-trim-environment-contents.ts ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unifiedLatexTrimEnvironmentContents": () => (/* binding */ unifiedLatexTrimEnvironmentContents)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");
/* harmony import */ var _unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../unified-latex-util-visit */ "./unified-latex-util-visit/index.ts");
/* harmony import */ var _trim__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./trim */ "./unified-latex-util-trim/libs/trim.ts");



/**
 * Unified plugin to trim the whitespace from the start/end of any environments, including
 * math environments.
 */
const unifiedLatexTrimEnvironmentContents = function unifiedLatexTrimEnvironmentContents() {
    return (tree) => {
        (0,_unified_latex_util_visit__WEBPACK_IMPORTED_MODULE_1__.visit)(tree, (node) => {
            if (!(_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.math(node) || _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.anyEnvironment(node))) {
                return;
            }
            // If the first thing in the environment is a sameline comment,
            // we actually want to start trimming *after* it.
            let firstNode = node.content[0];
            if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.comment(firstNode) && firstNode.sameline) {
                firstNode.suffixParbreak = false;
                (0,_trim__WEBPACK_IMPORTED_MODULE_2__.trimEnd)(node.content);
                // We play a nasty trick here. This call to `trimStart`
                // will actually modify `node.content` if `node.content.slice(1)` starts
                // with a comment that has leading whitespace (it will remove that whitespace).
                // However, it won't remove any elements from `node.content`; we need
                // to do that ourselves.
                const { trimmedStart } = (0,_trim__WEBPACK_IMPORTED_MODULE_2__.trimStart)(node.content.slice(1));
                node.content.splice(1, trimmedStart);
            }
            else {
                (0,_trim__WEBPACK_IMPORTED_MODULE_2__.trim)(node.content);
            }
        });
    };
};


/***/ }),

/***/ "./unified-latex-util-trim/libs/unified-latex-trim-root.ts":
/*!*****************************************************************!*\
  !*** ./unified-latex-util-trim/libs/unified-latex-trim-root.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "unifiedLatexTrimRoot": () => (/* binding */ unifiedLatexTrimRoot)
/* harmony export */ });
/* harmony import */ var _trim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./trim */ "./unified-latex-util-trim/libs/trim.ts");

/**
 * Unified plugin to trim the whitespace from the start/end of the root element.
 */
const unifiedLatexTrimRoot = function unifiedLatexTrimRoot() {
    return (tree) => {
        (0,_trim__WEBPACK_IMPORTED_MODULE_0__.trim)(tree.content);
    };
};


/***/ }),

/***/ "./unified-latex-util-visit/index.ts":
/*!*******************************************!*\
  !*** ./unified-latex-util-visit/index.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CONTINUE": () => (/* reexport safe */ _libs_visit__WEBPACK_IMPORTED_MODULE_0__.CONTINUE),
/* harmony export */   "EXIT": () => (/* reexport safe */ _libs_visit__WEBPACK_IMPORTED_MODULE_0__.EXIT),
/* harmony export */   "SKIP": () => (/* reexport safe */ _libs_visit__WEBPACK_IMPORTED_MODULE_0__.SKIP),
/* harmony export */   "visit": () => (/* reexport safe */ _libs_visit__WEBPACK_IMPORTED_MODULE_0__.visit)
/* harmony export */ });
/* harmony import */ var _libs_visit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/visit */ "./unified-latex-util-visit/libs/visit.ts");

// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to traverse a `unified-latex` Abstract Syntax Tree (AST). `visit` is
 * very similar to [estree-util-visit](https://github.com/syntax-tree/estree-util-visit).
 *
 * ## When should I use this?
 *
 * If you want to recursively replace particular AST nodes.
 */


/***/ }),

/***/ "./unified-latex-util-visit/libs/list-math-children.ts":
/*!*************************************************************!*\
  !*** ./unified-latex-util-visit/libs/list-math-children.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "listMathChildren": () => (/* binding */ listMathChildren)
/* harmony export */ });
/* harmony import */ var _unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../unified-latex-util-match */ "./unified-latex-util-match/index.ts");

/**
 * List all props of the current node that should be processed
 * in math mode or not in math mode. If math mode is not specified in the node's render
 * info, empty lists are returned.
 *
 * For example `\text{foo}` will report that `args` should *not* be processed in math mode,
 * since it's contents should always be processed in text mode.
 */
function listMathChildren(node) {
    const NULL_RETURN = { enter: [], leave: [] };
    if (Array.isArray(node)) {
        return NULL_RETURN;
    }
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.math(node)) {
        // When we enter a math environment, our content is always
        // considered math mode
        return { enter: ["content"], leave: [] };
    }
    const renderInfo = node._renderInfo || {};
    if (renderInfo.inMathMode == null) {
        return NULL_RETURN;
    }
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.macro(node)) {
        if (renderInfo.inMathMode === true) {
            return { enter: ["args"], leave: [] };
        }
        else if (renderInfo.inMathMode === false) {
            return { enter: [], leave: ["args"] };
        }
    }
    if (_unified_latex_util_match__WEBPACK_IMPORTED_MODULE_0__.match.environment(node)) {
        if (renderInfo.inMathMode === true) {
            return { enter: ["content"], leave: [] };
        }
        else {
            return { enter: [], leave: ["content"] };
        }
    }
    return NULL_RETURN;
}


/***/ }),

/***/ "./unified-latex-util-visit/libs/visit.ts":
/*!************************************************!*\
  !*** ./unified-latex-util-visit/libs/visit.ts ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CONTINUE": () => (/* binding */ CONTINUE),
/* harmony export */   "EXIT": () => (/* binding */ EXIT),
/* harmony export */   "SKIP": () => (/* binding */ SKIP),
/* harmony export */   "visit": () => (/* binding */ visit)
/* harmony export */ });
/* harmony import */ var _list_math_children__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./list-math-children */ "./unified-latex-util-visit/libs/list-math-children.ts");

/**
 * Continue traversing as normal
 */
const CONTINUE = Symbol("continue");
/**
 * Do not traverse this nodeâ€™s children
 */
const SKIP = Symbol("skip");
/**
 * Stop traversing immediately
 */
const EXIT = Symbol("exit");
const DEFAULT_CONTEXT = {
    inMathMode: false,
    hasMathModeAncestor: false,
};
/**
 * Visit children of tree which pass a test
 *
 * @param {Node} tree Abstract syntax tree to walk
 * @param {Visitor|Visitors} [visitor] Function to run for each node
 */
function visit(tree, visitor, options) {
    const { startingContext = DEFAULT_CONTEXT, test = () => true, includeArrays = false, } = options || {};
    let enter;
    let leave;
    if (typeof visitor === "function") {
        enter = visitor;
    }
    else if (visitor && typeof visitor === "object") {
        enter = visitor.enter;
        leave = visitor.leave;
    }
    walk(tree, {
        key: undefined,
        index: undefined,
        parents: [],
        containingArray: undefined,
        context: Object.assign({}, startingContext),
    });
    /**
     * @param {Node} node
     * @param {string?} key
     * @param {number?} index
     * @param {Array.<Node>} parents
     */
    function walk(node, { key, index, parents, context, containingArray }) {
        const nodePassesTest = includeArrays
            ? test(node, { key, index, parents, context, containingArray })
            : !Array.isArray(node) &&
                test(node, { key, index, parents, context, containingArray });
        const result = enter && nodePassesTest
            ? toResult(enter(node, {
                key,
                index,
                parents,
                context,
                containingArray,
            }))
            : [CONTINUE];
        if (result[0] === EXIT) {
            return result;
        }
        if (result[0] === SKIP) {
            return leave && nodePassesTest
                ? toResult(leave(node, {
                    key,
                    index,
                    parents,
                    context,
                    containingArray,
                }))
                : result;
        }
        if (Array.isArray(node)) {
            // The `value` array might be modified in place as we traverse it, so
            // we use a traditional for loop.
            for (let index = 0; index > -1 && index < node.length; index++) {
                const item = node[index];
                const result = walk(item, {
                    key,
                    index,
                    parents,
                    context,
                    containingArray: node,
                });
                if (result[0] === EXIT) {
                    return result;
                }
                if (typeof result[1] === "number") {
                    // The for loop will increment i every pass. However,
                    // if an index was returned, that's where we want to start next time.
                    index = result[1] - 1;
                }
            }
        }
        else {
            // We don't want to recursively apply to the `content`
            // of all types (e.g., comments and macros), so specify
            // a blacklist.
            let childProps = ["content", "args"];
            switch (node.type) {
                case "macro":
                    childProps = ["args"];
                    break;
                case "comment":
                case "string":
                case "verb":
                case "verbatim":
                    childProps = [];
                    break;
                default:
                    break;
            }
            const mathModeProps = (0,_list_math_children__WEBPACK_IMPORTED_MODULE_0__.listMathChildren)(node);
            for (const key of childProps) {
                const value = node[key];
                const grandparents = [node].concat(parents);
                if (value == null) {
                    continue;
                }
                // We may switch in/out of math mode as we pass to node[key]
                const newContext = Object.assign({}, context);
                if (mathModeProps.enter.includes(key)) {
                    newContext.inMathMode = true;
                    newContext.hasMathModeAncestor = true;
                }
                else if (mathModeProps.leave.includes(key)) {
                    newContext.inMathMode = false;
                }
                const result = walk(value, {
                    key,
                    index: undefined,
                    parents: grandparents,
                    context: newContext,
                    containingArray: undefined,
                });
                if (result[0] === EXIT) {
                    return result;
                }
            }
        }
        return leave && nodePassesTest
            ? toResult(leave(node, {
                key,
                index,
                parents,
                context,
                containingArray,
            }))
            : result;
    }
}
/**
 * Ensures a result is an `ActionTuple`s
 */
function toResult(value) {
    if (value == null) {
        return [CONTINUE];
    }
    if (Array.isArray(value)) {
        return value;
    }
    if (typeof value === "number") {
        return [CONTINUE, value];
    }
    return [value];
}


/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!******************************************!*\
  !*** ./unified-latex-util-trim/index.ts ***!
  \******************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hasWhitespaceEquivalent": () => (/* reexport safe */ _libs_has_whitespace_equivalent__WEBPACK_IMPORTED_MODULE_3__.hasWhitespaceEquivalent),
/* harmony export */   "trim": () => (/* reexport safe */ _libs_trim__WEBPACK_IMPORTED_MODULE_0__.trim),
/* harmony export */   "trimEnd": () => (/* reexport safe */ _libs_trim__WEBPACK_IMPORTED_MODULE_0__.trimEnd),
/* harmony export */   "trimStart": () => (/* reexport safe */ _libs_trim__WEBPACK_IMPORTED_MODULE_0__.trimStart),
/* harmony export */   "unifiedLatexTrimEnvironmentContents": () => (/* reexport safe */ _libs_unified_latex_trim_environment_contents__WEBPACK_IMPORTED_MODULE_1__.unifiedLatexTrimEnvironmentContents),
/* harmony export */   "unifiedLatexTrimRoot": () => (/* reexport safe */ _libs_unified_latex_trim_root__WEBPACK_IMPORTED_MODULE_2__.unifiedLatexTrimRoot)
/* harmony export */ });
/* harmony import */ var _libs_trim__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/trim */ "./unified-latex-util-trim/libs/trim.ts");
/* harmony import */ var _libs_unified_latex_trim_environment_contents__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/unified-latex-trim-environment-contents */ "./unified-latex-util-trim/libs/unified-latex-trim-environment-contents.ts");
/* harmony import */ var _libs_unified_latex_trim_root__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./libs/unified-latex-trim-root */ "./unified-latex-util-trim/libs/unified-latex-trim-root.ts");
/* harmony import */ var _libs_has_whitespace_equivalent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./libs/has-whitespace-equivalent */ "./unified-latex-util-trim/libs/has-whitespace-equivalent.ts");




// NOTE: The docstring comment must be the last item in the index.ts file!
/**
 * ## What is this?
 *
 * Functions to help modify a `unified-latex` Abstract Syntax Tree (AST).
 *
 * ## When should I use this?
 *
 * If you want to remove whitespace from the ends of an array of nodes.
 *
 * Note that whitespace can come from a `Ast.Whitespace` node or from an
 * `Ast.Comment` node that has leading whitespace. These functions take care
 * to deal with both situations.
 */

})();

var __webpack_exports__hasWhitespaceEquivalent = __webpack_exports__.hasWhitespaceEquivalent;
var __webpack_exports__trim = __webpack_exports__.trim;
var __webpack_exports__trimEnd = __webpack_exports__.trimEnd;
var __webpack_exports__trimStart = __webpack_exports__.trimStart;
var __webpack_exports__unifiedLatexTrimEnvironmentContents = __webpack_exports__.unifiedLatexTrimEnvironmentContents;
var __webpack_exports__unifiedLatexTrimRoot = __webpack_exports__.unifiedLatexTrimRoot;
export { __webpack_exports__hasWhitespaceEquivalent as hasWhitespaceEquivalent, __webpack_exports__trim as trim, __webpack_exports__trimEnd as trimEnd, __webpack_exports__trimStart as trimStart, __webpack_exports__unifiedLatexTrimEnvironmentContents as unifiedLatexTrimEnvironmentContents, __webpack_exports__unifiedLatexTrimRoot as unifiedLatexTrimRoot };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0wsT0FBTztnQkFDUCxPQUFPO2dCQUNQLGVBQWU7YUFDbEIsQ0FBQyxDQUNMO1lBQ0gsQ0FBQyxDQUFDLE1BQU0sQ0FBQztJQUNqQixDQUFDO0FBQ0wsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBUyxRQUFRLENBQ2IsS0FBNkQ7SUFFN0QsSUFBSSxLQUFLLElBQUksSUFBSSxFQUFFO1FBQ2YsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0tBQ3JCO0lBRUQsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ3RCLE9BQU8sS0FBSyxDQUFDO0tBQ2hCO0lBRUQsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7UUFDM0IsT0FBTyxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQztLQUM1QjtJQUVELE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNuQixDQUFDOzs7Ozs7O1NDblVEO1NBQ0E7O1NBRUE7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7O1NBRUE7U0FDQTs7U0FFQTtTQUNBO1NBQ0E7Ozs7O1VDdEJBO1VBQ0E7VUFDQTtVQUNBO1VBQ0EseUNBQXlDLHdDQUF3QztVQUNqRjtVQUNBO1VBQ0E7Ozs7O1VDUEE7Ozs7O1VDQUE7VUFDQTtVQUNBO1VBQ0EsdURBQXVELGlCQUFpQjtVQUN4RTtVQUNBLGdEQUFnRCxhQUFhO1VBQzdEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ040QjtBQUNtQztBQUNoQjtBQUNFO0FBRWpELDBFQUEwRTtBQUMxRTs7Ozs7Ozs7Ozs7O0dBWUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoL2luZGV4LnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtbWF0Y2gvbGlicy9tYXRjaC50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXByaW50LXJhdy9pbmRleC50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXByaW50LXJhdy9saWJzL3ByaW50LXJhdy50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXRyaW0vbGlicy9oYXMtd2hpdGVzcGFjZS1lcXVpdmFsZW50LnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtdHJpbS9saWJzL3RyaW0udHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC10cmltL2xpYnMvdW5pZmllZC1sYXRleC10cmltLWVudmlyb25tZW50LWNvbnRlbnRzLnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtdHJpbS9saWJzL3VuaWZpZWQtbGF0ZXgtdHJpbS1yb290LnRzIiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtdmlzaXQvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC8uL3VuaWZpZWQtbGF0ZXgtdXRpbC12aXNpdC9saWJzL2xpc3QtbWF0aC1jaGlsZHJlbi50cyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4Ly4vdW5pZmllZC1sYXRleC11dGlsLXZpc2l0L2xpYnMvdmlzaXQudHMiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4L3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly91bmlmaWVkLWxhdGV4L3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vdW5pZmllZC1sYXRleC93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL3VuaWZpZWQtbGF0ZXgvLi91bmlmaWVkLWxhdGV4LXV0aWwtdHJpbS9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtYXRjaCB9IGZyb20gXCIuL2xpYnMvbWF0Y2hcIjtcblxuZXhwb3J0IHsgbWF0Y2ggfTtcblxuZXhwb3J0IGNvbnN0IHtcbiAgICBhbnlFbnZpcm9ubWVudCxcbiAgICBhbnlNYWNybyxcbiAgICBhbnlTdHJpbmcsXG4gICAgYXJndW1lbnQsXG4gICAgYmxhbmtBcmd1bWVudCxcbiAgICBjb21tZW50LFxuICAgIGVudmlyb25tZW50LFxuICAgIGdyb3VwLFxuICAgIG1hY3JvLFxuICAgIG1hdGgsXG4gICAgcGFyYnJlYWssXG4gICAgc3RyaW5nLFxuICAgIHdoaXRlc3BhY2UsXG59ID0gbWF0Y2g7XG5cbi8vIE5PVEU6IFRoZSBkb2NzdHJpbmcgY29tbWVudCBtdXN0IGJlIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIGluZGV4LnRzIGZpbGUhXG4vKipcbiAqICMjIFdoYXQgaXMgdGhpcz9cbiAqXG4gKiBGdW5jdGlvbnMgdG8gbWF0Y2ggZGlmZmVyZW50IGBBc3QuTm9kZWAgdHlwZXMgaW4gYSBgdW5pZmllZC1sYXRleGAgQWJzdHJhY3QgU3ludGF4IFRyZWUgKEFTVCkuXG4gKlxuICogIyMgV2hlbiBzaG91bGQgSSB1c2UgdGhpcz9cbiAqXG4gKiBJZiB5b3UgbmVlZCBhIHR5cGUtZ3VhcmQgdG8gZW5zdXJlIGEgbm9kZSBpcyBvZiBhIGNlcnRhaW4gdHlwZTsgZm9yIGV4YW1wbGUsIGR1cmluZyBhIGNhbGwgdG8gYHVuaWZpZWQtbGF0ZXgtdW50aWwtdmlzaXRgLlxuICovXG4iLCJpbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IEVudkluZm8sIE1hY3JvSW5mbywgTWFjcm9JbmZvUmVjb3JkIH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IHByaW50UmF3IH0gZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdXRpbC1wcmludC1yYXdcIjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFjcm8gbWF0Y2hpbmcgZnVuY3Rpb24gdGhhdCB1c2VzIGEgYFNwZWNpYWxNYWNyb1NwZWNgIG9yIGxpc3Qgb2YgbWFjcm9zXG4gKiBhbmQgZ2VuZXJhdGVzIGEgaGFzaCBmb3IgcXVpY2sgbG9va3VwLlxuICovXG5mdW5jdGlvbiBjcmVhdGVNYWNyb01hdGNoZXIoXG4gICAgbWFjcm9zOiBBc3QuTWFjcm9bXSB8IHN0cmluZ1tdIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbikge1xuICAgIC8vIFdlIGZpcnN0IG1ha2Ugc3VyZSB3ZSBoYXZlIGEgcmVjb3JkIHR5cGUgd2l0aCBrZXlzIGJlaW5nIHRoZSBtYWNybydzIGNvbnRlbnRzXG4gICAgY29uc3QgbWFjcm9zSGFzaCA9IEFycmF5LmlzQXJyYXkobWFjcm9zKVxuICAgICAgICA/IG1hY3Jvcy5sZW5ndGggPiAwXG4gICAgICAgICAgICA/IHR5cGVvZiBtYWNyb3NbMF0gPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgICAgICAgICAgICBtYWNyb3MubWFwKChtYWNybykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1hY3JvICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBicmFuY2ggb2YgbWFwIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbbWFjcm8sIHt9XSBhcyBbc3RyaW5nLCBNYWNyb0luZm9dO1xuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgICAgICAgICAgICAgICAgbWFjcm9zLm1hcCgobWFjcm8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtYWNybyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV3JvbmcgYnJhbmNoIG9mIG1hcCBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFjcm8uZXNjYXBlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWNyby5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgZXNjYXBlVG9rZW46IG1hY3JvLmVzY2FwZVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdIGFzIFtzdHJpbmcsIE1hY3JvSW5mb107XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFttYWNyby5jb250ZW50LCB7fV0gYXMgW3N0cmluZywgTWFjcm9JbmZvXTtcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiB7fVxuICAgICAgICA6IG1hY3JvcztcblxuICAgIHJldHVybiBmdW5jdGlvbiBtYXRjaEFnYWluc3RNYWNyb3Mobm9kZTogYW55IHwgQXN0Lk1hY3JvKSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwgfHwgbm9kZS50eXBlICE9PSBcIm1hY3JvXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYSBtYWNybyB0eXBlXG4gICAgICAgIGNvbnN0IHNwZWMgPSBtYWNyb3NIYXNoW25vZGUuY29udGVudF07XG4gICAgICAgIGlmICghc3BlYykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzcGVjID09PSBcIm9iamVjdFwiICYmIFwiZXNjYXBlVG9rZW5cIiBpbiBzcGVjKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIChzcGVjIGFzIE1hY3JvSW5mb1JlY29yZCkuZXNjYXBlVG9rZW4gPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIChzcGVjIGFzIE1hY3JvSW5mb1JlY29yZCkuZXNjYXBlVG9rZW4gPT09IG5vZGUuZXNjYXBlVG9rZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBhcyBBc3QuVHlwZUd1YXJkPEFzdC5NYWNybz47XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hY3JvIG1hdGNoaW5nIGZ1bmN0aW9uIHRoYXQgdXNlcyBhIGBTcGVjaWFsTWFjcm9TcGVjYCBvciBsaXN0IG9mIG1hY3Jvc1xuICogYW5kIGdlbmVyYXRlcyBhIGhhc2ggZm9yIHF1aWNrIGxvb2t1cC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW52aXJvbm1lbnRNYXRjaGVyKG1hY3Jvczogc3RyaW5nW10gfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikge1xuICAgIC8vIFdlIGZpcnN0IG1ha2Ugc3VyZSB3ZSBoYXZlIGEgcmVjb3JkIHR5cGUgd2l0aCBrZXlzIGJlaW5nIHRoZSBtYWNybydzIGNvbnRlbnRzXG4gICAgY29uc3QgZW52aXJvbm1lbnRzSGFzaCA9IEFycmF5LmlzQXJyYXkobWFjcm9zKVxuICAgICAgICA/IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgICAgICAgbWFjcm9zLm1hcCgoc3RyKSA9PiB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW3N0ciwge31dIGFzIFtzdHJpbmcsIEVudkluZm9dO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICAgOiBtYWNyb3M7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWF0Y2hBZ2FpbnN0RW52aXJvbm1lbnRzKG5vZGU6IGFueSB8IEFzdC5FbnZpcm9ubWVudCkge1xuICAgICAgICBpZiAoIW1hdGNoLmFueUVudmlyb25tZW50KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFuIGVudmlyb25tZW50IHR5cGVcbiAgICAgICAgY29uc3QgZW52TmFtZSA9IHByaW50UmF3KG5vZGUuZW52KTtcbiAgICAgICAgY29uc3Qgc3BlYyA9IGVudmlyb25tZW50c0hhc2hbZW52TmFtZV07XG4gICAgICAgIGlmICghc3BlYykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBhcyBBc3QuVHlwZUd1YXJkPEFzdC5FbnZpcm9ubWVudD47XG59XG5cbi8qKlxuICogRnVuY3Rpb25zIHRvIG1hdGNoIGRpZmZlcmVudCB0eXBlcyBvZiBub2Rlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IG1hdGNoID0ge1xuICAgIG1hY3JvKG5vZGU6IGFueSwgbWFjcm9OYW1lPzogc3RyaW5nKTogbm9kZSBpcyBBc3QuTWFjcm8ge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG5vZGUudHlwZSA9PT0gXCJtYWNyb1wiICYmXG4gICAgICAgICAgICAobWFjcm9OYW1lID09IG51bGwgfHwgbm9kZS5jb250ZW50ID09PSBtYWNyb05hbWUpXG4gICAgICAgICk7XG4gICAgfSxcbiAgICBhbnlNYWNybyhub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5NYWNybyB7XG4gICAgICAgIHJldHVybiBtYXRjaC5tYWNybyhub2RlKTtcbiAgICB9LFxuICAgIGVudmlyb25tZW50KG5vZGU6IGFueSwgZW52TmFtZT86IHN0cmluZyk6IG5vZGUgaXMgQXN0LkVudmlyb25tZW50IHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAobm9kZS50eXBlID09PSBcImVudmlyb25tZW50XCIgfHwgbm9kZS50eXBlID09PSBcIm1hdGhlbnZcIikgJiZcbiAgICAgICAgICAgIChlbnZOYW1lID09IG51bGwgfHwgcHJpbnRSYXcobm9kZS5lbnYpID09PSBlbnZOYW1lKVxuICAgICAgICApO1xuICAgIH0sXG4gICAgYW55RW52aXJvbm1lbnQobm9kZTogYW55KTogbm9kZSBpcyBBc3QuRW52aXJvbm1lbnQge1xuICAgICAgICByZXR1cm4gbWF0Y2guZW52aXJvbm1lbnQobm9kZSk7XG4gICAgfSxcbiAgICBjb21tZW50KG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0LkNvbW1lbnQge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJjb21tZW50XCI7XG4gICAgfSxcbiAgICBwYXJicmVhayhub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5QYXJicmVhayB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZS50eXBlID09PSBcInBhcmJyZWFrXCI7XG4gICAgfSxcbiAgICB3aGl0ZXNwYWNlKG5vZGU6IGFueSk6IG5vZGUgaXMgQXN0LldoaXRlc3BhY2Uge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJ3aGl0ZXNwYWNlXCI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBNYXRjaGVzIHdoaXRlc3BhY2Ugb3IgYSBjb21tZW50IHdpdGggbGVhZGluZyB3aGl0ZXNwYWNlLlxuICAgICAqL1xuICAgIHdoaXRlc3BhY2VMaWtlKFxuICAgICAgICBub2RlOiBhbnlcbiAgICApOiBub2RlIGlzIEFzdC5XaGl0ZXNwYWNlIHwgKEFzdC5Db21tZW50ICYgeyBsZWFkaW5nV2hpdGVzcGFjZTogdHJ1ZSB9KSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgbm9kZS50eXBlID09PSBcIndoaXRlc3BhY2VcIiB8fFxuICAgICAgICAgICAgKG5vZGUudHlwZSA9PT0gXCJ3aGl0ZXNwYWNlXCIgJiYgbm9kZS5sZWFkaW5nV2hpdGVzcGFjZSA9PT0gdHJ1ZSlcbiAgICAgICAgKTtcbiAgICB9LFxuICAgIHN0cmluZyhub2RlOiBhbnksIHZhbHVlPzogc3RyaW5nKTogbm9kZSBpcyBBc3QuU3RyaW5nIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBub2RlLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgKHZhbHVlID09IG51bGwgfHwgbm9kZS5jb250ZW50ID09PSB2YWx1ZSlcbiAgICAgICAgKTtcbiAgICB9LFxuICAgIGFueVN0cmluZyhub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5TdHJpbmcge1xuICAgICAgICByZXR1cm4gbWF0Y2guc3RyaW5nKG5vZGUpO1xuICAgIH0sXG4gICAgZ3JvdXAobm9kZTogYW55KTogbm9kZSBpcyBBc3QuR3JvdXAge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJncm91cFwiO1xuICAgIH0sXG4gICAgYXJndW1lbnQobm9kZTogYW55KTogbm9kZSBpcyBBc3QuQXJndW1lbnQge1xuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJhcmd1bWVudFwiO1xuICAgIH0sXG4gICAgYmxhbmtBcmd1bWVudChub2RlOiBhbnkpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKCFtYXRjaC5hcmd1bWVudChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBub2RlLm9wZW5NYXJrID09PSBcIlwiICYmXG4gICAgICAgICAgICBub2RlLmNsb3NlTWFyayA9PT0gXCJcIiAmJlxuICAgICAgICAgICAgbm9kZS5jb250ZW50Lmxlbmd0aCA9PT0gMFxuICAgICAgICApO1xuICAgIH0sXG4gICAgbWF0aChub2RlOiBhbnkpOiBub2RlIGlzIEFzdC5EaXNwbGF5TWF0aCB8IEFzdC5JbmxpbmVNYXRoIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiZGlzcGxheW1hdGhcIiB8fCBub2RlLnR5cGUgPT09IFwiaW5saW5lbWF0aFwiO1xuICAgIH0sXG4gICAgY3JlYXRlTWFjcm9NYXRjaGVyLFxuICAgIGNyZWF0ZUVudmlyb25tZW50TWF0Y2hlcixcbn07XG4iLCJleHBvcnQgKiBmcm9tIFwiLi9saWJzL3ByaW50LXJhd1wiO1xuXG4vLyBOT1RFOiBUaGUgZG9jc3RyaW5nIGNvbW1lbnQgbXVzdCBiZSB0aGUgbGFzdCBpdGVtIGluIHRoZSBpbmRleC50cyBmaWxlIVxuLyoqXG4gKiAjIyBXaGF0IGlzIHRoaXM/XG4gKlxuICogRnVuY3Rpb25zIHRvIHByaW50IGEgYHVuaWZpZWQtbGF0ZXhgIEFic3RyYWN0IFN5bnRheCBUcmVlIChBU1QpIHRvIGEgc3RyaW5nLlxuICpcbiAqICMjIFdoZW4gc2hvdWxkIEkgdXNlIHRoaXM/XG4gKlxuICogSWYgeW91IHdhbnQgdG8gZGlyZWN0bHkgcHJpbnQgYW4gYEFzdC5Bc3RgIHRvIGEgc3RyaW5nIHdpdGhvdXQgYW55IHByZXR0eSBwcmludGluZyBvciBmb3JtYXR0aW5nLlxuICovXG4iLCJpbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcblxudHlwZSBQcmludGFibGUgPSBBc3QuTm9kZSB8IEFzdC5Bcmd1bWVudCB8IHN0cmluZztcbnR5cGUgUHJpbnRUb2tlbiA9IHN0cmluZyB8IHR5cGVvZiBsaW5lYnJlYWs7XG5cbmV4cG9ydCBjb25zdCBsaW5lYnJlYWsgPSBTeW1ib2woXCJsaW5lYnJlYWtcIik7XG5jb25zdCBFU0NBUEUgPSBcIlxcXFxcIjtcblxuLyoqXG4gKiBSZW5kZXJzIHRoZSBBU1QgdG8gYW4gYXJyYXkgaW5zZXJ0aW5nIGBsaW5lYnJlYWtgIHdoZXJlIG5lZWRlZDtcbiAqIFRoaXMgYXJyYXkgbWF5IGJlIG5lc3RlZC5cbiAqXG4gKiBAcGFyYW0geyp9IG5vZGVcbiAqL1xuZnVuY3Rpb24gX3ByaW50UmF3KG5vZGU6IFByaW50YWJsZSB8IFByaW50YWJsZVtdKTogUHJpbnRUb2tlbltdIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIChbXSBhcyBQcmludFRva2VuW10pLmNvbmNhdChcbiAgICAgICAgICAgIC4uLm5vZGUubWFwKChuOiBQcmludGFibGUpID0+IF9wcmludFJhdyhuKSlcbiAgICAgICAgKTtcbiAgICB9XG4gICAgLy8gdG1wIHZhcmlhYmxlc1xuICAgIGxldCBhcmdzU3RyaW5nLCBlc2NhcGU7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcInJvb3RcIjpcbiAgICAgICAgICAgIHJldHVybiBfcHJpbnRSYXcobm9kZS5jb250ZW50KTtcbiAgICAgICAgY2FzZSBcImFyZ3VtZW50XCI6XG4gICAgICAgICAgICByZXR1cm4gW25vZGUub3Blbk1hcmssIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLCBub2RlLmNsb3NlTWFya107XG4gICAgICAgIGNhc2UgXCJjb21tZW50XCI6XG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gbm9kZS5zdWZmaXhQYXJicmVhayA/IFwiXCIgOiBsaW5lYnJlYWs7XG4gICAgICAgICAgICAvLyBBIGNvbW1lbnQgaXMgcmVzcG9uc2libGUgZm9yIHByaW50aW5nIGl0cyBvd24gbGVhZGluZyB3aGl0ZXNwYWNlXG4gICAgICAgICAgICB2YXIgbGVhZGluZ1doaXRlc3BhY2UgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKG5vZGUuc2FtZWxpbmUgJiYgbm9kZS5sZWFkaW5nV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlID0gXCIgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5zYW1lbGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGxlYWRpbmdXaGl0ZXNwYWNlLFxuICAgICAgICAgICAgICAgICAgICBcIiVcIixcbiAgICAgICAgICAgICAgICAgICAgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksXG4gICAgICAgICAgICAgICAgICAgIHN1ZmZpeCxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtsaW5lYnJlYWssIFwiJVwiLCAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSwgc3VmZml4XTtcbiAgICAgICAgY2FzZSBcImVudmlyb25tZW50XCI6XG4gICAgICAgIGNhc2UgXCJtYXRoZW52XCI6XG4gICAgICAgIGNhc2UgXCJ2ZXJiYXRpbVwiOlxuICAgICAgICAgICAgdmFyIGVudiA9IF9wcmludFJhdyhub2RlLmVudik7XG4gICAgICAgICAgICB2YXIgZW52U3RhcnQ6IFByaW50VG9rZW5bXSA9IFtFU0NBUEUgKyBcImJlZ2lue1wiLCAuLi5lbnYsIFwifVwiXTtcbiAgICAgICAgICAgIHZhciBlbnZFbmQ6IFByaW50VG9rZW5bXSA9IFtFU0NBUEUgKyBcImVuZHtcIiwgLi4uZW52LCBcIn1cIl07XG4gICAgICAgICAgICBhcmdzU3RyaW5nID1cbiAgICAgICAgICAgICAgICAobm9kZSBhcyBhbnkpLmFyZ3MgPT0gbnVsbCA/IFtdIDogX3ByaW50UmF3KChub2RlIGFzIGFueSkuYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC4uLmVudlN0YXJ0LFxuICAgICAgICAgICAgICAgIC4uLmFyZ3NTdHJpbmcsXG4gICAgICAgICAgICAgICAgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksXG4gICAgICAgICAgICAgICAgLi4uZW52RW5kLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgY2FzZSBcImRpc3BsYXltYXRoXCI6XG4gICAgICAgICAgICByZXR1cm4gW0VTQ0FQRSArIFwiW1wiLCAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSwgRVNDQVBFICsgXCJdXCJdO1xuICAgICAgICBjYXNlIFwiZ3JvdXBcIjpcbiAgICAgICAgICAgIHJldHVybiBbXCJ7XCIsIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLCBcIn1cIl07XG4gICAgICAgIGNhc2UgXCJpbmxpbmVtYXRoXCI6XG4gICAgICAgICAgICByZXR1cm4gW1wiJFwiLCAuLi5fcHJpbnRSYXcobm9kZS5jb250ZW50KSwgXCIkXCJdO1xuICAgICAgICBjYXNlIFwibWFjcm9cIjpcbiAgICAgICAgICAgIGFyZ3NTdHJpbmcgPSBub2RlLmFyZ3MgPT0gbnVsbCA/IFtdIDogX3ByaW50UmF3KG5vZGUuYXJncyk7XG4gICAgICAgICAgICBlc2NhcGUgPSBub2RlLmVzY2FwZVRva2VuID09IG51bGwgPyBFU0NBUEUgOiBub2RlLmVzY2FwZVRva2VuO1xuICAgICAgICAgICAgcmV0dXJuIFtlc2NhcGUsIC4uLl9wcmludFJhdyhub2RlLmNvbnRlbnQpLCAuLi5hcmdzU3RyaW5nXTtcbiAgICAgICAgY2FzZSBcInBhcmJyZWFrXCI6XG4gICAgICAgICAgICByZXR1cm4gW2xpbmVicmVhaywgbGluZWJyZWFrXTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIFtub2RlLmNvbnRlbnRdO1xuICAgICAgICBjYXNlIFwidmVyYlwiOlxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBFU0NBUEUsXG4gICAgICAgICAgICAgICAgbm9kZS5lbnYsXG4gICAgICAgICAgICAgICAgbm9kZS5lc2NhcGUsXG4gICAgICAgICAgICAgICAgLi4uX3ByaW50UmF3KG5vZGUuY29udGVudCksXG4gICAgICAgICAgICAgICAgbm9kZS5lc2NhcGUsXG4gICAgICAgICAgICBdO1xuICAgICAgICBjYXNlIFwid2hpdGVzcGFjZVwiOlxuICAgICAgICAgICAgcmV0dXJuIFtcIiBcIl07XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBcIkNhbm5vdCBmaW5kIHJlbmRlciBmb3Igbm9kZSBcIixcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgIGAob2YgdHlwZSAke3R5cGVvZiBub2RlfSlgXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIFtcIlwiICsgbm9kZV07XG4gICAgfVxufVxuXG4vKipcbiAqIFJlbmRlcnMgdGhlIEFTVCB0byBhIHN0cmluZyB3aXRob3V0IGFueSBwcmV0dHkgcHJpbnRpbmcuXG4gKlxuICogQHBhcmFtIHsqfSBub2RlXG4gKiBAcGFyYW0geyp9IG9wdGlvbnMgLSBTZXR0aW5nIGBhc0FycmF5YCB0byBgdHJ1ZWAgd2lsbCByZXR1cm4gYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgdGhlIHN5bWJvbCBgbGluZWJyZWFrYCwgc28gdGhhdCBwcmludGluZyBjYW4gYmUgY3VzdG9taXplZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByaW50UmF3KFxuICAgIG5vZGU6IFByaW50YWJsZSB8IFByaW50YWJsZVtdLFxuICAgIG9wdGlvbnM/OiB7IGFzQXJyYXk6IGZhbHNlIH1cbik6IHN0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBwcmludFJhdyhcbiAgICBub2RlOiBQcmludGFibGUgfCBQcmludGFibGVbXSxcbiAgICBvcHRpb25zOiB7IGFzQXJyYXk6IHRydWUgfVxuKTogUHJpbnRUb2tlbltdO1xuZXhwb3J0IGZ1bmN0aW9uIHByaW50UmF3KG5vZGU6IFByaW50YWJsZSB8IFByaW50YWJsZVtdLCBvcHRpb25zPzogb2JqZWN0KTogYW55IHtcbiAgICBjb25zdCBhc0FycmF5ID0gb3B0aW9ucyAhPSBudWxsID8gKG9wdGlvbnMgYXMgYW55KS5hc0FycmF5IDogZmFsc2U7XG4gICAgY29uc3QgcHJpbnRlZFRva2VucyA9IF9wcmludFJhdyhub2RlKTtcbiAgICBpZiAoYXNBcnJheSkge1xuICAgICAgICByZXR1cm4gcHJpbnRlZFRva2VucztcbiAgICB9XG4gICAgcmV0dXJuIHByaW50ZWRUb2tlbnMubWFwKCh4KSA9PiAoeCA9PT0gbGluZWJyZWFrID8gXCJcXG5cIiA6IHgpKS5qb2luKFwiXCIpO1xufVxuIiwiaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5pbXBvcnQgeyBtYXRjaCB9IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXV0aWwtbWF0Y2hcIjtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGFycmF5IGhhcyB3aGl0ZXNwYWNlIGF0IHRoZSBzdGFydC9lbmQuIENvbW1lbnRzIHdpdGggYGxlYWRpbmdXaGl0ZXNwYWNlID09PSB0cnVlYFxuICogYXJlIGNvdW50ZWQgYXMgd2hpdGVzcGFjZS4gT3RoZXIgY29tbWVudHMgYXJlIGlnbm9yZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNXaGl0ZXNwYWNlRXF1aXZhbGVudChub2RlczogQXN0Lk5vZGVbXSk6IHtcbiAgICBzdGFydDogYm9vbGVhbjtcbiAgICBlbmQ6IGJvb2xlYW47XG59IHtcbiAgICBsZXQgc3RhcnQgPSBmYWxzZTtcbiAgICBsZXQgZW5kID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChtYXRjaC5jb21tZW50KG5vZGUpKSB7XG4gICAgICAgICAgICAvLyBBIGNvbW1lbnQgd2l0aCBsZWFkaW5nIHdoaXRlc3BhY2Ugd2lsbCByZW5kZXIgd2l0aCBsZWFkaW5nIHdoaXRlc3BhY2UsXG4gICAgICAgICAgICAvLyBzbyBpZiB3ZSBlbmNvdW50ZXIgb25lLCB3ZSBzaG91bGQgY29uc2lkZXIgb3Vyc2VsdmVzIHRvIGhhdmUgbGVhZGluZyB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgaWYgKG5vZGUubGVhZGluZ1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2gud2hpdGVzcGFjZShub2RlKSkge1xuICAgICAgICAgICAgc3RhcnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gbm9kZXMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2pdO1xuICAgICAgICBpZiAobWF0Y2guY29tbWVudChub2RlKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUubGVhZGluZ1doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoLndoaXRlc3BhY2Uobm9kZSkpIHtcbiAgICAgICAgICAgIGVuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbn1cbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoXCI7XG5cbi8qKlxuICogVHJpbXMgd2hpdGVzcGFjZSBhbmQgcGFyYnJlYWtzIGZyb20gdGhlIHN0YXJ0IGFuZCBlbmRcbiAqIG9mIGFuIGFycmF5LiBUaGUgbnVtYmVyIG9mIHRyaW1tZWQgbm9kZXMgaXMgcmV0dXJuZWQuXG4gKiBTcGVjaWFsIGNhcmUgaXMgdGFrZW4gdG8gcHJlc2VydmUgY29tbWVudHMsIHRob3VnaCBhbnkgd2hpdGVzcGFjZVxuICogYmVmb3JlIHRoZSBmaXJzdCBjb21tZW50KHMpIG9yIGFmdGVyIHRoZSBsYXN0IGNvbW1lbnQocykgaXMgdHJpbW1lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW0obm9kZXM6IEFzdC5Ob2RlW10pOiB7XG4gICAgdHJpbW1lZFN0YXJ0OiBudW1iZXI7XG4gICAgdHJpbW1lZEVuZDogbnVtYmVyO1xufSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGVzKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJUcnlpbmcgdG8gdHJpbSBhIG5vbi1hcnJheSBhc3RcIiwgbm9kZXMpO1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuXG4gICAgY29uc3QgeyB0cmltbWVkU3RhcnQgfSA9IHRyaW1TdGFydChub2Rlcyk7XG4gICAgY29uc3QgeyB0cmltbWVkRW5kIH0gPSB0cmltRW5kKG5vZGVzKTtcblxuICAgIHJldHVybiB7IHRyaW1tZWRTdGFydCwgdHJpbW1lZEVuZCB9O1xufVxuXG4vKipcbiAqIFRyaW0gd2hpdGVzcGFjZSBhbmQgcGFyYnJlYWtzIGZyb20gdGhlIGxlZnQgb2YgYW4gYXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltU3RhcnQobm9kZXM6IEFzdC5Ob2RlW10pOiB7IHRyaW1tZWRTdGFydDogbnVtYmVyIH0ge1xuICAgIGNvbnN0IHsgc3RhcnQgfSA9IGFtb3VudE9mTGVhZGluZ0FuZFRyYWlsaW5nV2hpdGVzcGFjZShub2Rlcyk7XG5cbiAgICBub2Rlcy5zcGxpY2UoMCwgc3RhcnQpO1xuXG4gICAgLy8gSWYgdGhlcmUgYXJlIGNvbW1lbnRzIGF0IHRoZSBzdGFydCwgdGhleSBtaWdodCBoYXZlIGxlYWRpbmcgd2hpdGVzcGFjZS5cbiAgICAvLyBUaGlzIGxlYWRpbmcgd2hpdGVzcGFjZSBzaG91bGQgYmUgdHJpbW1lZFxuICAgIGZvciAoY29uc3QgbGVhZGluZ1Rva2VuIG9mIG5vZGVzKSB7XG4gICAgICAgIGlmICghbWF0Y2guY29tbWVudChsZWFkaW5nVG9rZW4pKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVhZGluZ1Rva2VuLmxlYWRpbmdXaGl0ZXNwYWNlIHx8IGxlYWRpbmdUb2tlbi5zYW1lbGluZSkge1xuICAgICAgICAgICAgbGVhZGluZ1Rva2VuLmxlYWRpbmdXaGl0ZXNwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBXZSByZW1vdmUgdGhlIHBvc2l0aW9uIGluZm9ybWF0aW9uIGZyb20gdGhpcyB0b2tlbiB0byBpbmRpY2F0ZSB0aGF0IHdlJ3ZlIGVkaXRlZCBpdFxuICAgICAgICAgICAgZGVsZXRlIGxlYWRpbmdUb2tlbi5wb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTcGVjaWFsIGNhcmUgbXVzdCBiZSB0YWtlbi4gSWYgdGhlIGNvbW1lbnQgd2FzIG9uIHRoZSBzYW1lIGxpbmUgYXMgYVxuICAgICAgICAvLyBwYXJza2lwLCBpdCB3aWxsIG5vIGxvbmdlciBiZSBvbiB0aGUgc2FtZSBsaW5lIGFmdGVyIHRoZSB0cmltbWluZy5cbiAgICAgICAgLy8gVGh1cywgd2UgbXVzdCBtb2RpZnkgdGhlIGNvbW1lbnQuXG4gICAgICAgIGlmIChzdGFydCA+IDAgJiYgbGVhZGluZ1Rva2VuLnNhbWVsaW5lKSB7XG4gICAgICAgICAgICBsZWFkaW5nVG9rZW4uc2FtZWxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGRlbGV0ZSBsZWFkaW5nVG9rZW4ucG9zaXRpb247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyB0cmltbWVkU3RhcnQ6IHN0YXJ0IH07XG59XG5cbi8qKlxuICogVHJpbSB3aGl0ZXNwYWNlIGFuZCBwYXJicmVha3MgZnJvbSB0aGUgcmlnaHQgb2YgYW4gYXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltRW5kKG5vZGVzOiBBc3QuTm9kZVtdKTogeyB0cmltbWVkRW5kOiBudW1iZXIgfSB7XG4gICAgY29uc3QgeyBlbmQgfSA9IGFtb3VudE9mTGVhZGluZ0FuZFRyYWlsaW5nV2hpdGVzcGFjZShub2Rlcyk7XG5cbiAgICBub2Rlcy5zcGxpY2Uobm9kZXMubGVuZ3RoIC0gZW5kLCBlbmQpO1xuXG4gICAgLy8gVHJpbSBvZmYgYW55IHNwYWNlcyBiZWxvbmdpbmcgdG8gdHJhaWxpbmcgY29tbWVudHNcbiAgICBmb3IgKGxldCBpID0gbm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgdHJhaWxpbmdUb2tlbiA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAoIW1hdGNoLmNvbW1lbnQodHJhaWxpbmdUb2tlbikpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGRvbid0IHRyaW0gc3BhY2VzIGJlZm9yZSB0cmFpbGluZyBzYW1lLWxpbmUgY29tbWVudHMuIFRoaXMgaXMgYSBzdHlsaXN0aWMgY2hvaWNlXG4gICAgICAgIC8vIHNvIHRoYXRcbiAgICAgICAgLy8gYGZvbyAleHh4YCBkb2VzIG5vdCBiZWNvbWUgYGZvbyV4eHhgLlxuICAgICAgICAvLyBUaGUgbGF0dGVyIGlzIHN0cmljdGx5IFwiY29ycmVjdFwiIGZvciBhIHRyaW0gZnVuY3Rpb24sIGJ1dCBpdCBpcyBwcmV0dGllciB0byBmb3JtYXRcbiAgICAgICAgLy8gY29kZSBwcmVzZXJ2aW5nIHRoZSBzcGFjZSBiZWZvcmUgdGhlIHNhbWVsaW5lIGNvbW1lbnRcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbWF0Y2guY29tbWVudCh0cmFpbGluZ1Rva2VuKSAmJlxuICAgICAgICAgICAgdHJhaWxpbmdUb2tlbi5sZWFkaW5nV2hpdGVzcGFjZSAmJlxuICAgICAgICAgICAgIXRyYWlsaW5nVG9rZW4uc2FtZWxpbmVcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0cmFpbGluZ1Rva2VuLmxlYWRpbmdXaGl0ZXNwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICBkZWxldGUgdHJhaWxpbmdUb2tlbi5wb3NpdGlvbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7IHRyaW1tZWRFbmQ6IGVuZCB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiB3aGl0ZXNwYWNlL3BhcmJyZWFrIG5vZGVzIGF0IHRoZSBzdGFydCBhbmQgZW5kIG9mIGFuIGFycmF5LlxuICovXG5mdW5jdGlvbiBhbW91bnRPZkxlYWRpbmdBbmRUcmFpbGluZ1doaXRlc3BhY2UoYXN0OiBBc3QuTm9kZVtdKToge1xuICAgIHN0YXJ0OiBudW1iZXI7XG4gICAgZW5kOiBudW1iZXI7XG59IHtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSAwO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBhc3QpIHtcbiAgICAgICAgaWYgKG1hdGNoLndoaXRlc3BhY2Uobm9kZSkgfHwgbWF0Y2gucGFyYnJlYWsobm9kZSkpIHtcbiAgICAgICAgICAgIHN0YXJ0Kys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGFydCA9PT0gYXN0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4geyBzdGFydCwgZW5kOiAwIH07XG4gICAgfVxuXG4gICAgLy8gRmluZCB0aGUgcGFkZGluZyBvbiB0aGUgcmlnaHRcbiAgICBmb3IgKGxldCBpID0gYXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBhc3RbaV07XG4gICAgICAgIGlmIChtYXRjaC53aGl0ZXNwYWNlKG5vZGUpIHx8IG1hdGNoLnBhcmJyZWFrKG5vZGUpKSB7XG4gICAgICAgICAgICBlbmQrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xufVxuIiwiaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSBcInVuaWZpZWRcIjtcbmltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoXCI7XG5pbXBvcnQgeyB2aXNpdCB9IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXV0aWwtdmlzaXRcIjtcbmltcG9ydCB7IHRyaW0sIHRyaW1FbmQsIHRyaW1TdGFydCB9IGZyb20gXCIuL3RyaW1cIjtcblxudHlwZSBQbHVnaW5PcHRpb25zID0gdm9pZDtcblxuLyoqXG4gKiBVbmlmaWVkIHBsdWdpbiB0byB0cmltIHRoZSB3aGl0ZXNwYWNlIGZyb20gdGhlIHN0YXJ0L2VuZCBvZiBhbnkgZW52aXJvbm1lbnRzLCBpbmNsdWRpbmdcbiAqIG1hdGggZW52aXJvbm1lbnRzLlxuICovXG5leHBvcnQgY29uc3QgdW5pZmllZExhdGV4VHJpbUVudmlyb25tZW50Q29udGVudHM6IFBsdWdpbjxcbiAgICBQbHVnaW5PcHRpb25zW10sXG4gICAgQXN0LlJvb3QsXG4gICAgQXN0LlJvb3Rcbj4gPSBmdW5jdGlvbiB1bmlmaWVkTGF0ZXhUcmltRW52aXJvbm1lbnRDb250ZW50cygpIHtcbiAgICByZXR1cm4gKHRyZWUpID0+IHtcbiAgICAgICAgdmlzaXQodHJlZSwgKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGlmICghKG1hdGNoLm1hdGgobm9kZSkgfHwgbWF0Y2guYW55RW52aXJvbm1lbnQobm9kZSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgdGhpbmcgaW4gdGhlIGVudmlyb25tZW50IGlzIGEgc2FtZWxpbmUgY29tbWVudCxcbiAgICAgICAgICAgIC8vIHdlIGFjdHVhbGx5IHdhbnQgdG8gc3RhcnQgdHJpbW1pbmcgKmFmdGVyKiBpdC5cbiAgICAgICAgICAgIGxldCBmaXJzdE5vZGUgPSBub2RlLmNvbnRlbnRbMF07XG4gICAgICAgICAgICBpZiAobWF0Y2guY29tbWVudChmaXJzdE5vZGUpICYmIGZpcnN0Tm9kZS5zYW1lbGluZSkge1xuICAgICAgICAgICAgICAgIGZpcnN0Tm9kZS5zdWZmaXhQYXJicmVhayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRyaW1FbmQobm9kZS5jb250ZW50KTtcblxuICAgICAgICAgICAgICAgIC8vIFdlIHBsYXkgYSBuYXN0eSB0cmljayBoZXJlLiBUaGlzIGNhbGwgdG8gYHRyaW1TdGFydGBcbiAgICAgICAgICAgICAgICAvLyB3aWxsIGFjdHVhbGx5IG1vZGlmeSBgbm9kZS5jb250ZW50YCBpZiBgbm9kZS5jb250ZW50LnNsaWNlKDEpYCBzdGFydHNcbiAgICAgICAgICAgICAgICAvLyB3aXRoIGEgY29tbWVudCB0aGF0IGhhcyBsZWFkaW5nIHdoaXRlc3BhY2UgKGl0IHdpbGwgcmVtb3ZlIHRoYXQgd2hpdGVzcGFjZSkuXG4gICAgICAgICAgICAgICAgLy8gSG93ZXZlciwgaXQgd29uJ3QgcmVtb3ZlIGFueSBlbGVtZW50cyBmcm9tIGBub2RlLmNvbnRlbnRgOyB3ZSBuZWVkXG4gICAgICAgICAgICAgICAgLy8gdG8gZG8gdGhhdCBvdXJzZWx2ZXMuXG4gICAgICAgICAgICAgICAgY29uc3QgeyB0cmltbWVkU3RhcnQgfSA9IHRyaW1TdGFydChub2RlLmNvbnRlbnQuc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgIG5vZGUuY29udGVudC5zcGxpY2UoMSwgdHJpbW1lZFN0YXJ0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJpbShub2RlLmNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufTtcbiIsImltcG9ydCB7IFBsdWdpbiB9IGZyb20gXCJ1bmlmaWVkXCI7XG5pbXBvcnQgKiBhcyBBc3QgZnJvbSBcIi4uLy4uL3VuaWZpZWQtbGF0ZXgtdHlwZXNcIjtcbmltcG9ydCB7IHRyaW0gfSBmcm9tIFwiLi90cmltXCI7XG5cbnR5cGUgUGx1Z2luT3B0aW9ucyA9IHZvaWQ7XG5cbi8qKlxuICogVW5pZmllZCBwbHVnaW4gdG8gdHJpbSB0aGUgd2hpdGVzcGFjZSBmcm9tIHRoZSBzdGFydC9lbmQgb2YgdGhlIHJvb3QgZWxlbWVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IHVuaWZpZWRMYXRleFRyaW1Sb290OiBQbHVnaW48UGx1Z2luT3B0aW9uc1tdLCBBc3QuUm9vdCwgQXN0LlJvb3Q+ID1cbiAgICBmdW5jdGlvbiB1bmlmaWVkTGF0ZXhUcmltUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuICh0cmVlKSA9PiB7XG4gICAgICAgICAgICB0cmltKHRyZWUuY29udGVudCk7XG4gICAgICAgIH07XG4gICAgfTtcbiIsImV4cG9ydCAqIGZyb20gXCIuL2xpYnMvdmlzaXRcIjtcblxuLy8gTk9URTogVGhlIGRvY3N0cmluZyBjb21tZW50IG11c3QgYmUgdGhlIGxhc3QgaXRlbSBpbiB0aGUgaW5kZXgudHMgZmlsZSFcbi8qKlxuICogIyMgV2hhdCBpcyB0aGlzP1xuICpcbiAqIEZ1bmN0aW9ucyB0byB0cmF2ZXJzZSBhIGB1bmlmaWVkLWxhdGV4YCBBYnN0cmFjdCBTeW50YXggVHJlZSAoQVNUKS4gYHZpc2l0YCBpc1xuICogdmVyeSBzaW1pbGFyIHRvIFtlc3RyZWUtdXRpbC12aXNpdF0oaHR0cHM6Ly9naXRodWIuY29tL3N5bnRheC10cmVlL2VzdHJlZS11dGlsLXZpc2l0KS5cbiAqXG4gKiAjIyBXaGVuIHNob3VsZCBJIHVzZSB0aGlzP1xuICpcbiAqIElmIHlvdSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJlcGxhY2UgcGFydGljdWxhciBBU1Qgbm9kZXMuXG4gKi9cbiIsImltcG9ydCAqIGFzIEFzdCBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC10eXBlc1wiO1xuaW1wb3J0IHsgbWF0Y2ggfSBmcm9tIFwiLi4vLi4vdW5pZmllZC1sYXRleC11dGlsLW1hdGNoXCI7XG5cbi8qKlxuICogTGlzdCBhbGwgcHJvcHMgb2YgdGhlIGN1cnJlbnQgbm9kZSB0aGF0IHNob3VsZCBiZSBwcm9jZXNzZWRcbiAqIGluIG1hdGggbW9kZSBvciBub3QgaW4gbWF0aCBtb2RlLiBJZiBtYXRoIG1vZGUgaXMgbm90IHNwZWNpZmllZCBpbiB0aGUgbm9kZSdzIHJlbmRlclxuICogaW5mbywgZW1wdHkgbGlzdHMgYXJlIHJldHVybmVkLlxuICpcbiAqIEZvciBleGFtcGxlIGBcXHRleHR7Zm9vfWAgd2lsbCByZXBvcnQgdGhhdCBgYXJnc2Agc2hvdWxkICpub3QqIGJlIHByb2Nlc3NlZCBpbiBtYXRoIG1vZGUsXG4gKiBzaW5jZSBpdCdzIGNvbnRlbnRzIHNob3VsZCBhbHdheXMgYmUgcHJvY2Vzc2VkIGluIHRleHQgbW9kZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3RNYXRoQ2hpbGRyZW4obm9kZTogQXN0LkFzdCk6IHtcbiAgICBlbnRlcjogc3RyaW5nW107XG4gICAgbGVhdmU6IHN0cmluZ1tdO1xufSB7XG4gICAgY29uc3QgTlVMTF9SRVRVUk4gPSB7IGVudGVyOiBbXSwgbGVhdmU6IFtdIH07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIE5VTExfUkVUVVJOO1xuICAgIH1cbiAgICBpZiAobWF0Y2gubWF0aChub2RlKSkge1xuICAgICAgICAvLyBXaGVuIHdlIGVudGVyIGEgbWF0aCBlbnZpcm9ubWVudCwgb3VyIGNvbnRlbnQgaXMgYWx3YXlzXG4gICAgICAgIC8vIGNvbnNpZGVyZWQgbWF0aCBtb2RlXG4gICAgICAgIHJldHVybiB7IGVudGVyOiBbXCJjb250ZW50XCJdLCBsZWF2ZTogW10gfTtcbiAgICB9XG5cbiAgICBjb25zdCByZW5kZXJJbmZvOiB7IGluTWF0aE1vZGU/OiBib29sZWFuIH0gPSBub2RlLl9yZW5kZXJJbmZvIHx8IHt9O1xuICAgIGlmIChyZW5kZXJJbmZvLmluTWF0aE1vZGUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gTlVMTF9SRVRVUk47XG4gICAgfVxuICAgIGlmIChtYXRjaC5tYWNybyhub2RlKSkge1xuICAgICAgICBpZiAocmVuZGVySW5mby5pbk1hdGhNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlbnRlcjogW1wiYXJnc1wiXSwgbGVhdmU6IFtdIH07XG4gICAgICAgIH0gZWxzZSBpZiAocmVuZGVySW5mby5pbk1hdGhNb2RlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgZW50ZXI6IFtdLCBsZWF2ZTogW1wiYXJnc1wiXSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRjaC5lbnZpcm9ubWVudChub2RlKSkge1xuICAgICAgICBpZiAocmVuZGVySW5mby5pbk1hdGhNb2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlbnRlcjogW1wiY29udGVudFwiXSwgbGVhdmU6IFtdIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBlbnRlcjogW10sIGxlYXZlOiBbXCJjb250ZW50XCJdIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE5VTExfUkVUVVJOO1xufVxuIiwiaW1wb3J0ICogYXMgQXN0IGZyb20gXCIuLi8uLi91bmlmaWVkLWxhdGV4LXR5cGVzXCI7XG5pbXBvcnQgeyBsaXN0TWF0aENoaWxkcmVuIH0gZnJvbSBcIi4vbGlzdC1tYXRoLWNoaWxkcmVuXCI7XG5cbmV4cG9ydCB0eXBlIFZpc2l0b3JDb250ZXh0ID0ge1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIG5vZGUgaXMgYmVpbmcgcHJvY2Vzc2VkIGluIG1hdGggbW9kZS5cbiAgICAgKlxuICAgICAqIFRoaXMgaGFwcGVucyB3aGVuIHRoZSBub2RlIGlzIGEgZGlyZWN0b3Igb3IgaW5kaXJlY3QgY2hpbGRcbiAgICAgKiBvZiBhIG1hdGggZW52aXJvbm1lbnQgKGUuZy4gYCRhYmMkYCksIGJ1dCBub3Qgd2hlbiBhbiBlbnZpcm9ubWVudFxuICAgICAqIHJlLWVzdGFibGlzaGVzIHRleHQgbW9kZSAoZS5nLiBgJFxcdGV4dHthYmN9JGApXG4gICAgICovXG4gICAgaW5NYXRoTW9kZT86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgbm9kZSBoYXMgYW55IGFuY2VzdG9yIHRoYXQgaXMgcHJvY2Vzc2VkIGluIG1hdGggbW9kZS5cbiAgICAgKi9cbiAgICBoYXNNYXRoTW9kZUFuY2VzdG9yPzogYm9vbGVhbjtcbn07XG5cbnR5cGUgR2V0R3VhcmQ8VD4gPSBUIGV4dGVuZHMgKHg6IGFueSkgPT4geCBpcyBpbmZlciBSID8gUiA6IG5ldmVyO1xuLyoqXG4gKiBHZXRzIHRoZSB0eXBlIHRoYXQgYSB0eXBlLWd1YXJkIGZ1bmN0aW9uIGlzIGd1YXJkaW5nLiBJZlxuICogdGhlIGd1YXJkIHR5cGUgY2Fubm90IGJlIGRldGVybWluZWQsIHRoZSBpbnB1dCB0eXBlIGlzIHJldHVybmVkLlxuICovXG50eXBlIEd1YXJkVHlwZU9mPFQgZXh0ZW5kcyAoeDogYW55KSA9PiBib29sZWFuPiA9IEdldEd1YXJkPFQ+IGV4dGVuZHMgbmV2ZXJcbiAgICA/IFQgZXh0ZW5kcyAoeDogaW5mZXIgQSkgPT4gYW55XG4gICAgICAgID8gQVxuICAgICAgICA6IG5ldmVyXG4gICAgOiBHZXRHdWFyZDxUPjtcblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgZ3VhcmQgdHlwZSBmcm9tIHRoZSBgdGVzdGAgZnVuY3Rpb24gcHJvdmlkZWQgaW4gYVxuICogYFZpc2l0T3B0aW9uc2AgYXJndW1lbnQuXG4gKi9cbnR5cGUgR3VhcmRGcm9tT3B0aW9uczxcbiAgICBPcHRzIGV4dGVuZHMgVmlzaXRPcHRpb25zLFxuICAgIFBvc3NpYmxlVHlwZXMgPSBBc3QuQXN0XG4+ID0gT3B0cyBleHRlbmRzIHtcbiAgICB0ZXN0OiBpbmZlciBSO1xufVxuICAgID8gUiBleHRlbmRzICh4OiBhbnkpID0+IGJvb2xlYW5cbiAgICAgICAgPyAvLyBBIGd1YXJkIGxpa2UgYHR5cGVvZiBBcnJheS5pc0FycmF5YCB3aWxsIHJldHVybiBgYW55W11gIGFzIHRoZSB0eXBlLlxuICAgICAgICAgIC8vIFRoaXMgdHlwZSBjYW5ub3QgYmUgbmFycm93ZWQsIHNvIGluc3RlYWQgd2UgdXNlIGl0IHRvIHBpY2sgZnJvbVxuICAgICAgICAgIC8vIHRoZSBzZXQgb2YgYWxsIHBvc3NpYmxlIHR5cGVzLlxuICAgICAgICAgIEV4dHJhY3Q8UG9zc2libGVUeXBlcywgR3VhcmRUeXBlT2Y8Uj4+XG4gICAgICAgIDogUG9zc2libGVUeXBlc1xuICAgIDogUG9zc2libGVUeXBlcztcblxuLyoqXG4gKiBOYXJyb3cgdGhlIHR5cGUgYFRgIGJhc2VkIG9uIHRoZSBgVmlzaXRPcHRpb25zYCBzdXBwbGllZC4gSWYgYHtpbmNsdWRlQXJyYXlzOiBmYWxzZX1gXG4gKiBpcyBzcGVjaWZpZWQgaW4gdGhlIGBWaXNpdE9wdGlvbnNgLCB0aGVuIGFycmF5cyBhcmUgZXhjbHVkZWQgZnJvbSBgVGAuXG4gKi9cbnR5cGUgTmFycm93QXJyYXlzQmFzZWRPbk9wdGlvbnM8VCwgT3B0cyBleHRlbmRzIFZpc2l0T3B0aW9ucz4gPSBPcHRzIGV4dGVuZHMge1xuICAgIGluY2x1ZGVBcnJheXM6IGluZmVyIEE7XG59XG4gICAgPyBBIGV4dGVuZHMgdHJ1ZVxuICAgICAgICA/IFRcbiAgICAgICAgOiBFeGNsdWRlPFQsIGFueVtdPlxuICAgIDogRXhjbHVkZTxULCBhbnlbXT47XG5cbi8qKlxuICogR2V0IHRoZSB0eXBlIG9mIHRoZSBwYXJhbWV0ZXIgdG8gdGhlIGBWaXNpdG9yYCBmdW5jdGlvbiBiYXNlZCBvbiB0aGVcbiAqIGBWaXNpdE9wdGlvbnNgIHRoYXQgYXJlIHN1cHBsaWVkLlxuICovXG50eXBlIFZpc2l0b3JUeXBlRnJvbU9wdGlvbnM8T3B0cyBleHRlbmRzIFZpc2l0T3B0aW9ucz4gPVxuICAgIE5hcnJvd0FycmF5c0Jhc2VkT25PcHRpb25zPEd1YXJkRnJvbU9wdGlvbnM8T3B0cz4sIE9wdHM+O1xuXG4vKipcbiAqIENvbnRpbnVlIHRyYXZlcnNpbmcgYXMgbm9ybWFsXG4gKi9cbmV4cG9ydCBjb25zdCBDT05USU5VRSA9IFN5bWJvbChcImNvbnRpbnVlXCIpO1xuLyoqXG4gKiBEbyBub3QgdHJhdmVyc2UgdGhpcyBub2Rl4oCZcyBjaGlsZHJlblxuICovXG5leHBvcnQgY29uc3QgU0tJUCA9IFN5bWJvbChcInNraXBcIik7XG4vKipcbiAqIFN0b3AgdHJhdmVyc2luZyBpbW1lZGlhdGVseVxuICovXG5leHBvcnQgY29uc3QgRVhJVCA9IFN5bWJvbChcImV4aXRcIik7XG5cbnR5cGUgQWN0aW9uID0gdHlwZW9mIENPTlRJTlVFIHwgdHlwZW9mIFNLSVAgfCB0eXBlb2YgRVhJVDtcbnR5cGUgSW5kZXggPSBudW1iZXI7XG50eXBlIEFjdGlvblR1cGxlID0gW0FjdGlvbl0gfCBbdHlwZW9mIFNLSVAsIEluZGV4XSB8IFt0eXBlb2YgQ09OVElOVUUsIEluZGV4XTtcblxuLyoqXG4gKiBBIHZpc2l0b3IgdGFrZXMgYSBgbm9kZWAsIGBrZXlgLCBgaW5kZXhgLCBhbmQgLi4uXG4gKlxuICogQHBhcmFtIGtleSAtIFRoZSBrZXkgb2YgdGhlIHBhcmVudCB0aGF0IHdlIHdlcmUgYWNjZXNzZWQgdGhyb3VnaC5cbiAqL1xudHlwZSBWaXNpdG9yPFQ+ID0gKFxuICAgIG5vZGU6IFQsXG4gICAgaW5mbzogVmlzaXRJbmZvXG4pID0+IG51bGwgfCB1bmRlZmluZWQgfCBBY3Rpb24gfCBJbmRleCB8IEFjdGlvblR1cGxlIHwgdm9pZDtcbnR5cGUgVmlzaXRvcnM8VD4gPSB7IGVudGVyPzogVmlzaXRvcjxUPjsgbGVhdmU/OiBWaXNpdG9yPFQ+IH07XG5cbnR5cGUgVmlzaXRPcHRpb25zID0ge1xuICAgIHN0YXJ0aW5nQ29udGV4dD86IFZpc2l0b3JDb250ZXh0O1xuICAgIC8qKlxuICAgICAqIFR5cGUgZ3VhcmQgZm9yIHR5cGVzIHRoYXQgYXJlIHBhc3NlZCB0byB0aGUgYHZpc2l0b3JgIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHRlc3Q/OiAobm9kZTogQXN0LkFzdCwgaW5mbzogVmlzaXRJbmZvKSA9PiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgYXJyYXlzIHdpbGwgYmUgc2VudCB0byB0aGUgYHZpc2l0b3JgIGZ1bmN0aW9uLiBJZiBmYWxzeSxcbiAgICAgKiBvbmx5IG5vZGVzIHdpbGwgYmUgcGFzdCB0byBgdmlzaXRvcmAuXG4gICAgICovXG4gICAgaW5jbHVkZUFycmF5cz86IGJvb2xlYW47XG59O1xuXG5jb25zdCBERUZBVUxUX0NPTlRFWFQ6IFZpc2l0b3JDb250ZXh0ID0ge1xuICAgIGluTWF0aE1vZGU6IGZhbHNlLFxuICAgIGhhc01hdGhNb2RlQW5jZXN0b3I6IGZhbHNlLFxufTtcblxuZXhwb3J0IHR5cGUgVmlzaXRJbmZvID0ge1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBlbGVtZW50IHdhcyBhY2Nlc3NlZCB2aWEgYW4gYXR0cmlidXRlLCB0aGUgYXR0cmlidXRlIGtleSBpcyBzcGVjaWZpZWQuXG4gICAgICovXG4gICAgcmVhZG9ubHkga2V5OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGVsZW1lbnQgd2FzIGFjY2Vzc2VkIGluIGFuIGFycmF5LCB0aGUgaW5kZXggaXMgc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGluZGV4OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIGFuY2VzdG9yIG5vZGVzLCBgW3BhcmVudCwgZ3JhbmRwYXJlbnQsIGdyZWF0LWdyYW5kcGFyZW50LCAuLi5dYFxuICAgICAqL1xuICAgIHJlYWRvbmx5IHBhcmVudHM6IChBc3QuTm9kZSB8IEFzdC5Bcmd1bWVudClbXTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgZWxlbWVudCB3YXMgYWNjZXNzZWQgaW4gYW4gYXJyYXksIHRoZSBhcnJheSB0aGF0IGl0IGlzIHBhcnQgb2YuXG4gICAgICovXG4gICAgcmVhZG9ubHkgY29udGFpbmluZ0FycmF5OiAoQXN0Lk5vZGUgfCBBc3QuQXJndW1lbnQpW10gfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogVGhlIExhVGVYIGNvbnRleHQgb2YgdGhlIGN1cnJlbnQgbWF0Y2guXG4gICAgICovXG4gICAgcmVhZG9ubHkgY29udGV4dDogVmlzaXRvckNvbnRleHQ7XG59O1xuXG4vKipcbiAqIFZpc2l0IGNoaWxkcmVuIG9mIHRyZWUgd2hpY2ggcGFzcyBhIHRlc3RcbiAqXG4gKiBAcGFyYW0ge05vZGV9IHRyZWUgQWJzdHJhY3Qgc3ludGF4IHRyZWUgdG8gd2Fsa1xuICogQHBhcmFtIHtWaXNpdG9yfFZpc2l0b3JzfSBbdmlzaXRvcl0gRnVuY3Rpb24gdG8gcnVuIGZvciBlYWNoIG5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZpc2l0PE9wdHMgZXh0ZW5kcyBWaXNpdE9wdGlvbnM+KFxuICAgIHRyZWU6IEFzdC5Bc3QsXG4gICAgdmlzaXRvcjpcbiAgICAgICAgfCBWaXNpdG9yPFZpc2l0b3JUeXBlRnJvbU9wdGlvbnM8T3B0cz4+XG4gICAgICAgIHwgVmlzaXRvcnM8VmlzaXRvclR5cGVGcm9tT3B0aW9uczxPcHRzPj4sXG4gICAgb3B0aW9ucz86IE9wdHNcbikge1xuICAgIGNvbnN0IHtcbiAgICAgICAgc3RhcnRpbmdDb250ZXh0ID0gREVGQVVMVF9DT05URVhULFxuICAgICAgICB0ZXN0ID0gKCkgPT4gdHJ1ZSxcbiAgICAgICAgaW5jbHVkZUFycmF5cyA9IGZhbHNlLFxuICAgIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGxldCBlbnRlcjogVmlzaXRvcjxWaXNpdG9yVHlwZUZyb21PcHRpb25zPE9wdHM+PiB8IHVuZGVmaW5lZDtcbiAgICBsZXQgbGVhdmU6IFZpc2l0b3I8VmlzaXRvclR5cGVGcm9tT3B0aW9uczxPcHRzPj4gfCB1bmRlZmluZWQ7XG5cbiAgICBpZiAodHlwZW9mIHZpc2l0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBlbnRlciA9IHZpc2l0b3I7XG4gICAgfSBlbHNlIGlmICh2aXNpdG9yICYmIHR5cGVvZiB2aXNpdG9yID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGVudGVyID0gdmlzaXRvci5lbnRlcjtcbiAgICAgICAgbGVhdmUgPSB2aXNpdG9yLmxlYXZlO1xuICAgIH1cblxuICAgIHdhbGsodHJlZSwge1xuICAgICAgICBrZXk6IHVuZGVmaW5lZCxcbiAgICAgICAgaW5kZXg6IHVuZGVmaW5lZCxcbiAgICAgICAgcGFyZW50czogW10sXG4gICAgICAgIGNvbnRhaW5pbmdBcnJheTogdW5kZWZpbmVkLFxuICAgICAgICBjb250ZXh0OiB7IC4uLnN0YXJ0aW5nQ29udGV4dCB9LFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmc/fSBrZXlcbiAgICAgKiBAcGFyYW0ge251bWJlcj99IGluZGV4XG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IHBhcmVudHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3YWxrKFxuICAgICAgICBub2RlOiBBc3QuQXN0LFxuICAgICAgICB7IGtleSwgaW5kZXgsIHBhcmVudHMsIGNvbnRleHQsIGNvbnRhaW5pbmdBcnJheSB9OiBWaXNpdEluZm9cbiAgICApOiBBY3Rpb25UdXBsZSB7XG4gICAgICAgIGNvbnN0IG5vZGVQYXNzZXNUZXN0ID0gaW5jbHVkZUFycmF5c1xuICAgICAgICAgICAgPyB0ZXN0KG5vZGUsIHsga2V5LCBpbmRleCwgcGFyZW50cywgY29udGV4dCwgY29udGFpbmluZ0FycmF5IH0pXG4gICAgICAgICAgICA6ICFBcnJheS5pc0FycmF5KG5vZGUpICYmXG4gICAgICAgICAgICAgIHRlc3Qobm9kZSwgeyBrZXksIGluZGV4LCBwYXJlbnRzLCBjb250ZXh0LCBjb250YWluaW5nQXJyYXkgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0OiBBY3Rpb25UdXBsZSA9XG4gICAgICAgICAgICBlbnRlciAmJiBub2RlUGFzc2VzVGVzdFxuICAgICAgICAgICAgICAgID8gdG9SZXN1bHQoXG4gICAgICAgICAgICAgICAgICAgICAgZW50ZXIobm9kZSBhcyBhbnksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmluZ0FycmF5LFxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBbQ09OVElOVUVdO1xuXG4gICAgICAgIGlmIChyZXN1bHRbMF0gPT09IEVYSVQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzdWx0WzBdID09PSBTS0lQKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVhdmUgJiYgbm9kZVBhc3Nlc1Rlc3RcbiAgICAgICAgICAgICAgICA/IHRvUmVzdWx0KFxuICAgICAgICAgICAgICAgICAgICAgIGxlYXZlKG5vZGUgYXMgYW55LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5pbmdBcnJheSxcbiAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIDogcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgICAgIC8vIFRoZSBgdmFsdWVgIGFycmF5IG1pZ2h0IGJlIG1vZGlmaWVkIGluIHBsYWNlIGFzIHdlIHRyYXZlcnNlIGl0LCBzb1xuICAgICAgICAgICAgLy8gd2UgdXNlIGEgdHJhZGl0aW9uYWwgZm9yIGxvb3AuXG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4ID4gLTEgJiYgaW5kZXggPCBub2RlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBub2RlW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB3YWxrKGl0ZW0sIHtcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50cyxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmluZ0FycmF5OiBub2RlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbMF0gPT09IEVYSVQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRbMV0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZvciBsb29wIHdpbGwgaW5jcmVtZW50IGkgZXZlcnkgcGFzcy4gSG93ZXZlcixcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgYW4gaW5kZXggd2FzIHJldHVybmVkLCB0aGF0J3Mgd2hlcmUgd2Ugd2FudCB0byBzdGFydCBuZXh0IHRpbWUuXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcmVzdWx0WzFdIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHJlY3Vyc2l2ZWx5IGFwcGx5IHRvIHRoZSBgY29udGVudGBcbiAgICAgICAgICAgIC8vIG9mIGFsbCB0eXBlcyAoZS5nLiwgY29tbWVudHMgYW5kIG1hY3JvcyksIHNvIHNwZWNpZnlcbiAgICAgICAgICAgIC8vIGEgYmxhY2tsaXN0LlxuICAgICAgICAgICAgbGV0IGNoaWxkUHJvcHM6IChcImNvbnRlbnRcIiB8IFwiYXJnc1wiKVtdID0gW1wiY29udGVudFwiLCBcImFyZ3NcIl07XG4gICAgICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtYWNyb1wiOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZFByb3BzID0gW1wiYXJnc1wiXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbW1lbnRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInZlcmJcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidmVyYmF0aW1cIjpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRQcm9wcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbWF0aE1vZGVQcm9wcyA9IGxpc3RNYXRoQ2hpbGRyZW4obm9kZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBjaGlsZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBub2RlW2tleSBhcyBrZXlvZiB0eXBlb2Ygbm9kZV0gYXNcbiAgICAgICAgICAgICAgICAgICAgfCBBc3QuQXN0XG4gICAgICAgICAgICAgICAgICAgIHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyYW5kcGFyZW50cyA9IFtub2RlXS5jb25jYXQocGFyZW50cyk7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBtYXkgc3dpdGNoIGluL291dCBvZiBtYXRoIG1vZGUgYXMgd2UgcGFzcyB0byBub2RlW2tleV1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdDb250ZXh0ID0geyAuLi5jb250ZXh0IH07XG4gICAgICAgICAgICAgICAgaWYgKG1hdGhNb2RlUHJvcHMuZW50ZXIuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0LmluTWF0aE1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250ZXh0Lmhhc01hdGhNb2RlQW5jZXN0b3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0aE1vZGVQcm9wcy5sZWF2ZS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRleHQuaW5NYXRoTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHdhbGsodmFsdWUsIHtcbiAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRzOiBncmFuZHBhcmVudHMsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IG5ld0NvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5pbmdBcnJheTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRbMF0gPT09IEVYSVQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGVhdmUgJiYgbm9kZVBhc3Nlc1Rlc3RcbiAgICAgICAgICAgID8gdG9SZXN1bHQoXG4gICAgICAgICAgICAgICAgICBsZWF2ZShub2RlIGFzIGFueSwge1xuICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgY29udGFpbmluZ0FycmF5LFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiByZXN1bHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEVuc3VyZXMgYSByZXN1bHQgaXMgYW4gYEFjdGlvblR1cGxlYHNcbiAqL1xuZnVuY3Rpb24gdG9SZXN1bHQoXG4gICAgdmFsdWU6IG51bGwgfCB1bmRlZmluZWQgfCB2b2lkIHwgQWN0aW9uIHwgSW5kZXggfCBBY3Rpb25UdXBsZVxuKTogQWN0aW9uVHVwbGUge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbQ09OVElOVUVdO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gW0NPTlRJTlVFLCB2YWx1ZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFt2YWx1ZV07XG59XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsImV4cG9ydCAqIGZyb20gXCIuL2xpYnMvdHJpbVwiO1xuZXhwb3J0ICogZnJvbSBcIi4vbGlicy91bmlmaWVkLWxhdGV4LXRyaW0tZW52aXJvbm1lbnQtY29udGVudHNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2xpYnMvdW5pZmllZC1sYXRleC10cmltLXJvb3RcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2xpYnMvaGFzLXdoaXRlc3BhY2UtZXF1aXZhbGVudFwiO1xuXG4vLyBOT1RFOiBUaGUgZG9jc3RyaW5nIGNvbW1lbnQgbXVzdCBiZSB0aGUgbGFzdCBpdGVtIGluIHRoZSBpbmRleC50cyBmaWxlIVxuLyoqXG4gKiAjIyBXaGF0IGlzIHRoaXM/XG4gKlxuICogRnVuY3Rpb25zIHRvIGhlbHAgbW9kaWZ5IGEgYHVuaWZpZWQtbGF0ZXhgIEFic3RyYWN0IFN5bnRheCBUcmVlIChBU1QpLlxuICpcbiAqICMjIFdoZW4gc2hvdWxkIEkgdXNlIHRoaXM/XG4gKlxuICogSWYgeW91IHdhbnQgdG8gcmVtb3ZlIHdoaXRlc3BhY2UgZnJvbSB0aGUgZW5kcyBvZiBhbiBhcnJheSBvZiBub2Rlcy5cbiAqXG4gKiBOb3RlIHRoYXQgd2hpdGVzcGFjZSBjYW4gY29tZSBmcm9tIGEgYEFzdC5XaGl0ZXNwYWNlYCBub2RlIG9yIGZyb20gYW5cbiAqIGBBc3QuQ29tbWVudGAgbm9kZSB0aGF0IGhhcyBsZWFkaW5nIHdoaXRlc3BhY2UuIFRoZXNlIGZ1bmN0aW9ucyB0YWtlIGNhcmVcbiAqIHRvIGRlYWwgd2l0aCBib3RoIHNpdHVhdGlvbnMuXG4gKi9cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==