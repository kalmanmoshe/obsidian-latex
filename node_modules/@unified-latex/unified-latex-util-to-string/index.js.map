{"version":3,"file":"index.js","sources":["../libs/compiler-string.ts","../libs/to-string.ts"],"sourcesContent":["import Prettier from \"prettier/standalone.js\";\nimport { Plugin } from \"unified\";\nimport { printLatexAst } from \"@unified-latex/unified-latex-prettier\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { printRaw } from \"@unified-latex/unified-latex-util-print-raw\";\n\nexport type PluginOptions =\n    | {\n          pretty?: boolean;\n          printWidth?: number;\n          useTabs?: boolean;\n          /**\n           * If true, formatted code always ends with a newline character.\n           */\n          forceNewlineEnding?: boolean;\n      }\n    | undefined;\n\n/**\n * Unified complier plugin that prints a LaTeX AST as a string.\n */\nexport const unifiedLatexStringCompiler: Plugin<\n    PluginOptions[],\n    Ast.Root,\n    string\n> = function unifiedLatexStringCompiler(options) {\n    const {\n        pretty = false,\n        printWidth = 80,\n        useTabs = true,\n        forceNewlineEnding = false,\n    } = options || {};\n\n    const prettyPrinter = (ast: Ast.Root) => {\n        // We have already processed the AST. All we want prettier to do is the final\n        // text formatting. We create a dummy parser and directly return the ast.\n        // Note: if prettier is asked to format the empty string, it will not call the parsers, so we pass in \"_\"\n        let formatted = Prettier.format(\"_\", {\n            useTabs,\n            printWidth,\n            parser: \"latex-dummy-parser\",\n            plugins: [\n                {\n                    languages: [\n                        {\n                            name: \"latex\",\n                            extensions: [\".tex\"],\n                            parsers: [\"latex-dummy-parser\"],\n                        },\n                    ],\n                    parsers: {\n                        \"latex-dummy-parser\": {\n                            parse: () => ast,\n                            astFormat: \"latex-ast\",\n                            locStart: () => 0,\n                            locEnd: () => 1,\n                        },\n                    },\n                    printers: {\n                        \"latex-ast\": {\n                            print: printLatexAst as any,\n                        },\n                    },\n                },\n            ],\n            ...(options || {}),\n        });\n\n        if (forceNewlineEnding && !formatted.endsWith(\"\\n\")) {\n            formatted += \"\\n\";\n        }\n\n        return formatted;\n    };\n\n    Object.assign(this, {\n        Compiler: (ast: Ast.Root) => {\n            if (!pretty) {\n                return printRaw(ast);\n            }\n            return prettyPrinter(ast);\n        },\n    });\n};\n","import { unified } from \"unified\";\nimport * as Ast from \"@unified-latex/unified-latex-types\";\nimport { unifiedLatexStringCompiler } from \"./compiler-string\";\n\nconst processor = unified()\n    .use(unifiedLatexStringCompiler, { pretty: true })\n    .freeze();\n\n/**\n * Convert an AST into a string, pretty-printing the result. If you want more control\n * over the formatting (e.g. spaces/tabs, etc.) use `unified().use(unifiedLatexStringCompiler, options)`\n * directly.\n */\nexport function toString(ast: Ast.Ast): string {\n    if (Array.isArray(ast)) {\n        ast = { type: \"root\", content: ast };\n    }\n    if (ast.type !== \"root\") {\n        ast = { type: \"root\", content: [ast as Ast.Node] };\n    }\n    return processor.stringify(ast);\n}\n"],"names":["unifiedLatexStringCompiler"],"mappings":";;;;AAqBa,MAAA,6BAIT,SAASA,4BAA2B,SAAS;AACvC,QAAA;AAAA,IACF,SAAS;AAAA,IACT,aAAa;AAAA,IACb,UAAU;AAAA,IACV,qBAAqB;AAAA,EACzB,IAAI,WAAW,CAAC;AAEV,QAAA,gBAAgB,CAAC,QAAkB;AAIjC,QAAA,YAAY,SAAS,OAAO,KAAK;AAAA,MACjC;AAAA,MACA;AAAA,MACA,QAAQ;AAAA,MACR,SAAS;AAAA,QACL;AAAA,UACI,WAAW;AAAA,YACP;AAAA,cACI,MAAM;AAAA,cACN,YAAY,CAAC,MAAM;AAAA,cACnB,SAAS,CAAC,oBAAoB;AAAA,YAAA;AAAA,UAEtC;AAAA,UACA,SAAS;AAAA,YACL,sBAAsB;AAAA,cAClB,OAAO,MAAM;AAAA,cACb,WAAW;AAAA,cACX,UAAU,MAAM;AAAA,cAChB,QAAQ,MAAM;AAAA,YAAA;AAAA,UAEtB;AAAA,UACA,UAAU;AAAA,YACN,aAAa;AAAA,cACT,OAAO;AAAA,YAAA;AAAA,UACX;AAAA,QACJ;AAAA,MAER;AAAA,MACA,GAAI,WAAW,CAAA;AAAA,IAAC,CACnB;AAED,QAAI,sBAAsB,CAAC,UAAU,SAAS,IAAI,GAAG;AACpC,mBAAA;AAAA,IAAA;AAGV,WAAA;AAAA,EACX;AAEA,SAAO,OAAO,MAAM;AAAA,IAChB,UAAU,CAAC,QAAkB;AACzB,UAAI,CAAC,QAAQ;AACT,eAAO,SAAS,GAAG;AAAA,MAAA;AAEvB,aAAO,cAAc,GAAG;AAAA,IAAA;AAAA,EAC5B,CACH;AACL;AC/EA,MAAM,YAAY,QAAQ,EACrB,IAAI,4BAA4B,EAAE,QAAQ,MAAM,EAChD,OAAO;AAOL,SAAS,SAAS,KAAsB;AACvC,MAAA,MAAM,QAAQ,GAAG,GAAG;AACpB,UAAM,EAAE,MAAM,QAAQ,SAAS,IAAI;AAAA,EAAA;AAEnC,MAAA,IAAI,SAAS,QAAQ;AACrB,UAAM,EAAE,MAAM,QAAQ,SAAS,CAAC,GAAe,EAAE;AAAA,EAAA;AAE9C,SAAA,UAAU,UAAU,GAAG;AAClC;"}